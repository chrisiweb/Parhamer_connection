%!PS-Adobe-2.0
%%Creator: dvips(k) 5.997 Copyright 2017 Radical Eye Software
%%Title: C:/Users/Chris Notebook/Dropbox/Aufgabensammlung (offiziell)/Typ 1 Aufgaben/_Matura/AN - Analysis/AN 3.2/AN 3.2 Gesamtdokument.dvi
%%CreationDate: Fri Nov 10 07:41:52 2017
%%Pages: 14
%%PageOrder: Ascend
%%BoundingBox: 0 0 595 842
%%DocumentFonts: LMRoman12-Bold LMRoman12-Regular LMMathItalic12-Regular
%%+ LMMathItalic8-Regular LMRoman10-Regular LMRoman8-Regular
%%+ LMMathSymbols8-Regular LMRoman6-Regular LMMathSymbols6-Regular wasy8
%%+ wasy10 LMMathSymbols10-Regular MSBM10
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine:
%+ "C:\Program Files\MiKTeX 2.9\miktex\bin\x64\dvips.exe" -P pdf
%+ "C:/Users/Chris Notebook/Dropbox/Aufgabensammlung (offiziell)/Typ 1 Aufgaben/_Matura/AN - Analysis/AN 3.2/AN 3.2 Gesamtdokument.dvi"
%DVIPSParameters: dpi=8000
%DVIPSSource:  TeX output 2017.11.10:0841
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: alt-rule.pro 0 0
%!
% Patch by TVZ
% Makes dvips files draw rules with stroke rather than fill.
% Makes narrow rules more predictable at low resolutions
% after distilling to PDF.
% May have unknown consequences for very thick rules.
% Tested only with dvips 5.85(k).
TeXDict begin
/QV {
  gsave newpath /ruleY X /ruleX X
  Rx Ry gt
  { ruleX ruleY Ry 2 div sub moveto Rx 0 rlineto Ry }
  { ruleX Rx 2 div add ruleY moveto 0 Ry neg rlineto Rx }
  ifelse
  setlinewidth 0 setlinecap stroke grestore
} bind def
end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 446 2017-04-19 11:40:55Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 446 2017-04-19 11:40:55Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 446 2017-04-19 11:40:55Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not alowed!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-eucl.pro 0 0
%!
% PostScript prologue for pst-eucl.tex.
% Version 1.01 2012/09/21
% For distribution, see pstricks.tex.
%
/tx@EcldDict 40 dict def tx@EcldDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% e
/E 2.718281828459045 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> true (if |x| < 1E-6)
/ZeroEq { abs 1E-6 lt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> a b c (ax-by+c=0 with a^2+b^2=1)
/EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub
  2 index dup mul 2 index dup mul add sqrt
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch pop
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% orthogonal projection of M1 onto (OM2)
%% x1 y1 x2 y2 -> x3 y3
/Project {
  2 copy dup mul exch dup mul add 5 1 roll 2 copy 5 -1 roll mul exch
  5 -1 roll mul add 4 -1 roll div dup 4 -1 roll mul exch 3 -1 roll mul
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c (ax2+bx+c=0) -> x1 y1
/SolvTrin {
  /c exch def /b exch def /a exch def
  b dup mul a c mul 4 mul sub dup 0 lt
  { pop 0 0 } %% no solutions
  {sqrt dup b neg add a 2 mul div exch b add neg 2 a mul div }
  ifelse } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> Dist
/ABDist { 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> x2-x1  y2-y1
/ABVect { 3 -1 roll exch sub 3 1 roll sub exch } bind def
%/ABVect { 3 -1 roll sub 3 1 roll exch sub exch } bind def  %% wrong version
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 x3 y3 x4 y4 -> x y
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
%   { pop pop pop 0 0 } %% parallel lines  % --- hv 20110714
   { pop 0 0 } %% parallel lines             --- hv 20110714
   {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
   } ifelse  } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c R -> x1 y1 x2 y2
/InterLineCircle {
  /CR exch def /Dc exch def neg /Db exch def /Da exch def
  ABVect /Vy exch def /Vx exch def
  %% Dc==0 then O belong to the line
  %% First project O on the line -> M (-ca;-cb)
  %% l'abscisse de M sur (OM) divisee par R donne le cosinus
  %Dc neg dup Db mul exch Da mul 2 copy 0 0
  %ABDist dup CR gt { pop pop pop 0 0 0 0 }
  %{ ZeroEq { pop pop Db Da } if Atan /alpha exch def
  Dc abs CR gt { 0 0 0 0 } 
  { Db neg Da neg Atan /alpha exch def
  Dc CR div dup dup mul 1 exch sub sqrt exch Atan /beta exch def
  alpha beta add dup cos CR mul exch sin CR mul
  alpha beta sub dup cos CR mul exch sin CR mul
  4 copy ABVect Vy mul 0 le exch Vx mul 0 le and
  { 4 2 roll } if } ifelse
 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% R R' OO' -> x1 y1 x2 y2
/InterCircles {
  /OOP exch def /CRP exch def /CR exch def
  OOP dup mul CRP dup mul sub CR dup mul add OOP div 2 div
  dup dup mul CR dup mul exch sub dup
  0 lt { pop pop 0 0 0 0 } { sqrt 2 copy neg } ifelse
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x y theta -> x' y' (rotation of theta)
/Rotate {
  dup sin /sintheta exch def cos /costheta exch def /y exch def /x exch def
  x costheta mul y sintheta mul sub
  y costheta mul x sintheta mul add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% N -> x y
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> ch(x)
/ch { dup Ex exch neg Ex add 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> sh(x)
/sh { dup Ex exch neg Ex sub 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> e^(x)
/Ex { E exch exp } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x f g -> x y n
/NewtonSolving {
  /g exch def /f exch def 0
  { %%% STACK: x0 n
    1 add exch %% one more loop
    dup ZeroEq
    { dup 0.0005 add fgeval
      1 index 0.0005 sub fgeval sub .001 div }
    { dup 1.0005 mul fgeval
      1 index 0.9995 mul fgeval sub .001 2 index mul div } ifelse  %%% STACK: n x0 fg'(x0)
    %%% compute x1=x0-fg(x0)/fg'(x0)
    1 index fgeval exch div dup 4 1 roll sub exch %% stack: dx x0 n
    3 -1 roll ZeroEq              %% exit if root found
    1 index 100 eq or { exit } if %% or looping for more than 100 times
  } loop
  dup 100 lt { exch dup /x exch def f } { pop 0 0 } ifelse
  3 -1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fgeval { /x exch def f g sub } bind def
end
% END ps-euclide.pro

%%EndProcSet
%%BeginProcSet: lm-ec.enc 0 0
% This file belongs to the Latin Modern package. The work is released
% under the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmec[
/grave
/acute
/circumflex
/tilde
/dieresis
/hungarumlaut
/ring
/caron
/breve
/macron
/dotaccent
/cedilla
/ogonek
/quotesinglbase
/guilsinglleft
/guilsinglright
/quotedblleft
/quotedblright
/quotedblbase
/guillemotleft
/guillemotright
/endash
/emdash
/cwm
/perthousandzero
/dotlessi
/dotlessj
/ff
/fi
/fl
/ffi
/ffl
/uni2423
/exclam
/quotedbl
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/less
/equal
/greater
/question
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/backslash
/bracketright
/asciicircum
/underscore
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/braceleft
/bar
/braceright
/asciitilde
/hyphen.alt
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcedilla
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcedilla
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/exclamdown
/questiondown
/sterling
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/AE
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/OE
/Oslash
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/Germandbls
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/ae
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/oe
/oslash
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/germandbls
] def

%%EndProcSet
%%BeginProcSet: lm-mathit.enc 0 0
% This file belongs to the Latin Modern package. The work is released under
% the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmmathit[
/Gamma
/Delta
/Theta
/Lambda
/Xi
/Pi
/Sigma
/Upsilon
/Phi
/Psi
/Omega
/alpha
/beta
/gamma
/delta
/epsilon1
/zeta
/eta
/theta
/iota
/kappa
/lambda
/mu
/nu
/xi
/pi
/rho
/sigma
/tau
/upsilon
/phi
/chi
/psi
/omega
/epsilon
/theta1
/pi1
/rho1
/sigma1
/phi1
/arrowlefttophalf
/arrowleftbothalf
/arrowrighttophalf
/arrowrightbothalf
/arrowhookleft
/arrowhookright
/triangleright
/triangleleft
/zero.taboldstyle
/one.taboldstyle
/two.taboldstyle
/three.taboldstyle
/four.taboldstyle
/five.taboldstyle
/six.taboldstyle
/seven.taboldstyle
/eight.taboldstyle
/nine.taboldstyle
/period
/comma
/less
/slash
/greater
/star
/partialdiff
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/flat
/natural
/sharp
/slurbelow
/slurabove
/lscript
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/dotlessi
/dotlessj
/weierstrass
/vector
/tie
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
] def

%%EndProcSet
%%BeginProcSet: lm-rm.enc 0 0
% This file belongs to the Latin Modern package. The work is released
% under the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmrm[
/Gamma
/Delta
/Theta
/Lambda
/Xi
/Pi
/Sigma
/Upsilon
/Phi
/Psi
/Omega
/ff
/fi
/fl
/ffi
/ffl
/dotlessi
/dotlessj
/grave
/acute
/caron
/breve
/macron
/ring
/cedilla
/germandbls
/ae
/oe
/oslash
/AE
/OE
/Oslash
/suppress
/exclam
/quotedblright
/numbersign
/dollar
/percent
/ampersand
/quoteright
/parenleft
/parenright
/asterisk
/plus
/comma
/hyphen
/period
/slash
/zero
/one
/two
/three
/four
/five
/six
/seven
/eight
/nine
/colon
/semicolon
/exclamdown
/equal
/questiondown
/question
/at
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/bracketleft
/quotedblleft
/bracketright
/circumflex
/dotaccent
/quoteleft
/a
/b
/c
/d
/e
/f
/g
/h
/i
/j
/k
/l
/m
/n
/o
/p
/q
/r
/s
/t
/u
/v
/w
/x
/y
/z
/endash
/emdash
/hungarumlaut
/tilde
/dieresis
/Abreve
/Aogonek
/Cacute
/Ccaron
/Dcaron
/Ecaron
/Eogonek
/Gbreve
/Lacute
/Lcaron
/Lslash
/Nacute
/Ncaron
/Eng
/Ohungarumlaut
/Racute
/Rcaron
/Sacute
/Scaron
/Scedilla
/Tcaron
/Tcedilla
/Uhungarumlaut
/Uring
/Ydieresis
/Zacute
/Zcaron
/Zdotaccent
/IJ
/Idotaccent
/dcroat
/section
/abreve
/aogonek
/cacute
/ccaron
/dcaron
/ecaron
/eogonek
/gbreve
/lacute
/lcaron
/lslash
/nacute
/ncaron
/eng
/ohungarumlaut
/racute
/rcaron
/sacute
/scaron
/scedilla
/tcaron
/tcedilla
/uhungarumlaut
/uring
/ydieresis
/zacute
/zcaron
/zdotaccent
/ij
/periodcentered
/quotedbl
/sterling
/Agrave
/Aacute
/Acircumflex
/Atilde
/Adieresis
/Aring
/guillemotleft
/Ccedilla
/Egrave
/Eacute
/Ecircumflex
/Edieresis
/Igrave
/Iacute
/Icircumflex
/Idieresis
/Eth
/Ntilde
/Ograve
/Oacute
/Ocircumflex
/Otilde
/Odieresis
/guillemotright
/perthousand
/Ugrave
/Uacute
/Ucircumflex
/Udieresis
/Yacute
/Thorn
/Germandbls
/agrave
/aacute
/acircumflex
/atilde
/adieresis
/aring
/underscore
/ccedilla
/egrave
/eacute
/ecircumflex
/edieresis
/igrave
/iacute
/icircumflex
/idieresis
/eth
/ntilde
/ograve
/oacute
/ocircumflex
/otilde
/odieresis
/anglearc
/diameter
/ugrave
/uacute
/ucircumflex
/udieresis
/yacute
/thorn
/quotedblbase
] def

%%EndProcSet
%%BeginProcSet: lm-mathsy.enc 0 0
% This file belongs to the Latin Modern package. The work is released under
% the GUST Font License. See the MANIFEST-Latin-Modern.txt and
% README-Latin-Modern.txt files for the details. For the most recent version of
% this license see http://www.gust.org.pl/fonts/licenses/GUST-FONT-LICENSE.txt
% or http://tug.org/fonts/licenses/GUST-FONT-LICENSE.txt

/enclmmathsy[
/minus
/periodcentered
/multiply
/asteriskmath
/divide
/diamondmath
/plusminus
/minusplus
/circleplus
/circleminus
/circlemultiply
/circledivide
/circledot
/circlecopyrt
/openbullet
/bullet
/equivasymptotic
/equivalence
/reflexsubset
/reflexsuperset
/lessequal
/greaterequal
/precedesequal
/followsequal
/similar
/approxequal
/propersubset
/propersuperset
/lessmuch
/greatermuch
/precedes
/follows
/arrowleft
/arrowright
/arrowup
/arrowdown
/arrowboth
/arrownortheast
/arrowsoutheast
/similarequal
/arrowdblleft
/arrowdblright
/arrowdblup
/arrowdbldown
/arrowdblboth
/arrownorthwest
/arrowsouthwest
/proportional
/prime
/infinity
/element
/owner
/triangle
/triangleinv
/negationslash
/mapsto
/universal
/existential
/logicalnot
/emptyset
/Rfractur
/Ifractur
/latticetop
/perpendicular
/aleph
/A
/B
/C
/D
/E
/F
/G
/H
/I
/J
/K
/L
/M
/N
/O
/P
/Q
/R
/S
/T
/U
/V
/W
/X
/Y
/Z
/union
/intersection
/unionmulti
/logicaland
/logicalor
/turnstileleft
/turnstileright
/floorleft
/floorright
/ceilingleft
/ceilingright
/braceleft
/braceright
/angbracketleft
/angbracketright
/bar
/bardbl
/arrowbothv
/arrowdblbothv
/backslash
/wreathproduct
/radical
/coproduct
/nabla
/integral
/unionsq
/intersectionsq
/subsetsqequal
/supersetsqequal
/section
/dagger
/daggerdbl
/paragraph
/club
/diamond
/heart
/spade
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/lessorequalslant
/greaterorequalslant
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
/.notdef
] def

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfH{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def} bind
def

 /pgfV{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto } bind
def} bind def

 /pgfA{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1 add
def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div
2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index 14
index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke 4
-1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1
roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx exch
def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade {pgfR}
def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx pgfstartx
sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb exch def }bind
def

 /pgfR2{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfR{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1 add
def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def /pgfcircy
pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe pgfstartx
8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty 8 index
pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx sub pgfdiff
div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def 2 index 6
index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index 6 index
sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff { 3 index
3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1 roll 4 index
add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy
pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark exch
pop }bind def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore newpath}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore
newpath}bind def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def
/pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind
def}bind def /pgffoa 1 def /pgfsoa 1 def end

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: LMMathSymbols10-Regular
%!PS-AdobeFont-1.0: LMMathSymbols10-Regular 1.200
%%CreationDate: 16th September 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 694 194 0
%%EndComments
FontDirectory/LMMathSymbols10-Regular known{/LMMathSymbols10-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.003)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMathSymbols10-Regular)readonly def
/FamilyName(LMMathSymbols10)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle -14.0362 def
/UnderlinePosition -146 def
/UnderlineThickness 40 def
end readonly def
/FontName /LMMathSymbols10-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-29 -960 1116 775}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105BFA1C4BAA966BE78FD2F618C28B35E2A9ABAF
CFC1090C3FB0905252C41AAED38054D177019225F56A500BE560889E991201E0
4F9B605C0D22769EDC54E591E36E37E5FDE707BD42C0C024454DA2F639F72A9A
562B5C1D32C6F47FC06B117D908616531A8379DCE1701F7F184859612D9F84F9
0EE31AEF799812A99147A8CD30D5F8F8F033D677CF5973762278DEE78C7522D2
2503BDD4843BC7D22B723F8FFB9EAE1A365FD5A465501AFBF49D03BB5CAEB5C2
C00D92D7940CC5995D94BFA90687C972A362AABC211E7ECEE87EC66D7FAAC514
CD571128C64BA31B3D6D1EE29A580950C167D6F68D121D24E942C325DD83E3C9
176ADA5BB429335D8B64EE8DA6DD276C2E0F1AF529E27D9362EE6FBE6F34E3EF
730BE0C9856D232D02FF8BBE7B9C3903336801664B1F064896DCAAA4AA2E9F9B
6ADD0C342EE025775974A2A1698D16193E213A4C9AC3F2D5F4533E74EDD15794
F8F2456FD2DCD50796D5F9A7FD862FD9B5414B6C0E98718AEA2C06739FD91939
D22724207E144B6D7AE3031311717AB00AD53D3C9B7A5D0E6FE1D717422147DD
712D626F624F8BA5B347465B53327A9224FCBE2D659F188723A19E11C4E00D92
70B50D3D5444404A08421C1CD505780CD852A25840CEDBC9E1CCF5DDA749779E
7A1D39927CB9EA17271E1AFB2C1937891E8F4A2D1950D62D2B484F4005885762
96579F6935952724452D811B749AE61C6265711EF0024C6AB25EFE1E88FCF88A
A072958C75F616D971E4E8119833F4BEA9D81CC7B26F2DF718D3B6A703BD78F2
CB700660069EDE978BF7DD781EC63F092EB43D2DFCCF8479D6247D7A04ED87A8
95522498398D6921457D06D28F8CDDF821A2952FEFCCD910A8812C5A2E1CDA07
2D9A7DC6F3C396982DE5A1234195AF657F79C43D543DC31BE92BE270A2C52131
8376B9807473096F6791C855155887063B1B27DEE8771DE0FBF0A94DB173C46A
C53D51F08C783B2AE5020D74C7714FF08F5AE00F69DBED351708B1C760171CE5
5D0FE3BC5F6769FB19C7951CD5DCA774B841330A2C8CF59CF458230A1642F956
21D23843C4332F05F5AF14E70EF052F02F7E3F51D6E7D68A4FED8D2C4A733AA3
8973CF4CDF768C31E35C395C3BF67A79F8B1AC292F38AB2EF22A87A8ADBE2C55
747D7AF3101C5F1A2A1BF6C0E245AC583FE784CD69B918457FC63ACB5FA24E41
CAE39AA9386736476F5C0BD3D01ACFCABB35BD346B884B97EB5F467C93A2FC7F
82A0B3682C1D7B0CAE0165D6FE43CBD8FA5C85EDCD122FAC36F59FDA7CC4EFE6
1F9F8E88832737186037F9E5AB161B8A2090F5569529861FAEFDC91E823E0A0E
A92E7F1118BCF413BD355CD844D0F88C47B267EAFA1585B4ABAAAB9BF885D233
DE4656E4CCC1AC1A5762BE48F5FA88A0020AF17A438014B5902A55EE220152C9
0348CF590A07761415D2F53A866C95D4A6848E2BB7970D176670F90765843635
9C2461BEA57F9CC512BDC51EF25496B2C2253AE85AB38889B26761BA509C7F63
8C6CBC4BBDEA74FD3B43A178C86F9A97423815F5FA2C09BA590B8371D5B7758A
43F98F4DC4792308CDFE2779CA6F20ACEF23FD8FC11F483C0CDAFE837D984A76
1286C4DC5088F5DC4B8D59F781ED48736CDB2D0B9B51340F6218CDD622544552
9BAB6B88481D111091C2CAE5E19903BE5F2C90E79E2469EFE314329B4653D49A
0C4443075770A918BF41736B320F9653C19886C022E40DB4E36B72E592BD406F
596D415478975E25D1E9A8DBCCD50E0F27E925AE25105C74A97A28AB3241B091
503FE2B0DB2B950C453DF3EFFA7A223A8615C973D1AD43A9C5769C335FA10DD2
2A9C8D64ADFE5C705F27440CF292DE3F9A8D6890F4E2E9F07C1584D565DE2743
BEF51412CB09BAC78D9A9047736F25BC8EB7463BCD91C90087E61EC4A1CB5668
D0E7232AE1A101DBD23409514D1DCD2B5E23742F6F46B3676F2F5009B28FD8CF
82DACF603EA5961EED99C9AA3BA1F8E6B2C165A661D051338E97676D08D01D53
2039D251AAB75FDA4D5C2D9A594B8985C4AA1CE7DA71D7DE560B20388264ED77
132352AD4A02D36FC01DA5CF1EEDD532A0E3211BD9D9008646CC90C9E6EB17E0
1E12E516E4D3B72B49778095CD6D07783E9B5780319235708F3988B266504227
2F8B354DE15DF509B1940998ED426EACF54D77443327488492D6AA15C5A192B2
C17749DB6AC2084C6A75491E6FB631473A00203B1EFFAC9B11F49BB7F7E18CFE
82580E3E552399E387C42B68C9A4D394F73778F519ABA551DF0110BEF3968F20
064A2E38A4A472D85532A6FB51DA97B7F939C9A410F40BD0358000126811B9F5
70C248119395B41D5BB131FCDA070495A3976B1955395E37DFCE47D166E87A3A
9A7B4293E16208D96BF6DD82118BD7B014C2C18BF6D7D6A83363801A23DA4609
1C56E383D021AAE82BA17F0301C3DFC416303A78FBFFDA7CA62265D290277920
7F0434C9599D05A1818A48940D7EFF0E558543DDABFFC40C96BEC077BA050B32
77DAE88BF1A283762FD0B269D3DAB9B754DE837C8D9935EA9C47D35650BE669C
51C2981502DCBC244E383F32AD6B9329DEA05987665971A20BC2DE3216E39635
76EE7DFE9D0423E3BD1ED5FD84736E4B8FE25339E8BA005121F8C3A9685261C2
34B72F52D5B588666BDA79267F8176DE0B0209C699638FF43BBB
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: MSBM10
%!PS-AdobeFont-1.0: MSBM10 003.002
%%Title: MSBM10
%Version: 003.002
%%CreationDate: Mon Jul 13 16:17:00 2009
%%Creator: David M. Jones
%Copyright: Copyright (c) 1997, 2009 American Mathematical Society
%Copyright: (<http://www.ams.org>), with Reserved Font Name MSBM10.
% This Font Software is licensed under the SIL Open Font License, Version 1.1.
% This license is in the accompanying file OFL.txt, and is also
% available with a FAQ at: http://scripts.sil.org/OFL.
%%EndComments
FontDirectory/MSBM10 known{/MSBM10 findfont dup/UniqueID known{dup
/UniqueID get 5031982 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /MSBM10 def
/FontBBox {-55 -420 2343 920 }readonly def
/PaintType 0 def
/FontInfo 7 dict dup begin
/version (003.002) readonly def
/Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name MSBM10.) readonly def
/FullName (MSBM10) readonly def
/FamilyName (Euler) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 82 /R put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE32340DC6F28AF40857E4451976E7
5182433CF9F333A38BD841C0D4E68BF9E012EB32A8FFB76B5816306B5EDF7C99
8B3A16D9B4BC056662E32C7CD0123DFAEB734C7532E64BBFBF5A60336E646716
EFB852C877F440D329172C71F1E5D59CE9473C26B8AEF7AD68EF0727B6EC2E0C
02CE8D8B07183838330C0284BD419CBDAE42B141D3D4BE492473F240CEED931D
46E9F999C5CB3235E2C6DAAA2C0169E1991BEAEA0D704BF49CEA3E98E8C2361A
4B60D020D325E4C2450F3BCF59223103D20DB6943E919FB4E3240FEEED78EE63
0677FAF39AB2543D18C08A2B98B97451CD42CB7893DA8601CC0F45A65BEAFC64
EF72554395DA801CF2E9E3B03F65F1BD98F8C5F8EA06D7457842303C1A817E7D
69821807328AF426B9DDBC188A79A66FBB9E6193B4A3EDFE3136C6574B9C4C94
E2CBA4FE7997F949BB2DAC0D329C2AD8E4095BD18A037AC9F77B794FC389E5CD
56CC4C0B74D64FB0D02C92B88942C18B6DA84D4CF482DAF3A01E80BE483AC6ED
AE98F5F3E49BC762EF6BA937D528E751D9588B0A1E82EF0A5998150EC3854472
5A91EB983915BC1D6E2C3E615E0267B39D6937ECE0EC16162FE76676E5B69F3C
BC1AD934BECA284B89F0613B70876247D768BCD246883CFF4D819D6265302730
7E4BE6B2FFE7E91CCB8C6D2AFACDB4C5DB9688153E1D6B2DE136BF7068418A4F
2D1C0CA301B1B97290B46EE14B8286A81E709980F67382A5132F01B2D44DCFF0
9753E776AEAE2141D580E64C82598DAA6DA4057FFA9D02C3B77AE15A50AB457F
3FA5A10A3C986B22F8E154C1E564A55D3BE4487677613DCF793F7E1B57C9A925
BC57746C25FE567719A9EAA9CC44F1D0FF8F92C03132B205F57E3AFE9FB66632
D3FB3EF5BDFB9848030527FE759A5273CB81DBA2719611355F43E34F8FD7D0EC
9BE47685A2D122C9B60198A430C5F5E3F972376F0FF4BA52BAFF64095F7ABCBA
022622692231FF87514FD912B80C07A0EDCEECFA629E2734B5EFE2604E8DCB24
32A4C691DB4CCCF19EF897A9F4EA5B2B5AFCDF87AC06B93669F3007C1295E016
FF0A99324B80E37020B1080E80949525B3278DF111ABEA48E7182B6F4DE2DC90
B8D31A953343D5DB78B1F2CC6CE631EC7E3D0041A823DF2A4702AAC0F0A2F018
E5ADCD42EF2EC8AFF6F4705D30042BE7B6F866C14AEA1CEE04DFF82BF14931B8
D297C38E6DA6E587C23EF0864F69BB0DBC9C1EFBBB97B92BADC336A4AFAC6A91
0A6B158DC42E975CB5D8D2054CEF367FB112456AF50684C41F80B1E7ACAEA853
B843CABA76BDE9582090299F423519EE3AF8F83AE7F7828B314B6E36E9127419
F274E9FBF5622C5E48D7E95664D6C0C1006661038CF2C93BEF1DE34A163A2C86
693A13F4D0F052D2E183F36401F0C29862BC1B36A086524F76C7EE2C6D436A23
7009F146F1756DCADD3F70C51FDCE610E30C0F4AC538A2703423A07976ACA74C
25F4CFD6A92969E206375FB0C672E45948B0E832F2BE688EC22FEEB3E06BBC3A
272F73081A30830AE4214F2F029918FCA40BAEBED6299EDBECA01E08F27E5627
F53BC56F4AE7CE2D6273B27323AB829E2D51672A4990E3AEE84331583A99DA4E
63610AF8F10C50FE6196E3F4C1E4FC9BA6BE0ABDC81A0A7BF6A5792A97BD0A7E
7BBD31C3FDC01D734550843C8D84C6CC0B492CD1A6CCD57428F03A863E959C77
457D401028FD00FFA9BC422FD09D8B8A70446A61CB256A2FA0B59A2646D9C5FE
961894DB8B315C52008B4416AC35439E010BF90E43A05FCB2FBE8E62385E220E
588B7FE5509F1BB71150E159D01D24EE28008D4213227FE9BCAA34364B1039F6
BC142AAB19C8E9B15F0113781DF9C9B3BC145955552A901AEBA588D39D7E87F1
CAF27D315E168807021B0CD1B2CE13B611A7B5FC28DEB4
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: wasy10
%!PS-AdobeFont-1.0: wasy10 001.000
%%CreationDate: Sun Mar 22 11:13:35 1998
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.002) readonly def
/Copyright (Metafont original (c) 1992 Ronald Waldi, Metafont curve conversion by Metafog (c) 1995 Richard Kinch.) readonly def
/Notice (Copyright 1998 Taco Hoekwater) readonly def
/FullName (wasy10) readonly def
/FamilyName (wasy10) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Normal) readonly def
end readonly def
/FontName /wasy10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 50 /Box put
dup 52 /XBox put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox {-23 -1667 1720 881} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB02CB1AAE
36F1D7B67C605A37687A9C3F7067F07673039D1E3E1F5D9B09E6A389A55EBF12
06E72531469F768EDBC4DCCA572BD608C4BA8F7EC3E5BC61C6D949C94A843E69
0622F0AAEBF5CB25A2395DFF6342106C198751CF0B33691FC18800254AC54C04
02494A0E3670008E8BA57A3CD823BF47494F2EF9244421A8A0AED84D153D7201
BB12EE9478DF00CA573F64C2474817FF401EE94BACCA8AFC16E776665C3E1E31
89AEEC906A2B9F8974BEA7160C33F0AE7FB04B2666A5B16659D6DF66A688D80A
B531D9F866F21F15D55C6FE75A8787091359698E434EF9C129EED0427EB96787
B3F25C530E3664725C63D4C5DFF9D05CD13619FC41A001275A78C58F85FC7C4A
911CC31CB426231473202A698E5715B032D2206BB361EFCBFE3E32BC0C8D9BC1
353AAEC62EE632FC8FFFDCF6E7D928F562F689406CA00C11C7EAA723B62FFD2F
5F6343AF494085662CE2CE880B04F5589396EAAA8823DBCDE56D868B9E66BB8F
10EA91AF37D76A1BF27E69C2A2ED1D8B25434C0F205313ECB8A6E039093FFB32
983346BEC569B175529DAAD1FFEC1A9302918FC947C390A86C061AE0F6522D79
2D4FE06AE4FABA59F225D7ECE2EECD4BA1359DB18F8957F551C5D6F037F18545
CC6D03EB2DCCCFA294492ED72A737588457E5B18FA4CA0F6D6D8963CA35DFEDF
31A684FC0388D416D7BF6CD9837AD8692F284F24B80CF9F24DB10DAD0C4198BC
2D2A52D9F75CF6C52C7AE0D8D4598DB750E9CC97D0FD31EE8C598A2FF3745694
29DA808141AF4D8F8AA36D7DDCC3457D5E082B2BDF7EE060296721D44B092E70
3607B2335488925E41B22D659C8F0FFEE19A7C19547A147DB851262E47E9C4FB
0A8364BCBC1C77E29A1183EF185EF35B9A5B13170730ED52D5C52CCB460E7D37
F4F37F772794BEA0DA201C99C52F8AC2E4CE7FF33F6ACB796E55BA2372E3B035
52C4F57AB5C0BF828DC7E5A8F8F00ACE0120B99667816FAF5D736BCEBF7D45A5
79C9B5EAA32C9B672D764D2F51B2393ADC71A36AC0D5CA76F3F571D50CB4C1D7
CA77149B8F0C98198919DC43890B0BBF10075D53739F7E84CEE95B40C3DB68D5
6E9847E37B7920412068C3DE2065A77281345980956AFAD312499818890B454F
5DD8C92695818BA4DAFEBCDD4D268763515CE077A64C5F3AB384A6DFD7DD9641
FCDA0A3344B3A14F82D478B4BE7BFC2822A4D67AD3FD07B11589B93842066528
1E51D954D7E6019F6921DB9B00ED303B4B8F557EAC7A0B0340A268B0DDB25B3E
BE0982129B0D3416CA5D07ADC689CAA181270B8141F9D0F60C60F156CB305E5B
E71D9A5D5FB3216BFB66284FCABF6D74564D1288EA99D3FCF6F29C3AA690A596
02C0AD2BB29A2D457C66031E5571A1454758212EB4D053F4C28FF629FA94DBF2
9677AC4B92C4DF5C7FFDE31A8F2D6F9477896C11CBA890DD464C9231B1C350E8
E8CEE17F2E0F5D10416F7D7FBC6085E9BE09E692951EA7B93A9F49CD458476E0
A380E1D122F275093ECFD398FCA6D714187CC12A2B16318F9E1D2B0E9EC134A2
C4D2674AA68D2E7EDBCCA383
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: LMRoman12-Regular
%!PS-AdobeFont-1.0: LMRoman12-Regular 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman12-Regular known{/LMRoman12-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman12-Regular)readonly def
/FamilyName(LMRoman12)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -175 def
/UnderlineThickness 44 def
end readonly def
/FontName /LMRoman12-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-422 -280 1394 1127}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E7AC5E68123F9DFAD1150FFE135989C22B412B
63BEC913DA6144549F051416C71903E13237781A5DD70E8333F80D9F0E493687
94A83B2F049E14761EFE435983C72A913217C8946E4DEB22A9DB2FD68B53B9B4
02761774E0E713EB4A4FC9C587A325C91693ADBC62DF65291D5EB7BD830949C3
35DF08289D902F15122C50260EEE2B47E043ADA0D524C74E7162994153270875
9684A21A92E2A110C8FA542765DC1244DA4ED2FF03AB0E7836F187017A2AB59B
436136202ED2D5F38A061955643F519B56D5081FB38526C4091FB82642EB2AC2
17913FA5191E1482492797A09A2C4859DC92077AB96A24C759D2A12D8CF53A67
D39FAC370CA395D7947698CFE282BDAA265B8C66D319093A4B6A6B23D39B579B
02FDEBB0FAC4746D42B81AC988E14F5E16D364AFD1FE5E5BE79B95F649D0E302
3D515A32D736B13ED5A59461701BEE9BD6454D8EDC9F523F0F9ED8C2283958FF
E83175BCD63A78D5B5AA7A59598325B315F6EF8ED5C2903F0797F25BEE9627EA
B7293E929462468CEB3850E3F0F02C6D8BCB048CA7C08EFBDA6F2A43E03773DA
6CEEB9CA135749256D200AF2DA1AC7CC1F88D1F7E2FB7A3B317BD067B1136AAD
853BB4BDB4FF59678994E9E420712F1C1388E969C0C7AD3251B7DD9309CC2412
01ED1742C7CC55BA82454D4A8211FEEE54F750E858EA905059B59AB8153FDE73
21AE301103FF22B1C3AFEA3486B201D6E142180481F28189F1A55DEDDB2B8C99
284BD47214751BBA6318949FD9BF7FB4659ADE42F716AD523F9E49F08C8B6F5B
A43FECCC19D69391CDF7B54D6BEB90258567A4D3EED257CF64B722FF4A793FAA
07250123A6A86DA694CBF1F040B611B619BB7D3CBE2D58CF1223CBF5A0D79A81
7C10FB27867E46D5BA1B3EB266E09AC5FADBD0F80D95237A5F36541162C707EB
0EFCD7DBA0E962FD6C10C2E1556836669524A473393873D502CA659D99F404CA
7B3C6D001A60B17ED2B2AD4850EDCB990134F321F1FD6696F64BA101037918C9
F3EB2C616987CEAA46F6C052EB3FF6F2FB9A6F974915B82B6608CD85F75F0664
5644A5E3888713099F73E90FBC9681A6432D6944A68175A656D126AB96DEEC97
7DFB9A5ECCECE68B7C706A15EA93F5FA7800171D760667E1336DDDED349310D0
BB68B865F3E43C4275DFD82036752613F3FC722D561C0B5BA22C873A42C13AFF
73B7A9B8096208922179B7EDF55236F13203049ED2D3A304BEF0120285E9FBC3
921898A37465752B57535DF5054235CB5A713FDF779C161E40A8A8AD8074AABD
6A06EA11E40F1F4F4090C99D86095BE64A36FA8733362A8D4A2273879968020D
41EAA7F6C1A9B682B344B7DC94AAEDADFD1BD39385A57F9383AA235717AF84AF
BF5D808D32071618FA11E2F7907B9626CA16609BFEE67DB56CFE2E2B90BED39B
54D866320877A767FE000D8A3386EB1AEB2D99809C71C946EB77ED556CD01675
A5D45FC8BD04EAF80C756386291444CFC1D7F12BB4B1304696B2080A14F56ED1
959BD60C7F7F5BFAF8497205D4BD589967F17FBA10C2EF19C1679C5AACA4F9EE
B15E13977CA81B5026C7E1EF4FDDFF62E82B16CBE3D401AAFA4D973976EF232F
76C9D0C0793684D68FE95129C326682238CE9807B35B2C2C0C32F4122724C159
AA1C41DD94D0808809572A0A32125FA4D78B525B256291CA389F839797A13591
6197A48D453611484DA293AAA6B62F5ECBC9D32FD482C74A5387629E03895C5B
946117AA34217BC77B1E075A4BB99145EA55CFD1D12CB1D2E72636AE538232C1
3966FC6E07843E4FC7A8FB27BFB4FF67CD278CA322575D7590D77B4E03E63F7A
848E639AEA6DDEF55107E8C5B9DFFAA47CB3CB5A614B77D0112527C9AD97FDAE
5BC457971A70DB3421293E16959B64702BA858C1217A8B3B836A947462E0B59B
37C8CBC667F0052E653D33F067997638BDCAED6DF3A8F1793F71E79A58BEF6EC
47F700C376341D757B09A3E31F6ABE9EB9021C1A6E311CBAB6DBBC8AECB140BD
DCACE9B1E80979B7487BA2CB786018E20A5E0355AA33D6FCEF382799F62A9A8F
F8262E8DE16E9245C61CF3FFE09AACEF315932D79117A513F6863D275B80A249
01CC70FA943FF9A9F5E8D5716835F17CE3FCD6FC5EF10AC25471C19ED3B2D164
93293F09EA311F49295310B0C1AF942753C52402014764CE7026803F091EBA60
AD877E9208260AE6AF24100E2B365BF89C5B679378A7F6A67087C57B5519A988
04735147BE66CDFF2481FE35DBEE9CAC7E77D79BA760EF4C53A3C983853DE8C5
FD3F25925955F36A3BFF3454FF7B226C0F001FCBC5484DCFA46DD8D89C69C886
AA0247C5EE233C9D7DCFAAEA1E34B8938673AA6D760A80C38EFAE41268C528B8
5A14387C3E29D017EC16BE7E6918E11E7AAE31ACB6E85DE4B2B15B93B7BACB79
AC25F37A4E4D1B370E59C78DC9EB4AE83D1CB6E4DF546FBC914A6FF52591CCD3
C464AA14A393F61610D617E196C9252A013C9532C303C68553C91CE83431F239
BE883C519B643E9EAE5142F698F4B47ACE43BFE59E3AA4C8B47CA18016F95C6A
212208CDE1635F4E5271224CC19B6D47261CEBA3DB1E042443B665E915991D93
2209B3F4C86C9763861923B2F335DE040A8C24E73A0DC3FFAD5A6A9249A29AE0
C70F71EA41B0A4A505263D6A6C70BA63EB2814D31DDE792AAD7AEB4FA346EC85
0781604DBDF2EB65869969F265341938B2C7D6B979342D93A9F5A23A3CE8A015
130A0FB817DE38359C63DB215965E218E892C350FCADB5F66EB82D0813EF551E
F65992B2E24B4FC8353951C0A335B53F68A8F8286A94521BEE28D7319ABCDFA4
A21B5DE536B34845B32A34ED5CA1F3D3EE2B04DC4CBE12FC99DA94FB2648B842
54D4FB6729B1CB7E86DB55FF4216E2F57A08E04B44BB36F27129E5E93EDC061D
348F162C03BEDCDF0521B9F31D29543DE2AD436B75778C0489533F3FD5742FC8
AAAA8A72683C54B45F81F355D9D19496D0F80470D6B289B760B6851EA1A9D31C
01577A0026C7929C87160EE0D8EBC305A07052BD82AF003A0EEBF1D6FF38B526
E2EA0A91866201E08792F03323228B622E30142E47BC752EB0EFF7BE8B688A36
22826EC83CC42DCE8356DB43399E6A6918A887A64B2EEE98060E47C0F4276DEC
FDCA976E967EED2CE2C439693E2FD2F2C26823FBE781CE97DF06830FC498BDB0
73AD2CA5EC36B4892379B00A5C8564FC9A915C85B66EEE33EA460AF6141D60E3
76B4E430431F049992647E2B744E48AFD33CF5041056A43F90D0E6A47C2521C1
058E8C66894928964B332A89C5DA71AFBF455E5A68FDD4DF74A8F1572F8168DD
E778337122FBBD1485F73B4EEC2651C3465557A320A0932B65C1FF77F68B89E2
BE7D6D975EEC017C4CC66C88F5BF25B0D84AF0E70ED77B0B380397149845CE59
EEEF6DDDC9E7C6127A68489B4B19F3D15F6C72AB8DD43CA69CE0AE0177D2B999
3DB6EDD24B6A4FBFAF7245D800115B62C9BD6E97A52671CF3F69A78D19654F75
3822663BE5461EE982F36B0027977D6B3738BA7EBE8FFE3928E471DD9502DF1F
41F853B486CBF6A62EC2D4975CE0BAE9D76A833969FB573201280B149CA91AD5
F57D3A240F66B12B30C0B8C3C25DE1E16BDBF5FFF3CD111CA5FCCCDC96631D0A
2B46A37E422D648CF65D7C1392E322DAD8CD3CB42B3FA767FC185F653F299CF0
85F2C3AD7BDE7C44FD3DA32993CCB41A92B29BEB26E60B05B105EBEB7A7476D8
31D2C0383F39344255823DB7D1D12E2435634CF69890D14A1FF76CD20F731C4D
09ED15BFCB1DC5530257DEDE728A19496AAF9D8BBCFB2DDF39DA7261CD6B1DE1
94DB09EA1744A0B6E3A9A1704083D27D5690B18843ECD420763B9E7F42912756
39C6DE6964F3607C90166D11C291D467B35592E73C61A2DC1F13CD09369054DC
5695355C6FE73DCD523582A4973275B64B3D8058783639676B4F8B47476E4098
ED693455F82F098F49FF487626BD1A4D4B3B7961171D67F8F6B26EBA8AB37B5C
35D075C41218D0E9CAFBC8078A26AB4F29F821A015135CD43127434DAB18D387
013C388D3840182F35ECB411DD16BAB8CB1DC80EE2D09164F7CB2EDC0827D2F9
73A1460966368EA8F0D42E7A93BBD492847AE57C85675CF04BFD1410B56E616F
68C3927EA7267C0C4BBA87AA3EC7166170B80B7355E802532D38053D427DA3EC
5D297AB110438F9AA9CEDA887E63AD877E9208260AE6AF24100E2B365BF89C5B
679912C69C51E8D0541100E3DF71D501F4BFA0AE8260EA4119883BE0E2CCD156
1113CDC4983460A31A70C6614DA60CBEA3A564539DA028D46BD8A6C8E870451A
F92C3A3D555E94EA81503E0D53C0AE8AF190625DF8F48C433C5CA5E61B61960C
10E340864F2D181B835CC0F9C87C9CC0E95FB3F1824BF5ABE0DA3110FBD87806
4770B0F94B263E2C7A3D9DF14D9BE01BEF9882A1EC2C8DDA5931F895D02E4FF1
CAD0158061CC26D5256590E51541844B9AE3A861D6412B59941B7186BC31AAD8
9CC7F07EF9A36CF5C32F54ABEE8B83306227DF64A1F4E9B350DB04B85024FF0E
6FF4C8FDEECC5DF7106C24975E54928A3679928D4D84C98B3D33843CFCBD8AED
A1A74438EFDB0BD68AB2061EF46D65CA446C190A6BF6E0D8DEFA1E8EDDFB5541
473187ABC3D34172433CC652E9B2516AD0EEC9F452135D6AC8D97A90DD4C972B
69C05585BD438731D0DA714733FABC30765D6775BB68C69704D0BA5D6DE6BC5E
10342040FAE3CA1C359295C7D2967195AFD2D94BADCE1E95F17F0F95B5A683ED
8DA83806CBF2B803C94B5A135004A20823158454E29255E8846AB1AB9E444B82
AC000DE047EE32B5C7659AA3999D8CA1D3941D1FF042DCB7834420A2CB78723F
B40B625D7418A892CFEBFF58AE1CD0F128156868B917147969EF8319C216ED3D
620588A8D3D13C4737BB89F1FE17EA91AD0A119E1754916E4957C40F7642AD75
0E847F04D456B101A89F4E76E6BD785EB1F605D78CC0AB1425CEB017B47C1D40
BE68CE2BB94BFFF5120F91CB493BAD5966F870FFA6AE560AD6A82C3B0AF0C810
C12CA6C41677519886FD5CD163D6FB351E2918F4E5B5D5A27FB8E57A24EDF9D7
42EEFF2C7558A4479E218E053ED37FBC0EB204AAD253FF338FEC59B78E10A2B2
43C8E3DF12E0EA444924FBC760A5E32C9378F656AF7684E8E036205B149DA99B
2CD2F337147B5D3EBAC772C2F70F13DDA614AC122D353AB33D8949B97B181136
956D729E9026B048BF61FA390F64979D77A4C7CC07B1DCC9F4E8F100FB3AE710
F79091EAF4D42CF6A8DA8B47CC8437A4D888FA4FA4772845A518108C5548A8E4
97B9FAD42B86273D30CE80C424CB288CBB7155E850C778FF5672B756BA24DB51
A2A131B516923D5CC746A42AAE07B0AA79104E10420C3F67E491EA298A680975
64AA3F4C9A988692F0931B645389DD9EEFA606C7C16504FB17687F59658779E1
F56C5D8A1589528DBE0C561289A797E2F91BA5DA79D7AB6BB91A0A6D6FB96ED1
A9AC8C22E57755612374EC339DDFEF0101A9CAD4EFEA168F36C052D5EA81A259
7AD76B6A7DCFF8E0817223503719D83AB4ACC8AF0D1B73A3D0F73DB2AFCF4C30
8C9E0CE08ABC6DB7433B1B871A62E60353F613EC6187DCBF7F1EE55E59DCF7E3
8BF93A153B0082245B574C006312B254E6D2F2BEBE39239ADB477FBD2B0D86B7
02500421694E3BA2B545716DCEC01F7A80C3ACC17CB6A528591EF09C1FD39DBD
4BE29E699D9E44B7A6E99ACE99DB14455BC5C675C2F574036E13FC1CA59DB02E
731D1809F3CAB947E239EC69E5FEB2374FF8AACD1F10A5BBCFC9B7E8B83C453D
749AED9371D1D672EB3B04BA011E431421ED35A9488016DC83CCCE1C05DACDD1
3FC7379BEC45910F0ACD46A06FA3DC6C3F579DAA7490C29C5399BDB16EEA2A7A
A8206C8C8D4A801ADB04F4C74BE0C7CA9C36E787862910C4D049B82DA0F3D2CA
E3F2C028C5EF249DA376F0F22997656F359ED965A99750A337D1FCB6E77FE5E7
54546F80A9483CF06E9F77E57EFDAB737460B7E1B3376B5E37B763D4AFF33E38
A050003DBD2E7A4229655E487EEAB7641CBC7C16CA6991ECD1873495FAA5C7CD
44201F5886E3828510AB2F720FC5142AF5CEAAD07B020D3CCBFC275E73703C61
7CA186D413D7FBDE7A1DE16C177B128893D0DD76450709CCF7086C6B621AF0CC
131A5A3D36C13E3BA09872F5C40F7C7768A67B861D5FC2887F1635AACF2780A2
D583189F38A0A6C8F8F7A09788999967CF3BC505F3983784CA36F6027A26FF42
1BFCE5DAB2D853767FE8A25935C81D41A0BDB45D751F6641FDAD6065A36614A6
83425FAA2937974DBEB542E195EAF9D49EDF6190BCA557C4569B8E95A285BE2D
0678B08BF54D8DA66DC41B5259FA740748064D77BF335721FFFB55A4D879BB5C
BE06D7684029FB80D1A2E5CD343CDDF6652C06EE776A4C64991F14E014251C3C
2EB411F1DFD619D6F72BECD582160DFB96DBC17E8CDAF6DD7B3F01AE728211B0
CCB196A462A56CBE28CE20A9E7D22013BE81AA88E9D000D37BC690F668AFD3D3
6EDE20B10EE93517665826A01E9F0C9B47E451DCCDAC76A75523184F814ABCE4
E4F66095247491382AA7361AF27A3C413336CA6D80889436779796A91BD8D4E9
A9413FDEE39EDAC35F56A3644C27673F40E02FA3ACA9267B104DE7D912C5BFCA
E5E84C5F5B24AE8BC731B706FA04FC210E9E3DD63F00738AFFF0F2903EFF7A9C
E99358A8B1E1C2D6AB92277FC241439926F02B1D593862F016B702D8EF62D1CA
A336732EE5F578302026F851E887A5CDD4145844ED7B2A9D46CB699AEA993B1A
8BE0267989F985FD759D74577C6FBE9535A5203A13070274762F9A8251112452
C18F8DFC654DF8532E4A4E5F645FDF856A628A9B0EA9AF81B6CF75F8109E9C4C
DAF0060DD5ECDE7D4739935BF6BC6F9751B2944306176F7AB5B4FE9320A14013
C540DC0B2C7702F09131A46903CBA6B92D5EE09FF45F2D070A7FF5391AA9BB20
01FF877040B80713626E0C22A301504A6C3B746E7F9A862C93438EF51D6913AC
652F49975BAAECAC0E7D82AC7CFDD841FA25930B62800559760771873D48F813
C093D52026755C661023F05440BE467933216C0A17193F829547FBDB710DF375
0F1A32DD6B38F76BBFAA9AB9E3FDBE3B65729F4293D8C2434A8886D583181CFE
693F96F674A02769B6E79DDBC17E8CDAF6DD7B3F01AE728211B0CCB196A462AB
000632416E2316A739A2703A399BACCB0A38FF9D62A657E4A992CBCA5E1285AA
1067D470813C4EE0034373056692B5571B13D28E585CA2C81E20639F0DA069B5
5C8573C66D2ABC29FEDEE39359C3DB27161631FEE22F1B1516513BDBC143130B
05BAF1588BCE485A83A64CBB45FFCC35DA36AB230E3D911E6F227F85F85BDBD7
C31A12F21A8962CC7329FC1003852B5883FD2CC9F33C5535522E2BE0AA2CBED0
1B7BAB39735095A31BBF3C1D0D021B9AFFDB32CBB4BA63424577ABA7335BD2FA
CD8E7E4D33D71E8F20CE05056D89AFBA4F271732429D0E7D2F25A4CDA2190A7C
4D9B2F649115050BF7C3888F92E015CA5D91B363F99E42ADE00F1CDC69E178C5
2B5FB46AB460EFE17923AC043A9C96E547DCF3AF3471F16FF759D63A7C091ADD
CD3074422A9FF130AC2D89B4FCA3A9D502BA7F4DBCC130846220359D803B7E3F
78F34ED841FD5E33EFCAD136FDF49662442EFD590CACB680151FB582ECE3726E
EBBFC47ADCDF44873FF17704C4D3683A4297D67CEEDCA50AB79793859EEDC1B1
45E2347A339705A0084305994178ADECD69B50FFC1A2FC48EBD258283E882BF6
7E9FDF6FF3A0842C93510237B819027F631EE891128C8B11A8B9D7DC54F36AFA
934E907162B395AC6CCD1219E393C3F3334854C5D7495678DE754AF0AED037CD
822C764829548D1C357D76F8E623370C82E423A16B06F80009F4D98FE9E8ACED
DB346F8E75941C1189A56410C44793F22D21EA39CC104695A06D169F15B92FB5
907A517090BE92D4EDC366D10C640E2BEEA25168B07A9DD5405964EBDB1F1997
466EB09B29B743721932EED1BE00D81A62A60BC32326C2D367C28E8E001B92CE
DA82FA8B3C08DDBB485101F54BED2C2A6F111DC0E29EEB3514AE8783E757EED0
CE311CC947049CAFED875462CA8BC85A0743F5667FDDF5D425596A7ABC182CB4
A946697F2D418AE9FFF3F592BB139C678226A7D5378E48DFFBC68DFB6F533E0D
4ADFF1A3C4A6E985EC241005DC3759CBBC75FCA78855CEBB99357DF7ED61C12A
42A4E9F9365D91325CEB2F494E31BB223A9ED387112D2AD99FEAB933BE0E31BD
7F2AA1DE45FC978490BB69153DA6D6161F79CEE9D604C6018E7285C9712F76BF
D82B5151EABE7353E904B46EBFD5E6625286B9FAAFADFF8458994798F6AA696A
58C9DE0CDA9071928549DA53556B4C8D253EDBE083B8706170B67822A5FF7C73
0360CF6EB23BC007F532D30B4BCCF70EAAF9F8C37D31577E8C0D68A4B89535FC
FDA06EFF5490E5C45D2E2FF381528AE3E23D323472F26632D439E5109C4256E1
4813707C96C369F883A6E0982D0C89D1561CB28638D1D24AA9F358AAFF93B956
4AB5F42EE32241CA1AE9D54F1E3710F18FFA2F912FD822B108C71C4F80598937
ECAAD0FE2A9EC2744C84C939845B240F94CE082C9B9A6C7AF788223EFB01D867
563247DF94F1F0C4A0A7CED679B25D1AC2161B2251B235512E1D028E10BCB5B9
3E04FAA62C2147ADCC67517C05D3140EACD524F1D4A26A62D71FAF1FDB22E36A
57E3F58DB7AC65BF389BF0BA95B2A29E90BB4820B6AEF318B1F51BA128368775
10EF46C228F3CF7DEB6CC4A3DDBC297FF21649EFA534E62454EF587BEBD9AD03
DDF1E973359BEC37A32D5F06CA5583D506993C1272971985326ABB5BF77A2765
6997BD49E03AE6ACD5A69779C02248831BB14DECFB18E5B96080A63DD3973F93
BEBF07575429CB0E6DEFC0208780C6643DBA983132A8BC1D166C17512383C899
9EA7DDD0BA909EC99E655A0385F2CBDEE99868A3C8C70627EBE3F8C28EC36BA0
E331071D9B11BF19F5E6E45321AA903C3D3F360ABEFB007D46720081C4980181
482895A93B5A3EC2D3098ED38FC4CBC6BE50F14FFF4451037DFD23BC99D34FCB
2E6586DE317EE3BC34234AEDFE8784D31CF60B331D853D2C54E5E181BEEEEA21
378AF14827CA6575DC37C7ED828C8869C3A49EFC824212282BB7BDFC553EB487
5686893751303F9481D43A024E98F20FD2A113DD261724AA6091FEA179E6AC2E
AC2B431F7C64A22CE1DDCA724D3E7C028BE43318479FC13E89B700D4CE1164AB
87A89D0A2CE6FF056175D0064ACE063D503A8A881CCF48D46B146C2D437544E1
F7209FC8F1F1C273EC90F7846DAFD3297DA381BB775C3FD75DA8BD6974D336DA
8E44CF55DCD10D1ED5E8A86BE9DC61D8196D0A99B5A879393A94234733056010
7CC2BED659961EBB437A6C1DE102B2A272D61C8A05A56ACDCAF59B1C2BB8D58E
F4F733A123C16C7092BB267750FFF122216DF93857B8259106B11BC67975A2DA
68BFAD5210039E61598ECE5CF9BEE30173D395E1D941320BA2A64B42C1373ACF
F3D05BDAB89EFFEF7EF9EF46CD604D79D4F83161C24A1CA48DA17E5E93A08414
E5CEAD55C5F2EC61150D2E80B538DFA37842D60CB4A26A706440E79F43310E4B
9C2EDEB216FF0E68B149014BB6E8E6BB46A4EF699D07E116C346F8876D538B2F
90D0808FBEEB77AFE9274CC14073847C44F9BF3075F4BAC0137BFE9F3A9FD497
70A6786CD5B04165F8DF1BE13CC06BE30D434EE42C60407656EE331C248410E8
4D5E5795A34E65694436761182BA6D5F35A8F6D515F3AADD855C9CABD5BCC174
D4FBD61DE7DDB8C3C7DB1E364FFBA48BB844B5623950E6053B0068BC64EE37B7
0945B9CD7B18C88E1931B1D04524CDC4DFD91254F5F610D7A7A77C415D051224
39FC3BDD16A69CE12763AAD528D5BF0F0F1E39055E86180C7D70697B73BFADEE
2DFA7C71FA95D3514F04CA9AB516FEA662832F3B270718BC389E266EB035CC39
C828E042FC059A2C0FC15DA8D78E4806BB3A779935CB46463F4570CC1FCD2159
FEFB58ECDD0EE9C6DF72B8D560BEF7C82E6A80D6AD00F60921A11583E42F53ED
26BE4B0A546C3AC0C46F3D057FB5F2F74C50B86A307BEA398227363F529553BA
75ACF5B38412C4D8F52122B8BBB73BDC31C477A7F1FC73B49906DC2A30EBB36C
B925822B8D27EBEFDD075CC89C3E2095105B4449B7B4737AD52783C5737C44F9
E81FD417458090C455AB0339569338D455D8D355DBB8548F0D58ED841C7388E6
DFC27DC13B8E42E450DA982FF3AC62D4E943C600FB5E882A0052DE76A475D722
76E2C6A8C482236248C0DAA528C6A92646975A56E261E3C16937CEA1C949AF55
E8687425568F85BA3C5C140343582C9770D946F44AD789E6A2CFEAFA21AE6C39
FDE40B9D08EF1ED2E41BDDA797F649B2BC583D15080EDA86B614EFF5AC56F4B0
51A75975F19B8F6AC9B8097F47863AC853E1ECE72587556177EC9913D2BBB690
5704CF35D7BF8C3CB2AFBE3092441B5FC98C4431CEF86BD83C5C530FF9E9E77B
6982E16DC92EE50DA6ED4BD6582E0925DDC2C0F2F0DA63D0CFAC789772A5DCB2
40685CF1CDC7CA44B22063A2252638E44CE1AA387BC10720D3C90009A4366F34
D114C1602245A9EBF6F48ED9B0AA19301D76B7450C94C7266096682A66E04BBD
AC1D41C639AF02693C47AB90521383137F464150D390E63D23EBF909C3772B45
8F9FEC4D3ED8950B75AF0B6BEDFCF429BEAF8B3559A6C73FF86EED7D5B536D98
46B22B75BE321739617F870A37F456286FBD511C388D8E5A1679DE7B5B440C24
318B25FB27DFE0801BA72A097446FE8DD4BCAAEC6F7FC3C1A2F06FAD3649A643
6F1725A65DE0BF2FB1DCD831442F409F848C2646EC58EC8181601B97C41B9794
FF90F55A913D1BEFA7D862AAEB39FF8A7007968419BD1522EB9FF705509F524D
725FC1BC7652B9E7654772ADB8B7C6B8E38FEA7FB545433930B270C63EEEBC7B
22995D17E51B64E0D3B325C1A5722F6B7A119DAF4D29C7534B2E0477C529196A
79F159CF0BAD279DE905753D58A74E6059199C4E3EFC3101D7CDEE072F502CB3
BA262D22D1BE79A172564F2C36D240C5D964DFDA724EAA95CD2FB9C636F78829
8B4234AD04CA1F46E75CD23969EF9E387BB3BE62A351C14DAC4BEA7FB7530CAC
A51328C628017AC93638DEA121647C09131AF15EA82B826ED390CE1B27492514
C9727830A7C933913B36D15D6A6E5BCC2FA76C09DC2155E1863A8C5542B9437E
97A0EBB4121AF684D41E35DE24714345E89DB88F71852BA15E6CA36BD346E4A4
3E85BEA75A6DA022A09050F2086F0B643A4E89E630F99516B2597A03DB22D516
DDFABE69046EB0B0C8C4818AF7E1AC71DAAC22EF7B01A3527310A2404904836E
5C8BDAEF59F579B4DA5EF281ACE8DFD6D48A545300D111C681DF8126C4B104AC
F0B9CEA3DF2351DCA1E6900929E498D27F5EBCE0ECAEFB923B5497EF22BF3645
D4AAE35E132D1CA61DA27DAC4FEF6BC7F7D7F83EED9F947931149B6CFA3CC389
F31DB5F20B5D4A4856E5013EBDE652B37E911AE0E16EAAF0AB9C6BD12A8C843D
A6CF1498EF18BE533ECE9AF59FA8252F5D38820C6950A8B323B1B8648E3AFEB8
276DB217A81C502AB62EDFB6C4B0552007ED672902C0442A7A58BB400940D125
07B823BA98875C002332D592429673C71760E7B2BD1AB594E30D797581F5A0E8
1AB0F7ADA0E0C377BD150F134E5BB4F8D8247CF10521AE6964C77FC11C4992B1
4CA7B8F884CF0B65E50AB3E501CB5D74D3637559B9F38F17E3877053BCC3F004
DB440C37234FFBAF6FD1226D19189FF54777E37337534BE8EA33D9910495E6B8
2EFD33741743178CF16F2D4E2880EB4A142CC2A44A66339B839947E1E27B0381
4F81700A47C3C775B15765E61C972A38E423874D699CA4A0EF3803FDBD216FF3
4FDF4C1C0D8AB9DB1C4EDF7F1982539FBBD85CE21AAFB10C1E4E91CA5F7A54D5
F433E3C4634AEA5036691124A7306C41216FC6BC6F51EAB6C222623AF1935758
D71E94678DFB09463FE15EF2DAF9BB3C19BE207736ACF9CC36C4BBAEDBD7CD23
6E6D2E8F4A0A24C4BC96A1811807DBFE59B74C19F6098ABCDB06E2D56FD40D8C
EFA6095FED1E30409EA873F16CF157EABB93758D7B49B7697AA950C7E8898926
E201C9E847D513189D68F0EAE6D3A47112738FD10561A78DC0187569098950EF
C78B5057CCC02FD33A050C1CE35780907C8F73D5EC0B69DC22B3DDC1A2123607
0981D64AC418C51DFEA19A42AFE6A235C112E5ACC76D12FCB66B4CE904060859
78F8EAEEA93CA5167BAE6FB1A37122677ADF4D17A7689F02B48F1A91DD52BCA7
71EC09A99E8463848179C564E3A85CC92A1DA31E0162F3C5EA759F2F3954365F
87884D04B679187879EE3F15F166F1E2367E46F2CE58749D9FC1FA6F5AB1D724
A9FA3C784203B38F17312D51419BC99C0B233ADAE39DC533F1D10843067264D9
00DF4295847EF4A6D9FE1590FB1C99ABA94CABFF1F9E606EB9A0770C242394CD
61F371B3FAE0E757B49F46381583857A01BAA2C5C2C79D8578DF1E5081EFB6EB
BD8FFFE2AE969B7ABA98EB37CB2C2A8EA5326178611E141DA242C236DBEBC181
95D4BA3F2D9C1BA99FCFC7C1AA04015BB8B29B70C0831ADB61A92C2DB592CF08
B3DE2FFE59236F6BDFBB08490E8968CD02762CE02CB727B8B6F2F5BD944146B3
B7D9CA452453C825B92E606247E509FBD8174BC4409B9A97CCAB9DA5C7614888
8F30AE04C7E9ABB8899F9B84DC89457496897468652B863C1EC73461CDA81E09
D56A9947DC9406DE7410672590BD7BAD0515F620E4E7B7DB21E963318BECF5C7
F574AF99DF6CF36648D3965FD79D8348CE3C1F8B633847DE60058E64505F428D
3461B49331578ECF6BF06DC225B10C6267D04FE60C98903806F30AF37522828F
D5DE3EC220C719B63A9259811860E696616D2265A7C5C62940F92A7A466DE356
76C6EEF97E28A71990C9D9D966F9510557EAA9071AFD7B3644EBC7FB4F3C9FFC
8023DE1604FD41C754EA86877B7F11EC057BAEA084D203E197CD50146460DE39
6ACB33FA00C65F6F7FEE25EC23E5DF02A3787BDB92455626DC09916C002B02D9
B025971A01FAB3FFB24E6AE36B4913AAD0B6C8033AACBCBF0029B8C7842404AE
C20DE7774A2D1CD691B783529D3C858D5F431F6D34EDB76D653F853B7984B781
D64B6075D35EC1E3507FD4FE2E7097A241D6763F03516A6EEA22D2EA136FE2B8
C7CAE8040C80D33C01FF403643F1D606FEE10691D19ED84FE52EA965D5AFAC85
083402BF6CB44B2643EF64644C5FDBA2CAADDD1D5C6F38CE44881BC3306E363E
443C146F13D4D1A9EB9C57981BA528840E4C5F98BC050A5C19D33959111715BB
198EFDB35B3317308967A00EADA8A54DD0385F310E3ADE8F7420FB22C933BF33
A8DF702D160C3450D2ECB0DBF6A3EB5A3F665C5A98F578A03948821E40D1608D
C44BB72D59E2898450699BE5ACA02DB1536D99057E3776D38C89BEDF58DAB633
4F4800695B15D7A73C7B544862FEF5F66F1571346ABD5D7CBD7A792B3DB47808
9459156DCFCEC5781A692410F18B35935AA9D15EB6A459A08E58230464AF0194
4BA2D55B6E014C8A068F6391E1176065F3F33BEE98F4148B65F4AD87FA59FA18
62E4277D99C7F0648DF86B62D63BC05E6D3BB770AF9B5A747EB52C023965683D
CBA5BAA51ED9F1F601F0F088C4C2859209CB0BE5124AFF65FA70E2F9AB3F0406
D1C9E5F430B4B3CDDB39E03874442F3FE5093AB36A62182A6A899954D613AA9A
EB426146DBAF38651053E5EAE46AF5F5F193E42A8D09E1CA8A979105D528F469
23FF8EB1F262505D4B3EAE86FDB44E9C724CE688CC8C9B7E56A46B87152ECD3C
EA2C9A685A4C4D38AF1752A6547B2F7F77A71910A9AFE6EB760E528A8A7CB1E7
8E8CBD5F9412659725A3FAE0610D8A1D644FBF257E8C925FF8F244F361E78965
DE27BB84231E6BF13AB85DCC12A3A8B9AD5994E179D5BA4001AF33637D19547C
8D92E24C1190A50E8DCED4C7BEBB2C4D2B57D2E4BC003F05EA7B0CD2FC041141
C380F3044C5D7ACCF2A3C8F620404CAF4264845ED9EC42BA30471BA24A031372
0ACE3287858A257253A70692227238BEA653498A071D4F1397B4ABFD8DF02DF7
1286A13ED22C84636C75999FB2AC41250B5788FE9AD839A9F7950211563E78A7
63B6F500FD4C32473D9875FCC11919652224067BE81F9E65B25658B77D081C31
64D9C729398BBE2D1A6CD470061A1D580BF1033B82D15589D5B59FAA773FE2C5
7780F981545E85525FE962D2E1CB05A36BD49CDAD430391216C1F404E0895BD7
9589861F3B824FAFFDB52588B208505438142BBF1F1BF869ABFDF1228A65DC1E
5E1AB0CD9B4F53D76767CEBB5907ED1D486993180BDFE97F2E173BDD0A4632BB
D84EDC3F4E9EDD96EBFC742B7939C43BF179895E1A404580399E65C1EC0F6752
1E177A07E082CB873440C4648D3FFF06A1499A5C7EDE736E7A0B5F072E7235E9
B1BA19B953CE9DE783BE36D41D045620330912C3096974CD5B1B05957074DA4C
E59522EE1FF192AF561E7AFB4C6710520C895701EC10BF0293EF870932F6D281
F0F9C45F9969A88E05652EA129760537D6D668F34764F90B5E8A643C8CA2B2F1
2BBDECD78464D441F2FDFDD1B4174B45501FFB0478D14C301A3AD4363337AE55
F39C5E29D5D432170FBCB19B4C29CE1BED117640E0DAE8EAE60218354FBFB489
4943AA2C3AE6703D32D0327FDD1B8EBE6504EA7C1337060BF40406475C392934
09C469920A5E60BE73C36611705DF0DE767FEF57452944B5BF3F9610B68E57D3
3378ACB8ED7DE1B1844854CF1D179AC05D5E50D244BC4735C9ED3F75A15DCEA1
30D6704BCBE14EA5296654634482491DC499382A32060E4E7358A7998FA34AAD
8C8B26C32438741F39EC878D2575EF7628F546E9B7FE3DAEA7EF735E4FAB0483
0EF077A8D788B224C1843391438936023DEDB0CC9AE428714DDD6619AF0785E9
0C2CEDE5237B3467B1A26791BB653B865750745817CA28E49E561BBFD9589D9F
B42768AF8CAFD1490D4A0B81934D013CA3DB9FAE17B29A59D2C328CC6D94A70E
8C4DDA6807965CE6DC91D4F8B7800A05DECB300CD7A8C38D77498AE852D31BE7
72DCF52FB024C8364F1BCF967FEE2B832EB2FBAA9E9875835511AC631D01545C
BA6F90B8E9A741509DC67E8DFE3EEFA96E8ABB5CFD28CA18CD9013BBD3104864
AF6B9D3EA5F9A365966424B74C146E164A750993E079048596734F0904DF5280
531C93F0F9BDFE63655BA1B2912109796C1C7ED9476FD94CA6A05BB8C3A2684D
294A79DEDC63A2B3887CF7CA14D36D98547FECA871C1B55C1CFB942952C5F2D2
27B7A94085C657D1C6E550D8EB15C426BBCB0A20D4A0DC078BE75C6503695295
7EF37EF87FC74899D1667D16306506EE806011CFFE99E91E1C0DDB2999F26EED
9D32C373613F2E788C56EB08C4589E89D8AC1890E5580074E9FA4B87601FEC1A
6E5E381750FDD11F791B3CE3455A4985ED699F01D3CD3248B2AC10E08997786B
A72E91BA1D2759753E96A327B6C2C7B089C8AE581CE6668FB9ACCDFA2245364C
CA16643F25ACDC30E799BEDE4F80E5CF50E44B9D8319141D0F635F591C939FC7
6BCA004EF729886B8B4D23228A79F78CAFE6BE769312C50E570718E585A8BF0D
CBB9CEC865D929A706E06A2E0D9DFBDC28DE2F4431F3A1923FA3C5F292468C74
0515971B4CE4375A1A9F1EC3D6148A1C850D5184E485C71B916AD96DD66792A7
32A188E6A57C459389DD487754695A4C00758EE3D1E1C28495B0064C2A196BD6
208F7304AFDDF88F35E1F428DBE74E704276634BD0A70C5F04DDB4B27952C374
5B76EE5B168F047E5937CEC4B589686F3F263BC002C8884F38F3BB6E09768DA5
02CF15FB214B82459C026B3A1226E7BF21558D70B551EFDBBBCA49EB4131D979
6D5E9A6CCA98D3BAAA326A7E2CACB1EA73BE468AC0E2E6DD2F1D523210E60FC3
5BF96BF767F54E201558AC9CFD389FE0EB0CE21010E3AAC8487C9AED61EAAB9E
EBCD9C390C4D5C98FD2B4B362D9DDB163B01F60CFB6D04978EF48D32A207706B
36EB97D9202C5763599B3C05E1464BA1431DA55C428AEE554903D3BCA3A99448
0430B3817F4C80D9AA8F7DEFFFFA76B640FC05A08046169186702A682F00A125
22EC18F41F738AC7FD3ABD6EC50BFA7ED45DC42A0CE1D2A29F0A1583852AA0CA
E4C5F3035A6AEE439740E1E8E63459B85C5A9EE068854000081A0C911F1EE848
F75456B353EA0D2FCB03FD86FD6A1A1A68C4191BB96DD6768DB2F8314DFFB546
17007C1984D443CB98799D8999BFC582EF3A79C9F067B1C1D5C9E915592F7FAB
F0CD85560921CBE040A2AEFCBE4AC82DAFEEF86EB672ACE7D8BB7BD6FF3499F1
08BA1894F24E9568F4F1D5E43CAB8B8B767D8AA14EC60598548762C144821917
56BB89A71D9AA75DC4B7C0B5D6C66A4D98AD2DFCD5B367227B54C2C67C2D2538
4D8E7B9EB31D79E2C4607421389820073C2570C3EC5EDAB74AC0DC147F025EF2
D81C2284226BC26E09BD1943E95E4C4EF88B366E91576B6E330292DFE8BF687C
2500E3DAA62B3FF0C184955E04FC32A6C99EF29A16ADF045E0AF3C46E20A4327
3FE8CE2AD4D562732C8F47856731D2B3347F514E973975AE8458669830272F8B
5673C1B4B0F44B1F08930ACC46A54A7D53A672927E88E67E7AC8E934D993EFAF
C5D3C280C6065CC8EF2789054700D386CDF3420F37BCB6A70B9A92E46CEBE92C
C9D16802FFC00814F797D3B86DA474B23CB8650C76DEC4CDC7454411DE70346B
A128360E376CBE2E45148F21B62CA9B984BF232CDF9C3A96C8E2117EE1B5E983
9EE6966802723603DCA2903C2837243885B3A9D54145174C0A85099C0720C17E
FA1F16CFDEF8CC00721DD73158449C62461D80478E225F87747356B6A8047465
B532C22CCAFB13C7EA895B57D3B1754E41E6DCBB638191CF5265FC819B89EE81
BEB2CE49B36F45587CE94EF709FB9AC21E0BA8CC2927228DA25F7EC13C3CD3AB
9208C3DAD4BB882B76B85803D85CD34E2B7D5A9E4FF5753EC891959A5C63CB6E
E50CC3BF3D540CB6441B03DFC7D29C2C4C610551128CE2956C78B8E55C4351C0
372D4E6394F235C4EB26FCD917EC6E7B95FB06B6A93532B01AAAB4CFDF0E3100
6708AF8B8FA109AB755239EFA378E14BF7E40DA534D87F98D3853F02746477F1
CA55690FDE60AA52A2745EAB855FE9DDAADBB48FA4DF5FDB588BA6BDBAEAE41C
80D3D63B91E4F7F7918F5CDF1E041760648189C2223B108CC01B57DD46DD8F17
D52D4F415D17BB179FB01ABDD5C23F1E2C70F345691E0A02F99330AB30DD32BC
B9E3E57E8A2B21B74BF364F2F50FB13A0AE3C659C72846BAA9183F5312051300
61A6581DD48C5CEC8EAA4B49D7CFAB66AC05318FFD792FAB0353425C5C059AA3
0E7CAF540949F3D7A3F3CA35F241633AC928B1FF6391B6B039D8B7BE74F31012
A7CD0B185A980C8BD7B209ABE97F326AA1FC098A9D61D6DA889DA7A6757F6E9C
61E6B97BFB1563434078FE7866F5556409FC7C0ED67EE21C08BA72582F3E77FC
99B1AFB78D8CDC52E2933D3BD9E8389B58FBF9856CD402AD178CEBCA5EEF59DA
FDA9EB851B540764CE664D7BA5D6F0592F67C126A0BF703AB295EA24C65CF0BF
B4F960D1BC38B8D995FD3142F0BCEA13B0390784B8122FA1F25BE1362DA465D3
75526DA1EB0E526D408712B812E4A3CAA0A55F7594E2D8B7498C004377304ECD
638632AF5FE0A193F5D8D92A61F7328C802A7A10CC87832E3286E6DE007D857C
E624B5C2856AB1D9E59EA77B694CB3D22F1349C764B1730299CF9603C5628119
875E90B8B1D207B873C2416877E4821D3C8F3A7CB3C75DAC0EBEABE59BBB2FD4
68E4C7C32F1732559897E7754BC67DA59ACEA5B4A6525443D45DD6BD0502E6CF
141A9797EB12826FB5690F131F89C86F2E23E8536B4FA606036C2B0A151D8D3E
B991484039796BEDAB48179AEE55C855261FB610A981DEF1905A1FCBFD1458AD
7022F1A5AB060F70D8D75D001C7B4D02B951D2AC0835AD03EEC01762EF6C0502
96ECF0188950E744AB53050CE216C015B16BA8BBBA5F5E1EE2EDF7BD08F26F26
739506D4A685CB7D1B2D363544795520901652BD93A31901BE90967056D4F77A
4618D87B9745BD6AA0FC9584C78607EFBE91444A67478D64BE4AB59A9ACB31D9
ED8913BE6CCD34A9C35A3F000D2FC14B9EC1B3C6E30854380F85D41FB50A7247
8D81797F94FA2E94111D7B112647C5C9054D1267797DD7CAA661F9C17A4406AA
C5623BCBAF6CC5D424B720A52843CE6AA5B6D92365D296C10F9AB135340E2CC2
0127CE22E6B5DBAFD2563B90AF1FBDAB20BA2703E1AFF0EA56251BF4EBBD2BBC
BD5BCF93DAE5D7A7868AB8150AD1F69EB7454AADD0D448EE455348211F16B5A6
1E10041C4F3F2B51FACD25A2CF49DC9C534E73C1CA3FC1976D695C7B6BF15896
E7F0DECB1CDFEEC137DEFB4734C930F85666E0A8F7686E49F6927B3D502AB93A
34E800085D9F95118F59DD6D32BF3A0C6F063041F81BD2BA56D99C13375FAADC
0D39784646EBAEA27FB65E55FAA129211FD988076321E27E238C9E0A7C2993F6
3B6A23D412C1A33610E47DC498C33F37E0080DB96070BBA2BA84757E02C021D8
30E0EF728A401986C590880F7E3F76801AA83247644C5228993B5BD05AA2928F
7FF9FF527FD18A0B01057E2C8C32ECA0FEB28E59660E8502A510C00825F7B88E
CEB36F2ED4F2420659D0841B47C31D853C62159B5035001EEEEC1C4F6091D091
E8489A6F5B4B80441B702FEBFE496D0CC78442AD77391C0A13B4EE5CB40B9526
51EE55743B6F3F27DAD50366B5E797ED8646FF74BCD0332245A346E06516B815
FEC4F8D3D802F64F76A468E829BD104ECF7E6734A35D4F0404B062EDC7D7F346
BCFE537F027AC84D417C95781BFAB6A0D4714A323AA0A83115E8AED878484FAD
3448F4BBFCD65C66C90CDBFA88705BFFBC47E7BF430437BF7546C59748382753
4922EC95FBF7798F8FDB7F08812CF0AF52140286EA43AAA5A87E10A7187F3646
38398C4284119E38798FB6CBA99263B2B4D306B57507AFC10CAD22D2F02EF5F2
2304379CA7B3BDCEAF3F36E3A30FE677685FC4DE30C5FCB4BB0F0BE1416752C8
0E1330BB640680DE821E49803659BE6F09F08B10FA58AA1737E90C0E49F578DA
C31B9C3178133782D16E47B48BE9FBFCF5D154BDABE9D738AFB11EEB2F85A07A
1B857BD31FEECCD660DBD6AD3D118376DCC5D3EA28FFD1EFAF8802C3246403C1
60B26AA96F57750AA6CAE8E885860F49635B277CA95F05CFC1CCF44689044D78
9E0C382527BE50B8310823D044C1F53FF9CC88627A310E38EDFF7FFA892902EC
F5C7B25A619BFEDF13AD223CA2F6F140B1E57BCD46D56F8045A89B46D7DE7027
0AA30D9C4AF09B09626F83048DEB6A82E53214F9F30374ADBE880B8E044E4662
EF0AF221544DE5DDC61B176477AAC8583B1FB0BC61C7A26294870255E4A960FF
5D788E5041FF7AE67D07BFD4AD7D7C4574F0F05157113BE571E8603B709E67CA
767DC3D289A735E2E2CE219FD4274D069CF4BA39288125524FB9B80CFE21F8EB
5C75BEBCAF81A56B8E5B3EC29A0ED0C2E8781E51F78001A17F8D1001D42CF347
3A5F5BF58AB71E588E44AEE178278F78878C1FCE1FD8C6DDD3A6D83D138F5098
8367589E70FBAAB57DB6193D0977A98AFB748BD7D0C2B9BFD5BEC2CC3CB47C22
5796C2296499C4537217130683B5618F4E42C4900F9BB001E7AE549ECD98FC39
41DBA940165B86E32599090FC97F0BA667C8EC39C0A575E946F076243FD2BDC1
C21203AE6E013AF382D076734F1B28A2BEF186CC15D63F820578053451247218
A8345154076BFFDA274DE849FE185D65D4A0E3811AE84324E7AE061A410393DE
9C68F901719EE63DFA75E11C3E0EDE1220D16B8B68D32AB4FEBDB8425D845539
17DF929A3D8C9A7A2ACB68561A38B38A7F1A90844F0492A085DF037A9BFA0C4A
A37ED2C14282B995485CE83DD4100B2594B29AF24D2951ED1BC219DFF052E1CD
031B4F96E727EBD08A9E21266A7C1E83EE6BBA4FDEED68DE5A261444C3C95979
4CCCC846A84354105567A0C7087F47326CA576F8E280969044AAAA763EED4585
8F8706C4E7CA642CB3B8EFBACCB39538816B7735419F1036BDB37DEE058CB26D
13CA0546AD5A13904C1C794F196F196DADCD65E46283199D5A2682BB943DDCB1
F8AF334B793677DC9D0D6B2CF2ED2DD2300AA1D23F1B814287AC06CC61F294AC
1CD25B319DE250738E8EA3E6197E0FF2D6894AE97057373D81FA0E5837B06A98
E2F5D48EB8CC49A07D660BAD4118026F49E8E687AF91971575A168CC27C01592
46725B42C853A98F8D2ACDDDCD68BD4365D0EB877DEF741C6E1A1FE087DAF8C9
464C6DDF70122F76F9F3D935F174862B5D15CA8B6DE91A8AADC6A1A4196ADD26
A84E7FC14FB85313830F5779251E2FF43462E4E9977E82DA876235F5BD6EEC5D
7641B544181E89C0F0AD9331C14E263C15078FCB6FF651F45CC360CED92CF505
F8D3B8E6FEE2A839FB365DE477DA96682A638B07C7EFDF8A770D5F49817A2C88
C42F71C4FDDFB6030B11445E81E2AEFE4C7DD0D7361F2692B36ECDCBC5ED6E78
4C7382734B66B6B3E8D06F8F202029D2889BBB0189C6693F01641BA44E80C652
BF765F9C1943572D0417D15B2482BF4899482BA2C45FE9F2D3E7337E36B806B7
B396B3833267C84353EBBB9338766F05519F70C945DB288C6C3B3C1AB46BFCDD
A190E9E93C8DF81D89A3FEA859B8369B8114E1BDD4801170A793FE0BF167D1AC
EA2221E0D7399175CEC52A5E0C4B26F996BB0162B7C0285C7102F6B3FA48C17A
E21DB300CCBE50DE5775D6BB6BE00A5E0F5F5DC9D80D92CF01A8EE33DF4648CF
63AC7C905B13F525B3E8521A4C4DA548E6A760B62CF88BDEAF1BAE928465A36B
E4DFF9D0F8BB97DA6544179C39BE2C981AAC25FE2365D18733275A1938886D2D
C102825CB3EF2A783A5CA66F7648D5A1031F84BD428D432B450BDD1A005D4D07
C7EF367B1F15534F3EB74BE80850B641A2C3B18ECB5E4256A3567AF2D5717D9C
B96E7FF7D1C323BCA9223509BA4EBBDBE6BC2A68415E3646B522CAC11CFD9DFE
936FBBEED32254F3C454F7034F4E1E07CC5F2E150A28C605E9E3499C15F3C1C7
5BF15E3438E38676AFCDE9AD568319DC6F85E6AF68ED6994586B820935161A71
4F070388531C5BB9B3676EE853A39B40A5C5C84C1F9F6C7DCD21433F540A8F49
487216D0498C33DD55B109F616080F5BF29107A418F686DD2762DD99F13681FF
EFA725879CCAD9B555F26520E00BFAE18286E9016F978C6B2B032599C3B0056C
797110E8AC861BD2F3750E173D0DFA60D4F1FDCEEBD7E0E7E81D522AE8E2AE22
ACD9486356C07932ABC26EA02EA71ABD2125AB6D1C56F70CD3DEFE20CAB03371
38E6F1B0399F60AEA941EB929C93396CAD48E454F22915E353A7828281F31425
B2973489557E814F6E1EE1D1E4524DDF343A47C28591EF4EF8C97AFEF7D1A6BB
05DF9D7F1353DCEF8B1106D9E42E1BD7D7C375A8D27B8B26B0F41D787411855D
60DA659D03B7104AE445DB1EFB3B5CD6F92A9C3937D53F6FD4CF5B72395DA252
0BC96EF3284CF7C15A034BF45A46512CA49C06D313F237F4DA386A495D5CD275
85ECA2A8055170D504F0A0381D6FB6C2C9B8D4F3340348F6C3AF193D3FF20550
2FA98EB959566A758566F16EB1577861DBDA17371D616CC0875B14EA74764AB2
19B18E44A8774C716244C14D0A466D3634486450C09F36D39E927C74F25EDA5E
5D21968FB24EA83EE5B2DF037B50115677FD22EB916F942C61B563551B67531F
E13CB5631C45043F42C65316E33D6C0F9402B465E7952B16F4C01A8AEF272D0A
5CEA113A6C53EE73308181A42FD9F6E788109B0E708591BBD98F35635AF18683
6EA14CC0D4EB5F72EF08BC5570B02D93192077D7CE0A28D81DCD1E8D94F55FA1
F21AD448F8A7E00E39C0F4EC3510619779B007325B80632E8FE3629B4B2302C5
13421B83162DD2CA1165E8FF422B62C5C68BD64A5861B533D6F7A6E0FF8F91D4
BD8CB1BE6B3945812ED76E7C90A8A6AD3111739F32D6D0381C8F752E9A8BA8CB
8817AF3E07930B11BF28D776A9EC83FD75E095A09D124D346ED94DC2FD9C5DEB
0D1E9B061789D08E90341B4113822519716A5D31D18F40C86D7AE94C50E6DECC
889686AB52E345137B2A1C7F766B63A2F0B96FCF0F42A0F4D004E179740D440E
00A93E4A1F164BBA3165CDEC4BAA06FF834ECFF1A19DA3A4F7D0A172E149B269
02B059821CDB3B15AA06EF3BA7F086227B12FAA9D620113A18D118B979650E64
6A021AC21E836D44F95FB85A0214F2718925EC7138BE2A4B1BEF4AAF94E0493F
DE308A655F375EF8D935323ECDCF61A2B0091C6D768CFE644BD0397577DCB100
AB8A8A7EBA534C18891AD72CE46104488FA4EB87C29DFACF69A4A0FB7E5FA518
DBFA3A9415975C22CBA6388BC28C89CCABEDCCCCB93AEA254F7742B064C2939D
67D96FAD7828E5E203F3A85C4DD7E8E47CE2FAADFEADE1892AB8C62C6A37CD9A
9191A12D2F5F327354B9F1CB795B50F7CE38AED4FB05AB3C91F030E080E8E53E
32D85C497702E35828B353CE142AEAC9D40F12C0758CE4E300CEA4849629A3D9
E714F936E27FD9D572DCA30D35C693B9AD261C3CF603FCB87651205D6CF13F48
B753309D8BFF61DF17BFBDBE2FB8BF4BA63A363CCF933C449AAEE0A157C20D98
7B7AEB3CF7613C59139CBBC3B6113E9D68288A8A324AADAE80AAD15DD2581B14
1DB889CBF6699DCB7D2970392C6F74DE25899230BDA82070796E75E9F29658E6
569A201CDC0B6D4DC00672B6F27A827DBB2ACAE9DBD61852EC1165E2282B9708
41CD657C7A2D82EE42B26E7B2819232C20C50EBE9E8C67D59FCB80313124C42A
A8C6E4BA0BFCC97872412E075A40D5DDC439D8A64992351D3C3F54FC3B5563AF
E5A5317B358FC51347BC4FE838472A8F1A94A91EC64B4543F552B9187C731E91
82C7C6A1D52CFA76989C6CBB6330C265A5B7F41D915514AA0FAF252C2D470BEE
9F87439BC8E1F55749C832D6FE26E1653DD01511DD562B2D19792F25BD45F6FE
01CB6C901E7832C9DAB7C6297003A42DB2745DFC4F10B3DD8E35D78086BF5238
336C1440A2A20D489D2D641E1179234C265F2109FFA056CA89C4B5E4BA6D23F3
6716F5EDBB9DE857F53DDE90575EB8FE2922873B0C07933C744D3090857BD218
00FFB6AB533A5CD92C4BE598D861FB6CCB5326F6045E06AF3D7CBC1FC4988F6B
5D8C6AF233C3C2792A42338D892C8E1C2DAB56438F1C10D151131DF5557EF428
76F76EB35EAA4DFC8050FA541E1ADA337CC359A563B4BE5B7CE1545270CD8C16
1B690B316C773AB2698E8AF7DC253EDB4A741D428F601C18B85CF20C830217E6
F07F916BE599E3294CC9B0A1C388B1C70F96E6E9B44020D1EFC6862CE30DB7B0
2AF41D9891F7AEA9B95C3E17DE80677650B9602600F15B0D92F60085A5047D4D
B35348B363C36F9830029D8375F995625939A0A69BE82F08BB662F92073CA6F9
B1EEB698EE21B9B9410B1F50CA3696C194BC28BBC4A91F4F2BD34AF85E64D31C
7F7AB2A00301F004B0AA16C97C9A4C8D9BE7764F690B226F591F2753413E6171
27E7B3DFB4C97AC4F74BAE3394418229DC1AAB6E600628C7CBB47B4F64619155
FCA79D514A9E5A3368F1C202E2C0683AA630FA6436F735085115BF77D5DB4037
5C5E0B40B5FF1AEC8D777AD8F0F5976FA6FF75DCB0C87B8B2FE52D68D35443B1
2B6A2BB1948B07D8518A8E02C3810457D79C5E65F22980D315E0061E6293240E
3AE269B61DA8B7817021B10FE443531D92C5254EF67FBB93FE4E3350BB168086
04AB69C7433BCBF6334A59D6DEDB23B6D652E67D31433CBFC5677741AA375205
EFA304F8C5A7C1D6ED97D0B4DA9DDCE0A2E1BE682C87C8AC66A61BC681DA9AE3
FB805D56F35A18A77AFFD1CEC79BD2ED96838BA4DA63AC8AFD58DBD6303212DA
A923A47370972C08743508EB8B39E33E7FFB3BD4BD4174E893EC0F80BACC5E16
E77D307E529304D0A9DA233B0D12928349B0A0BA5921AA479B5B48F87B63E0A3
565639CBD91D4BDBC38169966D5E1909ACBFEB34DB3BD107A8B5E81C6CA791A0
CCA0F5903B3498A65DB098F8812FAD4124C0E79947DC0C904B1CDDE7327FBE47
9B24E9DC56EF44BF92FE67253CCA5AF44586C663D4F71B92309D4BA7506FF2E6
535176B63C76A3672054A8A2DCF175F3932122CC04FEC35A0023F82192384592
AD70FFB73D5027D546FFAC1019EEBEF5409421E261C973EABD9634A4F6D3C5CC
AD0CE58153903D29EF58A6D929393A15FE55B9DBFBCA9314A5ECEC4E9F59CAD8
2DE4BB29CC0B15B45B0BFC8AC82A120EA7D9601B5657A95010F4FCF6CF577BB4
94A5B9DBBAF10B53AAAE637757F315B229493B35F6193A77E998462D6A4AF1D7
EDAE1AE746539CDAB99F48977139722DB148540D5EA4A2CED1F905E815F2C04A
3937F15094FE589067727C5CAEAFEFB54E9403E8460673243F3D6CAF1D47078A
94E6735DCB06B7C1EE417F32D7CDC562BD50665C0276662F05B439BE42DDCDC5
9ED8B3F7EF5B1116334CD639E359701CF821383BB92C2F382C0FFB9E1B56E1B4
E6E0F98D758E1F58080B91D193781C39D765EAF38FD502BB7970BABC5FFD5F43
0D271123F142096B4927DDB8D993D8A15B42AA1FF55BAA08DC5FDB21A0E0FA4B
21B51F3E7789D60D6F0691F50F2756B37B56A2D11501C0FDB76BE1410DF4968B
67FF36285D51444DD58A3C1A715888EC2642F401771859C7732BD57F0483B78B
BBE29EDE2E31F837DF8671F89F79A2060D8429458EDBD1297F0BD3CABF48AE07
78AB03F9C157800F9D9C27522ABAECC2282D43623D2AC654C28102D69AE624EC
C38D0AB864FDC24E91B8DB056E1262C7009B9166C2DEDF97B0E48B8CC7DFE8BA
9D7BE47ACAC8323695FA6890A620DD863BD5364A28DE4283D96979CCB1E22C79
E8CF744F0A8735C3247550398E2A60F51BB3828C6B52EF296F939F20BD4C4DE7
90CDDCB68CC670EA5B3D140A3B9599A6FD7B8FF7AD0711E9D787E7D4BA90FC46
63FFAADF916E228A077CB3F8ABE7FCF57A38E114216EC37BD89C5CF33F50F0BA
F05732C17FFB56DB5B6E08B150C45F6938DD79049927330C560931677B2BC7B0
04C7786881EEE4DE5395FF1A2D2DB7180BF29908E37B50C0B011F02E00B0ACF1
6D37FC6491640DEA0555A3DE1C067666B606EE926C284D08219AF937880B6D5D
C23F59ED262BD3075A83CB86194698E18611742564B89CA5AEEEE5AF178B689B
988D1E5C76DC097254B46FE38AEE456A2981E8836A826BD6C9B546AF9DF768FF
2C5B8AE788CCA46698EA794AC7B04C514420F00EFB0707FD0CFB80D2F8A5AB07
C557462D5D23EA6F98133850F7FD4B4BC91837C13932A76031EABCBCE4FFD0FC
F3B0B3B7A7E6E1AF90F9CD42C2546DCF6D389B34C824064780886E0E65AA8B38
3FA3794730A696543F9571CE72D9458D4B79C8CBC555A75106C8FA1582821626
A21C9BC992A54B69C4DC8928ACFF1C1EA6D47CD8BF186C9593055E07C92F62B6
2EEC0125C2742FD2F0515A62DB20DCC583E289918FCC37040DD4771C1218921F
D978D54363029E92D6EAE72FB04C6D2B4499903019222D9E187A4D4E3A9D5340
57A789A2AA76C6BE896A0ED6408A6B04CFC8306A942F50CEF947EEA334D41B2C
C72C8A1932F0D6440FC9A6D7BA9F38EACADDE9506FACD574FFE1B809B3BDDF92
E8694A5AF9869A7ED4A02406022BA0DCD47B431C2F8F44CD9D5F5127D99FA213
2E6C41628AC3150F9FA7E4245DB155ED2D98DA057A87E541ED723B5FF0C63814
23798D2933661E333610470D4E854CA3A2634ECE79BD130568B187501BD24F31
56CF5736C2E8F84996C634C76222B6D736353AC4E2239181B9FC346A50372C58
2171A4AF21CEED3C3DC4BDC973F02ECD0ACEEA511B20D4D5F72565C43F022989
DC128018331C87CB83A65571AB482E2DE257D768E496928355B69718F95AC98A
C233A6E65D542FE7142C6AA828D2F5D56E2EBE0C3F8E456870FC6331BD98105B
719F3D8DC814854602CFA5EAE2D3112D43FF22C4723429BCDD7E6C18A54E4358
F2FC35AD5E36E6A1E22554AF326DDF81F1DAA71766C9B0D3440CE049E4FD8F11
83360FA32CA967FBDF1A183AB1941874DBB0AB81350F9F2283A52D2883D34B7D
A6679207C76C999903E2D33ECBE2A8B41299925F026F484FEB32AFA46F4BBCF2
C5EDB808E795433ED8AF4E8547699F518675AAF133616F53DF2FACBBAFE3CB90
93E776338ACBF0883CA9C1CB96074C0B4DCE612F5DFC814690F17320B28FE8FF
BEF52A4B6A1E0CDC8BF33E5CE60D2766558B3A7AFBA72B409F237939C43BF179
895E1A404580399E65C1EC0F6753CB733F979E9B46603F14F884E46AADAEABB8
EE6140B586AAD262C1B358E0D52FFB821C17B58701F3DC34532AF42ED5E5514C
A68BB67B6D0DAD8CC299A8CB22ACF60EE8530BD8B239A8DDF7AB69F9D0B41174
39FA69CDAC5352A1DEBE298B7883E0DA25554FC82FE4E94B900DFAB390314BDE
1B3734804F72600587293247C5DB2C5FA1F9A3BCC6F947205DE82F1F269661A9
5AC6CA56E7E1B0F498D7C733B4626AE3FEB4F127D0689D09A10C0B0BEF065196
3AEEA3507ECDB79A6CF9757E504385CC1CDFD1EA14386B0D16259548DCB667C8
10941A73296DD406BA5D5FA695858EBBB2A0CD25E12C19347D33386F8A2C1BB1
0445661E0B5AA0AC4706B0D35EC4DF7C639F175EEB2188E9D09ACD08123E09B4
858A4FB1BC1BF93B1F0A90C0CCD325A86ABC6DB4E83E232FBC7D2834B64C9D7E
90CC5DF5DE6E2C2EC152AC8CD8F14655FCA5AC7619AF8D95F153D6B5B012CC71
AF8F0A23A24FF33E980F844A2E0B92B219705AC7DD22CD157327FB99746825CB
278DBE285E67328F96BE577CC30B6CE0F06ED338449D1D3D09D27EA8C1CDE68F
1C2CD728BC91BA03ACE853016CBC6216396DB2FA2311A06BA71B710CDC7119EC
61593EC32F0C344B0DF25879638250E227FB09182C3819927F610B037D62FE87
1449D2EAA96E5F6F35BD957AE45DF6748735E8729F474B265E5BD651A5A326A9
3DB627CA5D773F0B1CF10E175524485098742DBBB924915684AAB5BA10132096
25EBFC17F333FF09D4487EF7882666D7AA06F65F386A5C4853D791F4B3CD728B
F48469146EAB60DFCC4DC168EF2C8A1A7626FEEC387F2D7C5B0D4D28EA1A368C
99C778851152D0ECCD5D9140740EDCCAE0F42203B2803D2029D2403889525888
EA18CE93A46167290FD03872BD87E46D78B810895316ACF09C0ED3594F4DD639
28C7EB68DE604375D32946CC1ECD82B68E0CCD145C0B7F3C4EECEF8CFFE6EDAB
35187383CE731305F98F33DE7D19C2F6AABD8F491980737A7B1408D4DA180CAD
49D16EC502212ACD4ACE663914735E2243BB0982A2196B39FF6DB85CE3903208
8DBEB0F6E8201DAA7AC6A7F8AF568D2DF730227F07F0A1779FDC66915E221170
748BFC8A4A14DB003C5D21197F835B183FDC1269D70A0B1829401866D180D930
9F26FC2689575C5FC57DA51485C3C4F8605DE795F8CFEF26954EBC88AE8AB2F3
1DB883376891652D14D5119F8E513797D1D55E711E6B25E1E51946FEBA8AC39C
5CE4E5D6AA1C6F813D68C3D0E18DEC5682F6460E2AF9E76C57B6AA7F5B3BF9B3
15C9C46AA3B83C633E410C32F5B4A1B9064D01DD620E7FC432FD294D971C57CD
A9247DCCCE231DDC44F86B5716DCA7D07D51FB5DBB0CD3440CABCC4DF0385672
E48B8259D335D0162325B2D305D37842217A30AE88A2B46401633EABD93E2DE0
9726571C70B4F4110BEBFD486669942A73AA50252B780CD1A210EFC22046B449
4D36D844F53727F4B65D85450350A982865FA9D083F8A63723F7E5072C70980D
A12393D473CD29135F8C77319A9C590BED5084CE548F085D8E63207369EA0248
2F32ECF40BB5CE31775C9E537E95935D47F55ACA0006432B3F1513A14DE29AAD
F0AC9F4B4CC126DF2779061016E32FCE4727F3FBF6C63C2901CEE4607E7838A7
7B6EE3EB0060CAF2AE5233F0F5E4D7AD6F647862906D0CDC93D74206E6D962CB
4569296F11FE67BEA8CDF55ABAD3F168461C8B077087AD3BC94EDCCB1341B540
4B401FC3204748B39BBE76D32933BFB3185C3972FFB6954BBCD9B066462F565A
CA8FBFC73446083C41506868D67A1FBA9D012360110F4C96901E634981F74FE0
DFCE6834D1393498ECCDCB076A6A7E850ECD3A062F050B7FD2B1255870CD61C8
CF7AA8DE567D174EC90945404C5C43AA99C05183A6B338DD38AB086689E8B7CA
81897749909A22E137F808DCFF33D406320583193B6201E1F9F453C94E01FCA3
05E0699ED2002033D0851E28921CBC74FBEC1AD8CE41047A2A4284D7A08F95EF
2F9B2355F428CA3D8C47CDA5983732A1600768CEC7E2B379584E95B58B79942E
DEABF4C7FC4C82D19CE7C4193F8338D80B9FA7185F13386B01A4894EFB18FB16
1B9581DD9D4C45370DC1C9594F7E01D63151DFE1BF325EC936C9825E30E3EDC9
91FE7034B551077515AE20AE548309D015C37A6F48919F0767422DBFAD050858
D6CB24C922D9F48025166372065580A61ADBB1A575F7D157800AED689DDC3E89
60BB6C9E5D5B722B697BDA2BDF56DD50DA155B6A248DE14B83C7BB9226B85B30
1431F192BC698286B3BE8DCDA5CEB0E2590803255AB61F8E7641F58AC1ECA0A7
7C67FAEE7EF602692B0952BF0C7EF088B0DCCCCB7E7B263889A5DEE8786CA07E
529AD7C6EB63CEA94E065B69860C378E3462106BF01B0684AC3A9678108178F3
3EC4A73DAD7E3D454A365D1D4026A3816DFCC1572CDAA62CDB59449BBA27465B
CD7F113C9C1B931168DE5DECF9171AA5B74EA30384F37D44F4096D27DE45164A
533D2C666989867D870897B2AA04BD4228B2395965E3BFF190F37DF8909AED57
A34577899D9F5A4B667DF1CA63B9333E6FFA6342E9FFBD9C7300D3C2260F9633
816ACF8132B8CB3B7D9A1F837677C5EDD9D1F90F107F1483EEF642084682982C
6FF3A7772C4CE1A387A5B1CBF361DCBE24765804D531A4A4FD236804E2A5C7D8
14E281480971FE849B7CD0D683ED1EB320A83EF5F8EA5486DCDE662038E05E9C
82777BDE416383A0F93562B59E3FCB7A09F9B0F007CF35FBFE163A00DF6392A5
0432551DFBCE647E55B2FF6F59CB1D410EAC5899303EEC5A1A794EF32C1B9161
E874EB2B8EA4A7DEB8EDC0BB83249CF414967A020E5B8B0F4C985C0FF4738600
BFFAE3E467BEA9BBE6258A20D9E32E1745184D7DADAD271E681133A397322658
A695A15383C57CE6C14E09BB3317866FC07CA3383968B30FEE70B61807309484
10E91DCAF1CEDB30F76D51A3CF5FD035BB860D0E929C16D8514CA4A9D64B3059
B6A7EAA62AAA3BB84AFA3551A8179D4DD22959063D5EE48988B1B0B57FFDF81E
13F71D56EEFA0961BA5176A2745C6DE790840422AEB41877424769AD11C53BED
092CD4C17A17A440688F12288E36AA0366719B4BA72DA3BF313B28DAC47700D5
5A34FA43CAF902D13CFF682371AD33D1C5B2AE7027977DE983BE8BC92C1F858F
1B3515A52556C0CC165A1CCA50F1B85F57673C6CE09EFC4E229D463548AB43DE
0D90A7E137FF9D6CEEE5278F058EB19AF974F07B56C16CE7136346205DD548E2
AF62F50DDD4155D43160E1B01C1263D3DDE27D9F06FA6C4F2CDC851039011DB9
4742CFAF5B2E24B7E24EE88FB207ACB013947A866A8ACE63BB875DEEB95FD18E
974B39A53B5DCDCFD9FB21A2F8D90C45FFF3BD147086881CD9C9335856F5F195
FCAFBC381356C1D7466AF5A5083378153907622D73A70D1D819B9A10D8CEC848
4B378AD48CDFB645FF9DCE1B9456A8F32CFD353EFA3F9D09838CD519B1F93847
4501DB42558E15D1BD132EF3D00ED366FD143E4E9C936EEA3B185A47591B9ACD
F6F761B032A4839C5FF4BCA78EBEC01BBE4DD79E7752FA9C4A90659DD7AF69B2
FA8E9C7B471454631F388B1327B6D213BB31CD5443A39D34B8038801E370D744
9C56B5F8ABDEC7E6F0B3EF6FB572D8086731CC6CE673FC8354550B24E244B24C
54CA777172ADB6D2D671F7C74A31CF60D1B6C767A45C80BD479DEE62F3C5EA75
9F2F3951A9603D41A3E8AADCDB4D18753287AF757E77D486D157916A2BAB6111
87756FD690E1853E69A5A31A81B6CC67F5E2F0837B90E198D5A70CB33AF918A8
3A04B3587DB50860F71FD391D9F5986179BD94C8F302E9FB32F894C4CF47F13F
9E7C89DC19215FA388179DE4D224F19182BA7A3BFAB35ADDB38514AC894FFC69
1E00B2E00D3A171F46D213349004FBEFD6DE3A2FD8163905A21A3C24CFC657B5
10FF2A478D7AA68AA53971A5C0B58532B6B5BA76537DE6E813864CCFFACC8D1E
26EDE9160DE149F77BBEAAD26D732C0A5787C961FE2354A00A5EC4BE34218E6B
25E840A594BB15F1946C9ED52C05B52437168215A6BA3CC143B7BBD1767508E9
55BE03C74613C3E5B7C8EA995D5C410F14D586E12D56778A4220B7FDF85DE8F0
E87E7E387486129299A31E2083E4DE5A410131B866B5582AF292CF744F30E19C
52DCA1387C8406FD55A4A112AE2AD377157EFB984E303B1D37BEF05CAAC06944
96E554CFB0C0001E4BD7661D6B521F456E9EEBA8A40D35153C336C37E21E3E82
144C358B1B12E2508E93DF30586958C707F0205C3F9872476833B252DE2788C8
33C0C5299769BF8A3C47EA80A353B71E82D1A5338D21A1F6AA8CBB9B5DC32EDA
308F149704EB45943BF7D8458B120CCE1C66F5489890731D895BC4215406A875
EF06B9D463191F1C11943BB76D83D22E65047EE2C12F07D6E275D32127C94702
D25AA31113DEAF625C7FBE04A38EC781C16E710608FE82EDB807EE2E53E2FE2A
4CC0B9DE515F745F915FA34289BFE2575672E1D940B29C8620D497576B7B0FB4
175BCC1BDE4B23567655746A1FFC73368EBEC0F519652D1F824F6BBEC50AA811
96AB799AA11B6B92732D4980EFC41B863696FEEF72E35112E7BADE4F046AF23E
68D800A8415D70BD54632CA65D8CDC990B7066D6963C46D328D35059C23BB9E1
DE1013DF541DD91E4E78A816C330A543ECE21D9AE53BE7022A63E40AED9BEF61
978D1C0B4418FC109D769900193394C969F7D5CB4300838E6E37D59577A8377A
23F639CAFCD4A5B9077C1F226654D30421DDEC90EDD35C3297DCC1C3E01EE5B9
3D616D6C0517DBAFCB5215F1B593A0787ACF533199348D11730EFF7C25DD5ACA
FE411EBCD2FD3499849375721D342810C74064EF022EF9FDC2491E6B5736ECAA
1EDD8E23956714987DB5FE6AFA80ADECCB2B897C7A9CE0513B324C57997A0DED
C5F25188B04FEEEAC6EB35F24FA95BE8DFA5438A68769EB407EEBE1970B02D72
8594F699800CF85B08E39D326A4E7845D8B59BF7447DA9415C4D4F92C8F6ABDC
B4006CA3F3B79124A9E47F4F5A8A15D697DF7E5483790A5673F267E51859F4A4
55482B979DBDE13544B856AD10C739CF98C8CAE1F50A8D81F244A01498B59AAD
06E09E58B7711FD642F61A533698803DFB2A20226E582EFF3AD7D517044090AC
B1E3A4D69168407AFCA4EBFA21BBC85D81C76879D91DADEAA25F850083BE6CC2
6AE7437664AC6A9720CFE12B66291A897CD411560247B4D041902FE833148765
EBCD0BD1C62E95F659D68F0D69B85BA188CF86213C0BE4656E35FA02FAF5101E
1AE6B7CB286C9DBDB59CF3BC025C012E85B2B1C1D5159025883E3130C65411C5
0FE801392BE09C8FEEAE1803EEABEEFB1ABC2BFCA9C8689FB90EC4390C88171B
C21574A5D8F47774DE3A08ACE5F2C2BC4ACF593CA80F3EDC101E96EC41F3F86D
6A63731F9864FF0E17979CCF3C0F685EC3D19B23A9F41E4D0C19BADF2167E3F3
B732A74067AB444F8E1D84E1D1C15FA740A00EFAB0C19B7B6C6A3BF99DB5DE06
EBB5886888D4A6C5C7AA46BF45AF4BE807778C97230B9C7606CB953B09ACE659
10521533282982BBF2DB1F468602B32E6EB0F0EC43C9344593E348050560301A
B125739FAB9FBEF8523676B7509EA7AD0D2111E3585A0BAB9B7921775DE49BC8
132788B2E841F0256A95E8275984BBDD588CDD10DEAA79E7BAA7E7FFA6685B03
1BF2D89A6B610790FD82681B0435C7EA8C1A0A48D9759D0396E05E4ECB9E7FFE
81A6AE51BD54DECE76FAEDD7F3A7519AE3CA885FC826D7A9FCB11694B694508A
A4689B87969909838CD519B1F938CD8854B02920BE88F84E2FF23C13595EFAE7
BFE2FBE6DE800B015E80DB2C9CEACCB1E5595721AF6C3FF776ED79DFC25AC2A4
D3ABBD3F6CC1A2D3F3148A65696FF8807ADB44A58D68D468762FE5B739273017
77A545643572C741F526E1C42119747CEC01D9B10A106F17B39A5A1AFBA562AA
91BD62B6C11EE01EF5EA9A3595DA8DD910D7770583AE6876FCCFF261C21FA581
E86060A08DEC9CB25A3D5621DD0800A9C690F9DCDFC93CC2A5353575EE0C2661
081D9CE4DB60D9BEEE8451F8CD3B277C289C864D54A1D5C8964FD702766B3691
6DD22AF08220086CC0ACFDD7F97E36C2ACE3D3FDCC55794EEEC590A07F9A26E2
9DADACC96DE3069F3018137F46571B4CBA36211A17C5B44960014C45D448D649
4E5B3692276D8435311B429E1F435B9B8C333207B8E40C2BB00FE15F78B4A365
37392E6621A9A05FC5DECE36FAE80BE54C77342B004150E4A8878F02E0B498DE
9C1A5F110347B7B612146B5E4BF0D3B20E1180643F164F819C35E9500B7B90A4
C13C05CCE5003D5F23F7CC75812D2FCB2475F074A0D44FB3B5AA549AE133CD7B
ACAF9F7ECD175ED7000248B0E799522C11FDA4C818B0A3812B714D9025814369
FE71C394AF52586F8D7AE7A911A5ED5DA4370CEF98A0D2DBC0758807A2CBDF65
5A93F83FAB5A881C78C19B3933C123DC0DE74C8526BE644CB5641B45A0687CED
6E30AC81F9D0980AC021427DC51C69967B97BD3EA8EA0369B2F4A285E60FA00F
D88F47EFED073BBFEA8DCE5D88E6F3954346850CEE2D90DCDDDF2859681D7DDC
05AA685BDCA6D3F2057FD13BE3E53419AC07368BFABD1E0F469636361327FDE3
7248BCDEF279D2F39E3F10736FACA7F6BB09125BA76D99DABBD711F6443FB1C9
9F314F2DCDD7A62744E2593F1625EB862D70DCCB12BF33ED6342EF3CF4319EED
4AF80310DB85AF8D9080EAB87A91353187BFD652DC36561D95B5E6789E8ACD9B
8E86EAF6757178108FB870E12A57A7047DC65975C97C47BA19DF9635CD0EC255
C7089E990FC6E0D346853DA730A560C802560B8D06F828161B59FFBD492E1A23
DAAB07C2FDEB6D51067F48409D3C1E1A165DB56024EB018B9F6C929ADFFC2F1C
D0AD65260CF7AA6BB04C128838EB5793042A49CAE5E19E9C5D12522AF7CC1791
8A59B7B41483B8FFC69B77AFA35274588303F9E8178B4A7C45141E0FBEBADCC8
7EC16E8D5EB47419A4CD8D7656C3FA0C12725A14BDB45D92379CACEA43CE73C4
B7BE0E08CD35E9BBF6582493B76EED4DFDA8409ABAB35BB210B77F002A6BAC67
DA45FAC0B1339E63A2DF0854ABDADBAE357D28A289F5FBA009CDD6A111CD7D73
9BB8D026A648420A1AEB659C973D52B28D6CA92DDED5BE33EEE82247752349D4
DB9C5DEF381D0456CC203C348DD73C1D3BF8250E4D2DDBA4D4E7848A25F2E789
C18EB54A6352925517B859237D7F5218A3AE67A8BDEDDBF2F325F764F7840D06
83F68416E49F71D0563B201D364E29610F51605DE7A883D850F4F7E5F3A3B3D2
F64D8C9A780CE75C1D1FB1F0B15679BFA992CA2D8945B38A4BF8B7E5993549D9
32FA657C9C81BC5432D45BD5C5CA133A4AAE7CAB46693C0B590CB56CAC844C46
492D5DE5FC1072F7FB0206DFC59CA7865047F3FE900978937F5C97252EECA5CA
374B608CEF10DAE6F7DD940F08764DE837286EBB53EFC8AF3D762DC806E16A8A
B4FBBFDA427F0F1101517B2DA36264201B557C997882FA2A418D110C76E2F589
E2BEAA6082D53D998FFA0D8E535E5AC0E01879174B5C7ADD841B22BCFD2B6A49
A29126CAAFA77FE21F478248CF21986DC483EC4FF27307585A437733C6C4A987
E2812B8CA402021F33A3B306589E39DEBF2F24B0253D61A9F5AB6BB0345592B4
2926CF2AC2CCD95119632824D781EAEFEFB6AABAD3062A9C6CBD3C6383F47215
9D705D66EF1F1EF3853765DB8C41918B3DC39F2DE71F886591BDEE18E063B395
DC84D0194A2C05C6773A7E262648B70B0310AD1D5438E038C7A274A27A6854DF
FD32B2A3A6A9713E6ACD1C362268BACAA862F841E416430F8B440662DE37316F
E19495581736B0FEE0F522702E81A866895566BB49BEDD95BAB691BB29CF1677
33EB1B80724BECDA6F994A489F51AAB37DDD0797CE8710E4F3D621652B79CD52
AFFAD95E18348CBAE03FF8269ECC9C3CBC78B0826BCC9C4DAFB2FEAADC8A76E3
74DBD1AA2E2F1D1418E8B455F3E84CA1856F591A0C693F79497FFC3B8B088EE6
6FBF75EBFAA276B5391ABB3AF46453EED1ADF4191D7947DD3A9460E41D038277
46224AE3F77A0AA06F36B9227F74A1687F7DF9F216B54BBCB0822D88E46C9909
074C8B69A24AF6D42A1F05A2B5F750ED1A437DF6480BC21F9903195EABD5DBB3
E16A98F1E92AC4A52A846A49F1A7D264A22CA3C192AAECB93C7FFF2F16174606
AB2770299A4EAE74122FF6840C84E59ED9410F4D901B7B6188C55C7BCEAD6025
831A7DC0DEA798EFADDC050817A6C3033A71F05B694C7382FE2E1F0575F2CD0E
ACFBBA826D65727B80673D6BA889F51458A7FF5F8BF26006164709596C0E7832
1C9CB5060E394DACCEE49E15DCFC537A774E8F036EA3BD1FB35B47C8B04FE5BC
3367497C95A462341C8707177AF767B8390D065017D52CC5CA99FF089F19DEEB
A90489ADD0914CC97D127612C7EF5F32A8A3C6A4E7C3BC8F04EF6C58A541CBA5
422AB89E041D629DB8446F058199B31DFD6084430EA6AB0D63050DAFEF2B2B97
0EA384CB6EA25D04E4DE8A55B5280D22A2E538FC8CBC5EA6BACB0504F911A391
72FE4A63F8243ADF0C07C6C16AD3E33C17669D89F9A71A3509FFA37B6CC0AD35
FCFDDBF7B4B6C2BE6916DAEF42DFC17BD9B7A268F55CD5423525A001FB54EDD9
54F9BE5B55AB8B57D38DC282390E735CDB7DFD57D62B539058D8DE5177013854
B10911605F872456B8F504547C4DF6E51213AA578A8B93C301A831AE893172B7
D2FF278D43C8936798FCAF1AB4CFD1799A16772F79611D38C24A7926FE06BAD1
D0C5C99C055A806FFF66EC1EB8714CEFC0541775F3E95AB26CDE61584D893A76
D9EB194903938C94729CB9E84D2266FAACE4BB3840E3BDE865E870D277F8134D
0136CA2DECF9840A372BA2464D679D68EF064EDC33D02A73272C68BD620851BE
2D39031BCFA0821FED4A2A8D9F8B0FED7401DD3592E809E0C72380B92F4B946A
7BAF34835CAA5065C1D28020FABC322A2A3F6204A7CA8F0960FD914FD8135AA4
0B1CF72B5A6A05D4881BDD656E4685B48D97F2A305E1E746E300DED9480A2F33
5CD366CF8D6056DEAA6CBB827EB53BC050B841774BC20AAB178E02E300E93373
736FF863288F0868949FA05569543B6321AB4CB26AB0DF817C1A3EA9B869567B
7E0DACCD9E2A9550E29FF01BB0A1B8C24D888D0804B8B89D6D6CEB178B3F8495
9484D54B27BB44192EB27082DFC0776D805807EBBF02F2CF9AD1A901D6705C0B
2C6106EF8BA980E08EE723B2CDFA48158CBE7A5994B8325F6EE7D2BE04AC7A48
ED4FA1566B96E221864A45A24ADAEC63F61C9FD185D4C20421EED1BC8C0976DC
D965F5FC4EE010D6ED3ECE6B0C3749DFF3D8C391A5FDDF2318F6D505E8FA521F
198C7091334762A700EE46CCFF0F8222069A239E9C0909E46EF8DCA3B5F674D4
E56982E5A019D84A227270D13A1846A0FE7042B80B0E772F332A863DD328D3DD
0C22580E174B97F62FAC2F2E1F29EF28B4A46FAEFFCFBE7A8AC43C38B1FE6F1A
7578AACCE5E275E11BBA1D0821C1D2A931CFB25E01E9F870CA8523DCDF93D57C
E57C1759F13D30F78E4E2174E4CA868698A7B0FF83E348376C2350F6DC0DC9C6
175EF0A6F4686548EC650147C6C269FE166EBF43AC58E8CBBCE530216B73DB0F
2D11A1630CEF8BD89A23AEFAD8BBD5D9B2BF18926E27341D514047E4BFD2E4A1
337693FE4708FA07991672B29087B8E5E649DE6325EFABF76957159A569F6487
50A7517205267A07706EB227BF0F67F89142B092BA693B846A98835764526B94
316E56A74DE14A0E8AAD7163D6D9B7823BD15731D8957FD257110AB63FFE6F0B
4B9C5A23F47C251E79181FB8ABBCA1361CB866E9ADF70B084BE5D64C2DB00344
39773923F9359C0D04B4797AFE137A447C5F7933722109FAAD870D876C29A82A
FCCBC42B5BE2C472BA27CBFEE526B56D785F58224F5BBE4BE182B460E8A7AF8C
F5AEA8FBCD2DF1B82C283756413323BC8250901DC4D9EC5ABB03DE8C8CC5DEC2
EEF6DBD8A10153759083DBE7DA3D1B6C9861285B0A991473DD4675DD09176E33
197D2249DFCD81D293D49C951E502A5FBB0F1E007B9DD4C3B50D79A627751364
0C79C1B882CEDD8499934963675C8C5EF7C84D0A905C4D928B1E8244A0B928ED
A45D6888797D3D9E5680DC3B191C830FEBD83CDBCD9ED005AE85712935462458
A195C1C6932996FF244387D9FF439E661E1D477DDA05E88217F05442ADCBBEFD
D7E229CE73E5C2BCBAA1BFC2D1F1F9E426CE80BDF3155729BE54754A98794077
19203E805324D5A6D466ED58BA1164C0BB82449BF73838E4CC3B74E5D1731054
672123916E7F4DBA25D25B678A174833906466F75BFF9210310114A62509B2D2
860816D9A042C22E654FFF2A205E1506C0ED800A923FCBCC56D86EDC1B69BBA8
7EDCDFC2B69639F4584EE29FC639995D37D2A9565480FB3A5E4F56EE6EEF7FF4
766BFC55CF8F98A45AC5A7DC6E82FBA02755A97617A27763AE2285937BFA88D8
CB3C9A6F88048206EC5209787A812D4ADBBB61713294A95BC93A20CE8C7276C5
64DA61198CA1B21439891C51E10C8EA64022E98A9B07F27757905BDC1315A1BD
664CC6E28CA1CCE26388189C59CA365E776B2023BECE6E186FB530F6A4B3BE43
371A883DF60990A47DA26CBC12A55040C5EFC335A14DAF72F3BE1149D60D8675
FAF28683606BD300E773469597CE33A3262A7D0F54866F65B6007BF5DF4F199F
693BCB280A5F6CA11B1A4E451CC6A0980DC683B27DAC9F25FAEC6D856B9DFF07
994B5EA9D63C064A8F59E9E27ACDBD3E2F8E16A675208C0EC06ABFD66F866400
9E9FC384314FF4D2A39A92002F424E1AB2025907FD4CA03EE0DE438D6E18291C
8931A1B21D8B9CDDEA544B2CCC38ED182D5477854AF5BE604F9DC3BC96315576
2A1019410B17F7FD6A5BBF6942A19C0EF2D1B93779FA6FDE3A897F68EED03DE1
8F36583A6A299C9957256112AC09F8F4A97FA1753A38E763A9575FFA4CCB92B8
76306228ACFCBE80D55A5456E7C031DEACF35887DFF26B67DDD397FD8CAD6074
2CA01E87924902FD4AF67E7B088EFC553E406F1B9102BE13E3470B4B43338895
398F1A750AD253EC309A9684763553A32E576AFC2156E8B85343324DDA568317
CF3BA290B130FCCAD9F524CE6948952A9181C0F7323C3BE4F26E76B4EE4B09FF
03ED4A0372130A08A7EEEC8E07E15AB1498C997BCF2670E92B8F115A37492722
6A00668D99E924F427C392C4141FED7CC8B5F111F2446AEFBEBA905E27CB6E8D
FF9BDBEBFA94E1338F4B9505B4223878D9CBE56200918A3EE18F883DA491E12D
FF65F40CB7812C856620783169770B46C85E9BAE057D57223D690D0A6DB60BDC
237078D7D25F10A1B98870D3EDC82E0FD74493AAA01A87841CC828576D6922DC
B19AE1CFCC0C795E6D2E42E14434238526569C11F982C0F28FF93703D558AFD6
CF635E5E94F922CEF48AB9F91CAAF5C8DE727683B2E533B5EDCCDED1E007AAA8
D9E2C81A4E2EE599B0A8685649FF7412073D505A8D994D52CDC759F371FA1933
51E318C1F455574A72618DD10A605E081299D41BF844BC1D4222B49D1BB19B09
4FBFFCFF040B6086016FD6F64D3A4B1FC057F95ED56D249C58F34FBEFE9CB7B2
9611F900387A2B48D89514331668E174008508F178747F9C9188E778E693318D
50ECFA26A2E7FBC569B896DC91C5ADA72868C6629F4DABDA3B58F08527DA263E
F056A3AE8A70C0DEA685DAAB7083B3631F8BE0660CFD6AF6115FFBCA726811A8
807DCB4F78E6C6C5367488ECE43213A6509B2BF141F26019B9FBBE5908198CCE
2033A24D47BD9EFF82E2CB160E5105418BE08AA805AD2268CD1EE3B8C3232DE3
FE81511CD70D3C9A62BA3654E913F6B937E5C64C04C351D229B3BE5AFDD13E64
792121A2FDB207315D66F04B5A48DEC4DEF1F040D3A96B7F8D8A55E396EDE950
94E570C27279C6D67E4DAE7303CED73CFF0DC7B36F3DB54502403D4B2B256BEF
61AE92D1CDE11558D63EA03F8DDE9597AC62CE15E6337C10744B64E6F8AB2C95
58535A453AF9980E00986C0E6C81C0B2152F293059083F5E07E64B3D40150259
7B7BE2341B20A7622DEA1051877BD1EE6DFA7DE36BD013A05DB4B6B835D8EF0E
05B217C73BADE6CD63CBB80D2B6DC412737548840FA081D5C71280D0A810661D
EC73D3C821B60542A392A103708AD337AA839CEF48A74F5ED14B7907B0873B3B
511D14308614E94537107A578E1F7322697C4449C8B9970B4B21B05689B8FFE7
35F98FE01BB444E9CC4578239F35C4B188CD43DBEB4E959FB03E29BC61AFE348
1F152163FFDD0EAFC0A3C6E0901F595D24957AE2EC9F56C76448613D79ACB706
C80D7BAA339BD7741516235EC8854ECA13A575299951F28D09C98CD651F70E7F
578FDAE49D71676C774752AFB72B1692BC739BCCEE66C9A4EA0353D265FA4235
EE05DCAE9C804758344AFFCE43F339E602677B33850ECF26400BDBF55C24B154
B2636ACE2A815583D69A74C51A61BD4480104F1EA6E12DBBFE99EAA634A3CBB5
4553837990B26FDB0FBE006653DDC21106CADC3586EED0E6BCDBAF06474D54BC
5AB73FE436A9B31EC7C2C99EDCDB9D1B24B713135E3600CD8EA8281F4DDF3DC7
2AED4901F05006B3F502342CAC4DE4F7174983F69068754AEF2FDF2F0F6174BE
D2CAA64BFA7CE2818900558751514C149FB1DFB1F245E01C1F3662CE1B2A9269
697EEB217F76DAB861076E5F8F90A8FC8926B81318E6E5FCA3C6AD820A3119A0
FD342C527F4E4A40E2B18DE8C089E519B9B0A295A802B68AF5A812088DF05E50
F1EFEA39797AA4533F2C568354A271240C3365E55B718685506393EE180B5BF2
B160C45EDDD3F0B813514AA8D41F670B8077174826D2DBA06CB803B0087B3FBA
8F681690130B6DFA58332425D2E905F53E96F885ACD311E1BA537E5A9EA17B28
D8FF4CAB442681D7F69202973DBD13643AC5AC7708061FAC0F2172F372468F7F
AE5A3E6B4419EEB4CB92567EF71FA5A5BBB38F2C605B41E1ACA139EB35D62DC0
25C192A69C5B682B8A3C5C5A42984BEA7F2125351A73F35B07DD33F99F358C92
D979591967E0E2D2C8C9A91FA0FA78455C4D11753CE4F22396849626DC4E1975
BBF33EE4EE736CF5114BA81CEB92E1FEB1DE8F48A4AEFC51C5D107F9C9049635
225176F2B0607239FB3742E65D619F40AF357F656015BC4C7A1F5D08A9FF1AFD
2EEF1C5DFE73366AA4D5ED8F37426829BD0DB55E27BD27F4B43B6CFE3E9CD9F0
4B09CA0F71CD9991C114AC1BEDB82D77DE550BD7EF071525CDB9384984A8BC5A
282210DB7BF404C557D3B9C359D18509C8D828CA43B4799FF99F40FA3D314252
283FDCF302BA3CA1DAB0D113715B31A7BD97EC3BAEAFC672E4EB35C55A3D4EED
AE6D1E3BE5A20E529177163C33EE8656F9986896ADDF8FD59E68B8B7BC7ACBF7
1A408DCA2BAE1DD8C7B82A1E02303CBE2FD37A7B53ABA05461DA405F5C41AE53
A2DED477860B4F3BA3A10761C825D41C018DBD5EDAF9FDC50005002C4E3FBAD8
21FDD4A22FA05905E3D70A1C798D2EE9CDE58E0E579969B57426E9BEC13B432A
098F429F38DE0A55323B41BA219F1B516BF85E792E23E838BF2D37C6E7AFC86D
A6509788063A29D710BAA5288840F8D2AEC8131935ABF25746A803DA854628B8
2D4040FF0951C9BBA124D681CA43739E7D9D35F4ECEADBECACC31177F8624A7E
C5FC6251855A3BE8F15DAE7EE02D012E0ECA690B6BC7DD4387A6947570AF45DA
62F818E79CF1AD9AFB4D79353FD09EFCF3F77C0BE31B7F84ABD1880C22E2280F
9A33BD4976A5F961E27BE80EF739F5C23423A446102F8BA6B750740CD392DAA1
C9B8DF572D19CA8FE0FC8C0EB0445B1B23250389EDAEA13EA120359B6B3C9B82
1E51BE6CA44E5F6ADBDE5E08BC5A4769AA23C32AE881E622E2BF1D39389E2EE7
9138D5B9FDD485F3E608EA7C724E03C5E12276D40EB58D2226E4397B02D2EACB
99E585ACC3A81C2CF7AEDFEC8A0CF8EC691A29BA3CE4454C71933C90CF92BAC0
E32D6EA9AC0B71D0E9DB461E24D7E93AD86945E4B30C97F07D3E8BA847D01512
CFD3B552669EE205E9244542BFD2849D4946D7E7ECDA13AE1F8C393EA367109F
4676A791518DFDFF3D665DA5F701E405BA47E0B895195C457A49B874A3194640
B31DC07E07E3697150592ADB01BF6DD12800CD2653B292297138AA0783F1FAF7
92F2F23F08BA6AC9D3434EEA3110F7F8FCAD7A3CF8BF1ADF91721EF6277730FB
F9E573DE64F28EACA681A5F32B3D9E818395ED245EF08568EC46F15E5D12C278
4FD92308FB84B1D8A3681A84D170419BD7F9B8947889E6697C12879DC56F11F2
5BA7BF9384C6F52F59AE85E5CE593D4FFC686AA2C59D0971465F3061C1B05C60
E6E9544A09BA5D70BE0296E5FBAB122A404FE26CA07A7ED5DF0E85AD65FB2CFD
2CB8F113142F8AFD7990B90C3AC9AD11247CDDF66B3CE0F76E1C488BEA1945DC
4FB43F96D68D60B653A429F54B372902B1EB009168D7F8CAB36440B88AB40302
B100A494696753F0EEF915302A77B8C0E1F42483FD08FBB92ACCEF289AAA827C
7D974D1D20D0D4385F17DF7966736CBB6D55A8A00752669D7CAD40CAFA44A56F
838A0E5172B70C4F2AB9CC0601EA3746B867B2416D180F297868304DDA36015C
0FF38DE0004526C82E1168602BAA0F9DE7FC30F59FEF09BBBC6D35014DC7DCEB
4DDDFF03F3FB0DA841ABAEFA75FCC28310736042CFBFB809BFFC55B62775D9B5
53BB28DBF2D3D90393A6E1CF51D47D2733C2BCF711FD4F80AD0BB6489007C555
A6A08BD5CCC697D880AA8BAB7AD42D7096A78A89546E106C0DD059D0606803F8
7CA72C388EF7E850A6ADB3D92B5F90B32CCBD0754AADC263D4159B9E4BC6EACA
9C39EC867A170854167866C95FD6260AE7C12B89C7B42F0C8623C726F725E008
F9F8AA1FDF092C2E4A29FAD002A25C69667393F9C76DCABD2E17EA9C37F5DBE4
3F8CEA154E5BF453E30947DB24A2D7DAB6E17428737BE681B48C44CBBB25AAC5
D7A47EC1388863C20BACA47E7A602956F450D039C17151E5D4616F49B991C6F9
26219363A5FB6D86720D15CFC176D8B7726B7AEEB999616AB2F5B77D1C96C1B0
C02EFCBED5C252A3875D28C3E93786327639EA2F37F7993734D21B347C3EAC97
E924C96BD8560F9F2A4D5DBA37CA3E8C0836D66BF74F7C5358BF0C5F46D448DE
A3A13EB417859A338B4394A337B26A33635F3E3F35ADB452666DC5D01766D012
6713294E1357D4F5D1A888BDB454BD36B57C53A57041E20F6B0EF5F40943D368
1F9DCB79A8D94FBE22F27011F5D672E9A2FB9F6F437AD7A240283A073BBA07EA
5C21D6858952B43CB6CD2C8FBBE9DEF284C4A5866B4995AC5C0F3A898D1E2F46
6B1F2329D42C8BD81ABA7CCE0947B11CA2B164491F9BD7F6732B6CF0BA5DCADB
3A867097411B58F11487FC25FBD05765155CDD382944EFE3B940E92135B392A4
E18DE998C0857CED4CFACA96AE3BA35BF86F69024DE2BD8AC38BFD127A25FBE0
096EF1F6D16D26D918CC6F3EED11C068E3994970324F9F9616D7564B96585085
17582B10BCD1DCFF81D1C66D291A7CF13ED5DC34C11118481154D16BA484AF00
83A18A0AB2905B98FA6D3E52937E2344F58E976878EEBB4AAFDF19BEA892D9D3
C0D3B4D8E8455CC181C6A1E7FCF0E62DA82E23B1F3C26A28DDE7F3D52A9BF57D
4634F96E280B5658FF8186853F9ACE7B079E554FEF6B423A8D8C2BB93CEECA12
BD18993CB84566F1E32B977700AD43E07491508E28EE4568EA63F0D1AC4623DB
C5677442559503A7C7890BC618561CA2BE870CB504E918E794F520930AC0403F
858582A7547BF5C6209178368D499ADF9356A2BE4D7F05EAABA3AE1D92790E1F
6B8B203FE7D637C3F081F0E15D5D26C5255B262BFADE8570DE99269EC3BC8D73
075B7C6F34C1316E230E9B2ED0EE90ACB6B6CC8A63C5ED3EE94F972B1F13DC27
AF0A57947DFC03AB4A2DB0B9136B63879B0093DFACE1BFA8DA0E678AAE28017A
5A32FCFB655C6EE6D76CA3200DAAF03F59E451315224159FE6377B2BA5CC608B
5303CAD13D5B8D423B09E43B810EFC21FF23EBFF5E6194D56A367137318B7282
0B87987C27CE24ED6438F2103FEC32DA6EE86EEFF37DFA9DEDF4E5683FAB7716
2D840B2CC547632CAA610E5CD3035E05ED2B02FAED30BF20BDB6164D9810B7F0
F1465CE43EB8DABC01A1740E4D5ED50839E75A8B1504CDA739A51DF52B098251
1B8EBFF693FEE9FBD41EF42303654E4216359C6637F6F9AA0169A779CA3ED6AD
9145FF295A86066F5743CF829742AB921F7F37EDC9C9471A82F996F7002458D6
C1361E815EBFDF75768512C9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: wasy8
%!PS-AdobeFont-1.0: wasy8 1.0
%%CreationDate: Sat Jul 18 14:19:02 1998
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (1.0) readonly def
/Notice (Copyright 1998 Taco Hoekwater) readonly def
/FullName (wasy8) readonly def
/FamilyName (wasy8) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Medium) readonly def
end readonly def
/FontName /wasy8 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 52 /XBox put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox {-23 -1667 1827 938} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA3140A8A4C99ADB
B3214E61CB091BB87421CEF35FF5745EF8DDC51293183D75AE11F26462B918E3
F15A016BF051C59D797E59AC042DB329D8738C9DF453DD062F0BA8A59E23E500
D03758832A6150BF51F1096E643C98DA553929EDAC78FE0F28B0D59B9D567F99
6C27607811761DCA1B0F378580043FCB1226121A1C268C9137BB9D807A7390F1
E9E22AD85FDADDB0F2A8E24EC39BCFAA063EEA79AF1FEEED770669412AD541FF
7545CB7E92ED4E00A6A29315ABF17ED9EA3F5EEE2B8A82791A6117E97E4D8CE0
514DDA999D980177455008706D9845F13F675EA952D79969B2972F7C7CD715C2
25BF576C035C2FB946A8D80A716DA8E79881D4637DDD27CE4D1FD60CB8788158
7D58DA3798C3DB10B26B2BF8DCD585F7F041C77361114163A71C018EF48CB33E
CEDB5105F3955582EC9E1BEF6C039B196FB4C47688D043D418E7A4B864AE025A
6A586237AF8E40C1C72984C41BCBA21B393E64D58764E8D44DC578BE2402D13F
C5372E05DA06AE1AA476FB55E9F7BF83E99DB42CCA5B74BADF60C651D3B263A0
12D74D2467062820066322DB73AC9C7591840CBF18DC1792626C15A27A6F8A6F
BD7232C8AB7F1222A31D5388565BC11F6E01B51FB0737D6910C3613A8B124557
E96288F5B63099A987EA201DC2DCF75D442F72C993DA0A3BC0DA437CE1F86DE9
6FB31974380AC4D4FFFFB5AEFE99D94C6F68B7A84AA40E2BB1322708230ABBB2
F116AD79E9D6617F5E3A3DBEA424950B0BE06333BE2F1A70A0ED368F51CFF3F2
C9D8AFC60C3F8C2AEF4307114EC5D35CDFA5362EB3212A067140C2787F6B8A1A
425642693EE8FF88E184706CC412DB867CF0D3C1F08ED3EAF9C195C3CE023098
9BE928402345A1592DE02C3E99357EFD3BCD4045EF68A6F45AEB7201BB489E25
74C98CA34E8ADA7B6259B256CD1A08F62A42885EE4C7FF49F8DD75763856D853
E62D1A74313C4E0BBB37AB099844282972DDAB92CD10C20BE3CF33BD334AEBE7
C88B9B222D0C72AE259AD5D13B6537F6A331D2CF65607995D16A646A3A793210
4CA014DA5B42BF7D6C58D4ED41AB0EDD8B76A546ABB0D3AA9192FD9AE8CDEF46
84D0D53CD82F0E2D841594C73154D35FBCC705E5D05CE7012A34035C81296EE1
77A97F5C501CC79CE1B5C172F63A71685BB826CF43D1C7B3A8552FA51042A0D8
11AD951842B853F2C672BE5BAFAC181F9D4C4C45471B799A3C40238CBAAFEB46
943745E17B42D29A9E0ABF1C9DA42F1C7F164F6A6CBC6881004AF6DAF04C8B31
EA5B6340C28EEF89CDA1EA573931825515012488C0FD8184F26046AF3C45F562
793DF174B8D950FA17F0084AF627230CA69D041FB245AD518C46EF6D1C6FABE8
385CBF970AD152B3F5E2E085351ADFCF60682345218941B862F938FB4ECF951D
9D3342626EF804839C157B49828A4D36331E001EBCB5E1FBE72A621FB73F513F
C0318C644E413964D9007F3AAB1E6EB1670FF6A78E3D14194DFD29EBC4D4EDB1
068DBC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: LMMathSymbols6-Regular
%!PS-AdobeFont-1.0: LMMathSymbols6-Regular 1.200
%%CreationDate: 16th September 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 417 117 0
%%EndComments
FontDirectory/LMMathSymbols6-Regular known{/LMMathSymbols6-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.003)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMathSymbols6-Regular)readonly def
/FamilyName(LMMathSymbols6)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle -14.0362 def
/UnderlinePosition -88 def
/UnderlineThickness 31 def
end readonly def
/FontName /LMMathSymbols6-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-4 -948 1329 786}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105BFA1C4BAA966BE78FD2F618C28B35E2A9ABAF
CFC1090C3FB0905252C41AAED38054D177019225F56A500BE560889E991201E0
4F9B605C0D22769EDC54E591E36E37E5FDE707BD42C0C024454DA2F639F72A9A
562B5C1D32C6F47FC06B117D908616531A8379DCE1701F7F184859612D9F84F9
0EE31AEF799812A99147A8CD30D5F8F8F1E34D6494BB6367FA2B172011486EF5
844F5B89DBD01F38E82689CB16E2BB46A5E39043E718382C77B554CE0F5BDA45
B555F543B5A4669091DF58B79AB8A54B63C4D96C02C4B32021405D3A086D8A06
2E73A4A478789C6E51C058FDFA980ECB2F964EA385ACFC9A15416BFD38DD998D
35255414BABB9C6DD923B8E866EB22731B625EB76647E680B79EDD64B5B6D9B0
ADE8F024B2CE77FE9D87C1A1286ED288D3FC51CED96F6009F87E505A8B9D4288
4AB9134B8325BEF5BF60359BD06C20186FA72EED84622454B0848BB74A51C541
E9F8468308E20E4D41FE78074ABBEFB80E7B5B58641F660CCEFE5A36C7E1DCC2
862B5005575BF1D4A7845F976D9A52A7E2A33558953A65CEB6601B904A42E75B
92CF31D9B57842CA62CC666700C974D6C7B88C4E3D1A1B143DAE1E2DDF725758
E2E6EB357406DF364D2720E373DCE143CAD7FEC1812EEDFFDEAE20D75039850B
0314C68931A618291AD30A299FFD982858215E9CB25FFE9A6A805EFEE2B01B62
8A682DB0C011615552F03DB40513901CE59ACCFD6C2D6F05E2B6C8AAC7EE97D8
80BE1AF192DE2AD3600CFE96D7F2280FF1D7AB28635B3FFE975FDC6329DEC300
1F56A4424DEA4A64D855B319ABD08B73E84F536BD6331778706987D7AB15DD1A
4BD7C272B4A0B383C6A680B6AB91AF0A3442AA8D1F163221902D87F9923FA77E
3346F09DE23C25D4CA5909B956FA16229BCBC3FF36EF6933F33D529CF2847EA6
D3A482CAA539ACAAEDB0299025B307CA410FBA6D82B4733763DA07D521E34DD1
6523917F436B78AD360BAABDF2CD7016886C28EF390A51085691FFA140FCC6C5
1D7EA07BE7F71EAF563D92056FD6F12A603AA2DF6708C73D283DDD92B043ABBF
3DD2E24A4D5FF0DD4EB111616C102637EB49E17B440AC54D21DFB7B2411B2B72
CF35172ED4505DD175A836C0B599415C638471E3F0B4BC30296704D41973F487
D4C1B50A848F2E8C0A77E7FC13B044E5D336C31BA0F189C36F9D48CABEB786FE
A0EA4CF0DD9598A9036B749049229902B646FE10BF4DAA942280A326B0C4356B
774DAE57D20990968A49116A09BB7F320F0CCD98F2F7DF378E1BABBCA65215C9
F425C048AEC1C929FDAB375F3B47EC3157488ECF3EF7B3069EF25ECDCE357DC6
CBCC1EE0BC7AC38FBA8107608BAFC9DB86B570FDE7E6248B6EDB4ED358D5C45A
FF2A3ADDB1E2963200F24C20A0D1CA998BD258D1C694069BBD9DD80466FEF509
9993B56E1544A2EE08946129664626F0AF9F7E546F6AFE62DBE7DDD5D3DC32A3
7C5BD00DD016072EEEA098A86BA7B6AC9F23CF55920502D0BC7EFBD5CB140E02
C5A8CC261C06A7EF3CAD09AD5ADE65A51B6A915CA708D66C339EACCC45B962A6
7731C76AC98678B54E6E3A103D82F070F486122EE08A4870456161458B6C93A1
602C336D492C4F6A7635B85ECF70EF5733EDB26731D14B304EBAF0638AC6F539
C21436A7D25573FF22A0D0A0D452A23F35B688B79D566F17691C3E15ADAE0B32
D5928724D303A23819484A60305B58B88920CEA06984C65370B5ED6B7F0EC00A
2490B48D7DEE3A263A115E406B099A5C0DA4AC9330C8D7F16CE4984E6275F5AA
9CE24EC3FF0F73FD02F87E46D24B219615F18E14B859C6575A1DD4505E724878
ABF0737B3A85443D4B789F3B597D73F0EE3CE0469FFEF6D1B30F39EAA11AA1CF
377954565246A2E3AB856FCD5FA8E842B5AFFA3E9950914CB0BBD8611E13DA3E
0491B4E1D68DE7625CFCE4E36881BB97F5A457F4F375D06880C6C48230A3E758
B4BB242BE4A92F1DBF1B1B46D0DB96EA0E2CB4EC84E971C63DD7D3979B27F1E2
EACE8AB6F7711E304156DA600850D80F1FE82AECA1283FAA11C15B198E01285B
FE86627822131E018AE35D62737A27BF81BBDD5DB49847A8A817CEC721B88231
B5BAD34B641CA1AD8E39D009C74E0A0AFB46578E15AF5E
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman6-Regular
%!PS-AdobeFont-1.0: LMRoman6-Regular 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman6-Regular known{/LMRoman6-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman6-Regular)readonly def
/FamilyName(LMRoman6)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -88 def
/UnderlineThickness 31 def
end readonly def
/FontName /LMRoman6-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-515 -298 1647 1125}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E7AC5E68123F9DFAD1150FFE135989C22B412B
63BEC913DA6144549F051416C71903E13237781A5DD70E8333F80D9F0E493687
94A83B2F049E14761EFE435983C72A913217C8946E4DEB22A9DB2FD68B53B9B4
02761774E0E713EB4A4FC9C587A325C91693ADBC62DF65291D5EB7BD830949C3
35DF08289D902F15122C50260EEE2B47E043ACF386043BC0B77B47F761487099
F3EE8B97E5F18DCAE51B94317C8F4DECC130CEC55EE16A19C81D4D1668127C7B
86C63787AA273CDA19F2DCE459A6BDCED90E3C60B9F7DA6A0715D2D12F8B805A
5203A948442C2E5796D5CD20544385DB0893AB62040E1E7F33167592F1944E2A
AF140EB52E80AC868A5E53B529B98C77E46244F0B9D46A2FBA3E0040CF5A1D5B
8CF20FDE7C876B9AF4A5F6798ED83E56E985DC30EE5A3B2D5EA30F640DA2DB67
1783F69DA070954570F579C316046D8A6B7EEEBAC73F338A8B7D40470B4468D8
CD9BA8B731E8581C69A41FE873D6ECF58F4962AB44706743806BDB909276EE0E
99E10A530147C9C14638387F89B169CCEA629DE9AEBC010589EE04588A992E08
30B37AB3DF923029B8F6BF19C1C728797AEB5C0F2044753BA4C7D1437E2B9B1B
3DAE6A15672EF1F238D1AB8F873DBF5264D704FB19F5C1CFA0E5168002B3741F
0134E79412F5B0AFABBF3069460C10225E6F7BADE64F07074C9D594F6F7514CA
5B8A7750FAF214600FB248AD5E8D9FF734EE44CA79A585268A06C6FD4E294257
0F814FAE80C1A7776ACFE85D3159ED173F8C4EF0456171564E9A2E1C26464408
16B747D137D37316A340FB72BC005029A06DF8BA48E9AACDF832BA2745C448E7
9225CE3A522B46E18F5733663105D638E571758C9E8D9121EE819E4A12676318
11F0C568B81E1502A5D168139F197F7A71FE60CCB05063C6D9D8A0048E60F9C9
5CFFF69AFB554B3534796218449D2BB97FE15BD1A6FF104BF67F8EBA5C3C39B0
24ADAC78AC4FF61D5847F0A11065111310A46FCBB19212E33F0B75634F4B5550
DCA5BA87E18E4F07B5CFD4BAB729CB705A53CE0E0336424602EA4A3032DED7AA
13FDD13235C6514EEA804EE4C5F3035A6AEE4391BF9839800B20C7E958E4B42A
1EB67E90C22A997075D4F197AF8485F01346CB8E17CD12A285205B2D5D6FBC1E
930909D9A6A38BB39CA02AB2598B2EBB03A60FDB795A3BFDCC677895D8CDFC66
887FF3C563185662EEE213EC8671211F7317D00BE0D30EB7BD4463F7A542C9A7
373C3A40BE476AFB688358F195BDCDEBAB71622D0A07E8894B416C8D24FC15F4
5E5961D4C11AD4C569CB28F6C6D112762B8527CBE3381953B0908617A28D2D6E
AA59BD102BAAFEAF854C1B48B036052A3D727C0508062BAC23C2866945E46981
F9406B6E4F61160966AA3922C4B0B6ECD515EC314C7493E8924708EFB767FCBC
B0F795CC6D377F09A17FB2C3F45B2E98C37EC1F64848F36CF72B5D3FD84E73F2
2023C63FEF39B8BA4CBB8D50429B985F23EBA0C907B6CCB4A57AC0CEA9F70D95
2224811BCECEB52C86E3666430E4FEC39C474463806CE627529201F1A70ED484
FE92F0C684F4A045E61AD94FCD6D373246804BA5F2171C5C56B6562A13A43B92
A806EB2F90AB0BE445530439E0E8AE43B439654E6175E9B3AF676603DD8C5F5B
037022B38CB7DEAAB749F802FECA58D6E39A107ECE8A3EBE7E645FC1DA735CF0
9EBF4678CFABD1A6D3FBBF8357D4DC0527C2DF2E6C382CF8541FF7E243AA7F16
F534CB8E4EEC56359CF1068CEE7B5E2928E43D4A764EF76A128CDB6111E10967
09BDB6D8C9510DBF277B31B8BF2B86755746BDF7C38D8480A71A9FCF98F4F950
1DCF69FCD870565A7154A43D5879042740352282BB0DFB808522CB0CB8C0D4B6
4A6799C8449E97E13CA0AAAB196E8A40446C77F005D897D944251600E7A6B304
DD76E08FB03B942847FDE355DB3C39956F9F914DBE112C8394C82D57D654286D
5C2C2D8E6A24B34217D101BAA3037C63ACE221E3BBF2A45CE39B80FB268D543A
28FD409DB32F938FC52C0AEA6475261702FAA0ED37FED6546463AD649C32D00F
99B504DD1602FBCC202CC8046BB4EF5E5E1F853052970408E1B96714C7B1D4F8
06F88EFB99AF0D7FA4DA1316C3C5279767142D132F62EB21701C915003C885E5
77E9097CE4186BE217A2F3DD498FD152C0CFD0662D318787C108CF6922C96AD6
D8D0C2052FF4A76D691AAD97701382DAF90A28C0896AC2934C35E15760990827
01FCE199811DD294CC46CF1F0662D1D1E9C9DF1DA7866A772E358CDEA9FBA4EA
2EC4425B0A4947CE3C4A3EE986616449FE094A5F910C93A5B74FF64283F15EAA
51DF4C74CBB662283EA4ACAC860B567466240E3A598E0D31B4BBA740CAD470D8
BAD77608136DE5C61CE6B1953A900D0847C53F2A87B3226F5E1F4560A4C061DD
345142D8F2F4A85CD7DB687B5D2BFCE80CD03235A95EDDB64BE30EECBFC6618D
90A399CBD792FE3855F316DC33187662B519FC5AB1FFFE0A6A33736CA5A0A7A7
5023BD9BFDD0C94753098D5FD28E46480B0DD99F4679772820B94DC7F8D4C2B5
A8BD9D9858193BC1069471D0CA4DC7AA32B72C9C581634E789A5C10BC1E93488
DCC273143E753907B15EE37DC5F4533724D785C22C645809C6B3B4B8C9830049
95898EFFC985D007AE44672530620E26E88BC793DA7E638388619EBAB9C62CB5
1FA723C5F22F5BE5873D64C726C983B33756ACF3FE3AD85C6A571F2C32DB6208
081585CD9A312B09793B1C1FA056374433EA2FE095D4A9761F4DCF1E7FD3ED38
0701745BE983D2F572BB56C524FEC5C3D513E8B9306CB9F10D1D8371169DD47A
3437A02EF556D9F32B061E78C54C768A72D9586113BBDECEDB4192AE9991497A
922907E2AA79A60717C38B23D7CA54BD43619A46D5FEFDD4D548F4A1B5C4BF78
895E49CC6FF69C287D243D182304EA766957C4B309FA76BC36084200592A259B
C950CFC7BBCE0055AF1446D3C9A163230C5D3A4A94455AE704A09A3F3D68C52B
226196F0E466DB8BE5C0AEEC0B983770CFA038C3DB87BE396947FBE8692B77E9
A6F66A56FB00A1B25F2BC121CF9F4F5687CE3FBE729922F42CD1C5811F86578F
44E5BEB7F997758232B7EFE394F5265392E03264AE22D81E75A04AE68344A9F1
51D5B3EC66EF1D37916398FB8CE955E12D8A89ADEB15FE0B39F2C388F118806F
AEF0361E5A30DA786E599B3930697B0E81958D7D8343C840CD6FD8CD9CF8AEEB
9B406B7A6D96510D772EB2BED726D5F12B4487AF4052AC962A19C387672A4D10
1E1BFB07CFF9F577580D64EAB72407B03DB1D677859BE22829180DC4FEE2F095
7F061B9FA20CF2EFB32200703EF58C425B9A7D211E88884D5B37EDC8DEF2EACD
9C3985BA9ACAC69EE37073ED2DFE552E96EAE73E7AD80E3341EF23D94DC5831D
1F7D822A57E0BA52FD6822344E2682F728CC93F7D0064EBFC23908C4EE8655E1
2DCA4E6B66BCB8909CF259E0895B44F511485B30A84709054F39D5251DD66298
0C233DFE8180D5919A15A56721FD7F5958D74150BAEEAB1893860BC643B4EEC0
2BF0E32A9F6594912546C8A4CE88818DBDE72D030D8E884D315F565E0C09604A
B40535E4200380CBDCA96015D3822CF62D8638273210E607B04566B99B40DA40
C25FA70652FEEFF9EB42A6F3428012077754BA3854A60A3676CE51E886412ABE
0FE0C8BA6B1417DDA84325C4BD172D16BCEB6E8C68859734B232A7C0ECFF1216
CF4C91084EA3061F27D2DA45CB5AEEB66CE99FBBD9293D62238210495850B3DB
D091C7D41B7859835D08CF0AE8B3365F26E55FDB1971BDE1A6280F1008E54F55
752CF018AD094D307B9A074DA1502ED05F04969D83194164C4017EAD6A5C182C
775FD8878D39F160B10D4F5E8E6701489F6F6D62C193EC19D9F43166F2C6B96F
17F4B043CEDA94C0C249064433891612C1FDC768618BA9BBCEF70C3E4AC1421F
96840C16E9C37DB87690A759E2AD1988E6DE4164A97731F59B6017188D449C86
7D7B28DDADBD3BA6BCFBFEBD5D3333E32FD2DC6FCFD5299FFAB326C11D46982B
C42D9DC23475C397D456E05B2BE7BE4E2B4ED126A95DBB4FA2D09EF80D1F2C50
7DF980D3D8330D8677C2F7E4E231A76E88F3034C88DF0082E6A8C8664FB05CAC
F3296865532E0597C8B7410E7E4445AF03A4119AD06FAE9113F3D8561BA38C75
DAB52F0F1124DC2A2A6F8F48D39838647F35B6059CF7286586D1DE7A371B52AD
3B0B79A7504BBF5BA6C59C6BE0B2BF3FBC775A2838FFEB314527A827D08C98A3
F490025B20ABE6A0B0C94EC561A12D2BEBB44A71F76248841DE5394BBBFE694B
826E4B63F8E9BA65BF43438EF9F52AF893BBDA215450F629A3FBA5BF5B3FD77A
408B81624F74248314A08E4B0F4F814B77D3B6731568486D5A0CD6BB35654451
0E702D3E2A6C4884C57CECE0AB1CC156049E60651AE837C675FBD42AEA82D51B
F9669126F15AAEB8C958779284EACC28BE483D01113B2BD7AD8D322D32EEDA3D
FF2E9C94884FBB23B636DEC931E87F4BF5F39840266A3ECAF618C664A5EB0BB4
F2C8AE029BD1172B430088B5786E7917F1B1DF019A4CA177E48365DFDCC4167E
ADCF5EA73CCCD0CF4ABE809375826B436E6034030E5BC5ECBFE09EF40CEAFFBC
E1DE0C0838B32FB1886BF564BDD888F39086B32E3630FC1D9B1FFB3BFFAA6D0A
20C0381ADF48E4DD41814E1FF110E5BA8697379A27707AB74F4D4C6C11B10DEC
9B4A0988E4AAE449964323B79BADE117A3CE6890E467EE46E0FA73157A7D2B86
A0885D0DE7B71FA9805D4EC1A3099AF1EAB3652298E6F6E87978C4908A372193
E93E81846A8D10F604E10AD60B635D2F72CDB12CB642A9F47D149B38A0D7E4E4
342CFDD22C780278D973CAFEF06EE979AC3BC155D6E552A5E95D70A7F43A0B52
F2C7FB2E881F5CBA918F299A849F5ED006AA52A23114FFDDFB324CA6EEEEE7B4
FA88BA66620BB08F65A08BF76AE39757CE99343D1361997B367E27EB09E48873
CF9998177F234D7EE7AF00BC8DA24B5DBA872B606D8DEC5A93CB49DAFF8E6C6A
79D4E8BFF1463DDD942178D252686D67B7521787F7A76DD68F7E5D640C87FFA0
5C0EA432E2C0EABB97C7BEA795B1279647B812D8AB3D92BA5A04E4B6FC5B2A51
660FFA663695FB3C03D7569D309DE3ABD980F141FAB4B93F604A39107E9AB6EF
C28D52BAE71F989F94030793B4EC86011CB0106EC22428ADA49CAFD61F4409E8
7DF7760C0B265E69091135318B5BAE543C44C891BBF9535C4BB445FEFEBB1E57
52CBC7539470C7635808B89A8D93E92CCC167DB36D72585E112E6E8CBD8C8650
45F89776F20005556CEDC68FC47660EC9C8A4F0EEDE91B46FCE4E987E770A4A7
512B5276E36EC3072C6DC05BCF084BB1D69B96D07F2D617ED8BE90E81563C7BD
4421D692373E4B88789736CFBAF1AC7F16BB81496BCCDEA1DC382BF19D25C9A8
35EAE764DBD502ECCA2D785E1DF31C57E6DF36D3705E771E93F9232FEB35A8AC
6CC6CD83F69020F0544340C3B4C147A3CA6B939B4B19E81AB221062ED2B94AC8
4E717DC7612D6EC842A956F9884A42FA980ABA46C8E1E8D30561EE8D84857517
A5F51E22F4C9F772A253B6B477C24A622E3473E11CC603E82A0A16BBD8118221
9104B22197EA041EB4BD5601CEB6D079BE849706B6D6E9979556CFD400721EAC
67C16221ECCD01B42D1E2074B7116C3845EEA16B5282A7375B3C445C6717DAEF
0C8CD4A01F63B6B2C6B6FCB93802D72D75FDCBE79016475ADF2D88CB239FE337
3A015B5CA29A7E732AED78660C06E7682033B4376512D85F65AD30E430DCA0C3
F11259C4DE58DBD2DFDCFC03E61F0DEF4EF5FB31615490810F7246F2DD3777FA
4061CFF9D9C1A82925C7E423D726925DBC56B562DB11A93A95D033B6AA4DB98B
AF2D3F1513A14DE29AADF0AC9F4B4CC126DF2779061011FD20756524C0FABD33
553FA71C10A239CCBD5711618A67F278E92560FB682B0123147E9E8CD09DAFD0
54A06352C2351E58BC51E25FDEDE60F0532E3B730962F63C882F2CA3CFB976C9
151056EACA79E2258D77C26407681064F7DAD1AAC6417E96A34888EB46F1175A
19233DAE11D97999EB8C40288B69A9E79012C9C5064D6804B4B23917BCF4DA73
458BDA9F31F188D5BDBEAF62F00E36C57354A0EC173B6288428B7A4C806115E2
7EF216FCEC8EEF0C9BDF30E5C68667C0DDA575B44F8CE8CB67BC77FF01E0A063
314391267AFF415923F7250C5BF3BE382D95FC397999058C8B8EFBA9F66BBECE
A13733037B3072C48C217BBE240E9B8AE837B7DDE8993804A527FA18E5C77323
118C49109DC23451027036DEF9E8780305ACEAABA7DB4A724BD33EF52F6EB045
6379A5018902545D6704F828DF84705383D05EA02D410DA660EE50583BE34AA6
7E93065013D121FE71C19584777E6CA510A921B50D54C9FB6A2C529DA22A5A9F
0AF66B44344F1DF681219626CB0170FBD49CADFF1DC7AD838B897AD728B35D86
9CF783096159281B91BAB816434577E380D4407D0BE8775E1C7EEEBB97C7BEA7
95B1279647B812D8AB3D92BA5A04E4BD5F3B7251C5F475F0C42E877B96009E06
5BF3653115BAD639BF6423C688F32BFA5256F93585A43DFF3C1448399CC24795
854136B0ED501CEA8E19CBBF7C91D74BF983075C6247166107D6C1A4FAF9AE46
BCF6A6475B419257CF60B459D25F8802020152E5FE51543C5E421C449E9810C4
16D00ACCB2883C2384CE146E963EE5EB69F69BAD1ADFED677569C646EA23E316
AEE1EC29BA8D4A7B96436401A7BCF422C9A4A46BCB3A9089D8B41B2CB300792B
CE376A9F2841845CB62FDF58F84CEF83450F3CF968A1908A2AF0E1ED9254513D
2002A9CCD73361CC952A8733A8EB8CAC3B04F079E4557AEA1F9C18CF250FC519
5CA1CB3C00B458426157AE838C755ADA472EC3CD85FFE719FA2B2DD4E4EB5D8B
7370D2FFAAB5BA1013209625EFC456EC20A9D8AED089AF77F0C5D896228A3AF8
A9632F542BB60D4FEADC846E80E90B0115532DBE216FF5DF7CAE476FB4F4C2EB
EAE439306822F44A5CACB22DCA7BFCDEEDF9E90B484FC8C8D637F6F6C0136E0E
1F0FB0A3B5DE4B19800AC8ADC2206AB30653430174D252E3FA20771F02DA68EF
579CD4EBFBCF2F88DA535DC05FF15EE71CCAFC0B8A5C89479548766B85438C10
412E9C1BB27D809818CCAC6C165A39EB148B25F23459D2996A7896CB20683BBA
DCE87FC499FF9DED0E6C8FD6715B5797EDAC51A40543B30E165D9572F9FCE01D
B7D89D00AB1F14DCCA116CBFBC34A074CB3BC8C1754662B5D3FC0462AC496092
F32A87A8ADBE2C55747D7AF3101C5F1A2A1BF6C0E5E0523951454FE7AFA29CDD
EF96E951AAA9B8EEB3F9B7A53131FDA08D2A0093B1C31CBEA19AAE4FFC83A933
DEF54A482CC6AF65E421861F921CFC9583463AB93563080BACB324F05BD01D36
D82EEF86CA96462CC10A99281DB0023BED6E64D0BD1E9C51FE0264A18B16E899
EAB7F8D9100F751129AF903A2071B3E1928C721690E46D14548FC68AD0D4F49F
02C538FB890DA8254F3350F4C6708A496AE56C594ED6F276069D11ED9BEBDE43
C59E2F3879AB08B9A5B0901EC307EDBFF4A6CD8CC2FA66CAC34B171FBCC47141
F9C5DCED967A0667DE7465B7EEC2606AB53EB49507130471503204710CCBA0E0
138D450960AE56D6A027782BA27C44FD991761CA10FBFBE802FE062AD9F25558
6C424DE65237FB22C8424FC12497D7A39ABAD70F0760AB33B369EBFA1BABC1CA
2D5134F45D29A6B34C1FCF8465ED7103702AEF74973F6FB697E645E902D65357
C18B655BA12EC2461AD673225CACF50992785B8D77F7B600EFA22290B3DC8113
DB1B383EC98F8367ECA287DAD6A6BF31CCD8C5A949FBB5DB580EDA64442DA362
6194D76ED4A688023BF4933D7B415FCEC04738328542CCC82841732EC66D4BB0
A88B525B2DA2E5894BB6597DE3C0A43E7842920D073CEFD986A0584E020CB510
5DD5EEDE322800A9A0EF849BB02EADCA01610F6DF3BBF81A1A8FD302055C0B6C
B35488BBB2EC8930A139EA0FBC49C57E03C0F565C8E6BC119C8429EE319B1E09
E4044F8B2B065D4A943EA52291AD5033D0ED550DA2D59EFC52B122D4049F2291
FAA610FE8C4CCD57A7A8C9F5071193E20D096828984F609F872CF41ECABC321E
0A4F6F62668E67D660453AB36E6E325AEDAC9D82657F8ED07C3F4BAB14F54A80
89D3752C4D8262B3A6BCEB0F4E6436B4D6BBD1FFB91EA14529BE16F9E7F147B0
E3379E2AB5195667C3ED3E61CC556FCA79F7379325FB25D9E62268CFE94C0B39
A3D34378914075B7A31ED94233A9690AA696EE8680F17E2F8520AB299EAB77CC
0EB53BDCF9FC767A18B14BEDE58018E16ECE31415E2010323BF7B94C460C35EB
73F4AABB0D4C4560D8DF4183D3598FB9584A4433C913183835FDCEABEBFDBD63
C5B7CE8FFFE1D3D4047BC314780CBB549621EA8FAEEAB5E745E5CAF9DD3087C4
764D42A374C9CB925A84ABECFC00B4212CDF4E88876C2DD4E03023BC4874E464
ADB3D3F07FA22542322B7BEE5EF03D4B16F0562555A04553B64057A6E98D1747
274D3532637E253FBA27CD4F9D6D60195EAC4220B7FDF85DE8F0ECB79D4BF36A
724D7F414849B63D419F4B45BB03148722C583B7075B6E655F40FAC45F546BCF
BAA9E568F4B42D05218DDE862922A8F80A0DD8B36675E83371DDD08042927CF5
AF0328CAADC389D9FEBA7294E4BF5E5BC97294BD59C91650038D43193A9F3A3D
031A22BBC6063AB31408A5757BBFABA93EFAB8CB1D08A0BE926E464C425CE134
E91EA9C52A86F390343826989D59C19520CBE7228870D2168A99303C380DCB44
3F857B733BB64AF5591BA0D348915FAF4F3F2C3850BC291D372242340BA0449D
E1343A610605FF377C5F5FEBB6FE7AED268986B789FF758D29DA2A03176C992E
047A9E302CF6A3C38A3E255C3C92048596DE90718558CD3B7F6543889B0C918B
4D8060946ECFBA5ADCBF48B9E4EBE90E855B40EC27B7ED3E038B0BABCA16CBBF
AF27BB3538EAD5C8185DB353802CEB96F4AAB4425E9D7C3CFC41684C5249EB92
F0A7884BECAA984022347BAF5408E3CF3E7821D6EE31ACC0CB4489A057DB04B8
5024823654FD33D3C4D429D3793E55A08337C9812303280228A1E6E048CC39F0
1871EFAEE49D1D2D41749A942880D34BD13605ED1672C9A69EC9550922E73CFF
BE4201AD7462760440A2317E38B6D1CC468DCD65C961DFA7A9D7580AC15BC89D
1266566CB6B5476F2EF2991878E11F38FF36D1F1D67E0A154F2B4EB2F0B0630A
0A9A58E882932ED1E4292517107A32A63A475D1B321583B42DE5E0F9AD77BC7E
6B1A6CFBD3FB4FEFE2D494D5BEB32197BF52B989DD185DFABAC4C213DD6A04B0
285C7AC913CEC83CF9F300831FD25A9A7CC8B8870DD9E5D9541C24BAFC53EFA4
2A90A1984881D91B283FC5B6A95A1958EED1B1A35F21271D10FCE1045F51012A
BE342D42D52C383193734662065DD5653C091F96B947F7B389AE0DC3AC28D2EE
5F1F4A8C486D974A71CAD112BC1371BF8A5B0B825DB940B2125C16F982248B43
16B923D096EE2A4B193612337A6D180D9FA91E94F85FA4A333B445704A546A9A
1AEAFC042118AEF126FCEDA17A1AB82D58C6BC26430662D2EA4F4ABD625E32FD
AAE2005B0C6DEBC833692D4A13E2D795232E925FB4EC9A227DE0124D9E4B184A
84DBE481D044DFB16043E5DE2151363D800BBB94851B40657C4251E28174F4A8
1959C7F39B116613FB795FC468D39CB8F3E469F9D141FCA2179378543C805136
253ADE278AB7B25B0AD31AAEC036756DDD9639E5F846CFE81911D1812DB7C679
6778B0918C229951A684D801930E1BBA5BF61AC448351874AA23197E9DE8BB96
46A156B1131100E35CFB1CC7432A5967F4F372D2012C5ED5A9F1AE7ED8834087
9B2EBF04DECC857C4880F185B2FD093493DCCD90A97F22BB0B70B8DA22B3049C
46C749095EFA75F3205EB2BA1A79554E8CF3E58961D7037FA2BC4A92730FAF68
949DD17C1D4D030D7C1F70F8A4AF141013647112E761E4235722E6CD85C35C02
BC2251BC21E2E5AACC0CA211F50A13075ABCF9F440C991AFEF477BE13FA0D8C8
B03C7E9561C08C78B82824725A3855A2080C457601646F7B8699BE56070C904B
4AEC8B6B9B8B11F1B3F3B1EF24974DD6824A8E335AB7E67328C3CD90D02C96FF
328560331A5A45AA9D915695F9BADE4737BF65889EE9FDFA11A543D6358BAA6F
FFF20AB8C3ADE49C298C9D8BE918437C0AFC7665016DA0D967FA1A1B45CB09CA
DBA91F8B83C1C576806B25604B266B8CBBAA56B226DB7673920A2C426EEF8DA6
7E650EB7B1D97A8B5F4B74E77A542ECC85D27B1E7B2892E94414ABBA5CF4EB2C
265BE63A2A2FC874A864FDE98BF0F62DE28562647558378BA14DAA5A4745550F
8B3480EB2CA082893B64A7452A690BF0D521932F48137E381FFF4DCA857C3BBC
B5DEBDD171A3100D4D69D8A56566C0FA3EAC58EBE691481F52AE787815CBF0CC
562674B3264DF5FC0C886C34CFB25E01E9F870CA8523DCDF93D57CE57C1759F5
73CEE384947A14739733F9011788FF8C76EF12390D5F3BB52C4D2B57D2E4BC00
3F05EA7B0CD2FC041141C380FB9E4DCA7640B13B0C57532648A5E341E6E376A6
3E8B0783DC381EE896BBE7AB8209F798187BE85B570F3AB5808F2CBCC1A37AC3
00FCBB1C8F38EFE801F714073019173D6472F480A08459D6E042863D685255A2
3A4BA8B6CEAB1C3DC43E4C2E379C5976ADA0586431588D2E7910A5AC1C3DC43E
4C2E379C5976ADA0586431588D2E7910A5AD2B8E5D150CB3584CB2DDC5796F17
B54A16ACA135C208D66738BCB61B03E6DE126317ACD924D5A61FC3122DB710F9
A0DD26B8C902122271A38B7923957A15D11E6FEAC46B11617838874E7F840DAB
45050FC413A50371058D893A908DC4D0DAC6FA6AAB73CB8F02BA4A00DF7079CC
28BD92DC4EDA5C72C6F813D53F1E9C3734B81C2AD58142A13927989ADB385BDB
052206F0419C55E36B49145919616751A5A80154B18B9919E7E1A053EAF0914B
C8A5EE9DC972DDFE5750B9009F8741061465C24DAFD3E4809B0052081A7B4B17
5094D56402045F9A3E8F2D6D03DCD918A30005C31F177816336B74AF8B9931BE
C0C18FE8D16D2EBCD7AD3050E68B2F5B879433A41FCA23CBACF19CC2D4E00573
CE94A0263AFEE43CF04F81A4AB342C7D46FB3284186CC6BA6A41105AF4BE60E0
FE5C1E42E1702702E1BBD57A1107F0AA9727A4EBCFD903DF37C43690582E58C0
C3E1A010DBEF44CB2CC458F45CC832FE2D679157F082AE2BDE83E736F2993D8C
048393BD80B70F06F44C3765B43DB403D579E475E0B2864CA02F2EAF92A23F82
87DAB64850A522D33B09929C00B48C2CF4EEE2C9E03A99209B7C8C8E88016AA1
A31C82587A0E788C1FE512FE1AC1AC380F35CB7D1A99103E110E0CDDFD04C81C
19DC862F93B03A24C94131987565B60AEBB0164B2E683EBE9F8964D358AA76DE
110300CC7B898FBD8BAF00EBCB8C621EAD3929CA3359322E25A5E9FF521C76D3
F8A506E322B194E71A7521A71AD931844838EE9A0A68CE56BD9B788235AA0847
B7E9A4E1D5C3FED9F2798B38A40ED8E3CF7729009495AF32699904D4229F797E
793D3239F2A7A697C3F18F402EBF6C56CBC4B24764D050C2476D716A5D86A42D
4AC9B54C9D41E0DCB52E647555DB73D6E2B9B17F3714CECB3E58A0A8C4489E23
9C17E34D6E7D2AE2E881E755D62BF45FB7F79DC36C582C274D044934D212B4FC
A7DAF88EE055B2CD2711EC377DF94127279895A66CC744D9947BC5A800F9DA6B
7BAF861C673F9B4A317C507CDB27EA8A1472D4E8D917E62C98DFB04BA67AAFBA
A5AA9EA029F95B828F816484772203F3CE77D66F982B8E51F67A14B5B2C6F84E
9503B6429B70C9A6763449801BF7518806C6D295955BB71395C43390497C7B19
0EE510C1CD4BD3F70BD38D7374A987FEE1026817192AACEF23FD8FC11F483C0C
DAFE837D984A761286C58E113FDF77718900E4F5A4B84DD25FD7B650D3DCF5F3
C8A28F7F2648E1819966BC2476D4AC4E4347E745919F654CAE066DDC7393F29B
4D933306793C754111044E6A2C0A8B2F290EBBC3B35D92E472849BD10612A89E
2410E5BC82DBE4730B36A9B89006981089FFA13034B8CFFACF3899205DE91F70
834CD87323DEE711598377B8A1C8740B62118704F4C9DDA1EEF4DFE780E86651
D99C9B72D245912F98E607A891E5DFE6228FFAE7F13B55C205F636F38C6C51F6
431DE0F8FEB6C3091AFBCAEEC0FB3F3B74ABD59FF3D815B045C9B64FFB8DAF84
6931370FF1C2D45589A2C997B124C1AB303E1C8AC7CE6FDC9AC1D86044F2E5ED
AABB95B187A4643893395C4BB175F1BBD94595044DE7F40568FC538A0EA2E76E
1F62790DA67887AE37F1FE6E983CB566D63D97119CB34E5B87902E04E1970252
842AF43D57F70718498FD85E7A99EAB7423DAA5730DC35B437B7DD011061B1EF
585D7190F2C24F9A9A1445B2196BD5689E19C3E604F93B012ABD81551CF0D1D5
85061693306E17DF2D9686FDF1F0122A886D3AD63FF123C9B19956DDF207E96F
CA85B085CADBF9DEDD098FA17F55B8E2DD8F082C1C06DABB32BCFD7EADC3FA5A
495B3BE9A85447F14127DCB7495134C584257D260AB9E6C0037A842DF6AAE584
3C949952BE48F9E5C850205DBA7C68199E356555DA1A22700A87C2999DDE579B
60444EAD3883C5F70C2E005213489EA21075A3BAB4C488358207F61EC332632C
DCC750FE6081ABD0F64DC19BE13680CE806D3C6E541169BF642BCE84D2C73C83
76BA18203DF4A546DFC76AD0424D6077D5C415AEFEE988A756A598AB1998D530
39A1BFEA1C40DC1AEA90C0959232198D1F487F22A1209E17F22E4F250B1AD234
808045A2343483ADE82A397E82B1E979FBFCE731CDDAE1D91474488C3128E876
564646B0910BA9E173FD2222DDED8C4BB4813D9050AB5734897477BA5BFECD08
F2E9B0678F1C75B4349CD62FF97F498371BAEDB7B887A8C6479AECBDAD3753FC
B3FC313F26FF8FC14D0B094AECF59054765816492E0BC6F9A4AADBCBE3205CC3
5CC5254CEB2975B401A1E45AC6E8F79F3B51C476287897BA6BE3AE9206F15177
732CCEF25DC095FCA2071BE8C67EF945078DCDD901074A7DBB248AAE385AD7B5
87A7E8E59EF92E6CC1D2BC815E10C3FB0767090F5A01C7B35DC8851C4CC3CC5F
A14AD45834B72A72EA85547426FB8DCA85CED8C179E8DA15A08D67A61C390DE2
4773607EE2AF66BA82F846986F1BB03C7CDAF15AE531C02F7BF2BD20D865F316
89074E8EB7AE9FED28B0224E5C15C3E4B1B7B9157998C8EADA678CE38225701E
16A819EEFAEAC7E06C9CD499F43D24E8A1A815338E9F4B2B1B0E82CE1FD16B33
CA5A42CB96345F37CF043FC6A0A62B66FF1976403B8C17B6DB619D0DF87BCF69
EC5D5D66EDF8A007C8C599F051F8181FA2DA8EB3A3FF7FA13BFEFF0A5980FBAE
2FE3B3F62F20BF5C8B39C8ED705D80E3DE0D2332FFC0DF09B20D2A30C907A4B3
019CD4AD5B5F9C815B4F86BE50000FB32209766D44D3EE43BA5D9A50B1531955
36AE6A6E83FC0D04CA55D1476E2A99F8F271B2B1EC80832C40E532FC4AC9C488
F1288094A65808A9585AD95B37C1FB0AFFE4A05112A3BEA369CC381E09AB94F1
A9224922B4A5C23593F8765E8124A2017F56A865295A80BC736A8634DD460363
59DFDD4DCB7453FE85F8C56A14109EC81E903522047C2CD466C90A3A342D8157
822D42F334B8793F13FB6797C5E5249A9849DD59F622DEE2356B941F292425C6
3C09D85A4E0B1453589BD32FAAAEBFEE0F7C1DE0499D8206BA8984959BE70B58
957A46918DADC4502323B2A791A83E9FCCEFF13BA763B492483C51D41076C0FE
99D988D612DEBF78DCB492D5FAA6A668B2585A3D6006683222F07BB1F0756B17
71C5FA50EF20ECB3E3080FC6D8B395542D5E464CCF581BBC6051A1F0E5EFEAA8
C7D2D8DEE7AF696EF5BF1688543D83B3EBB1F1EC7A558CD8D86DAD66D3EC9336
7EF4E9A58163F8D66A425E637DD4790CC8A485CD0B577A7C44CCFC66887FF3C5
63185662EEE213EC8671211D85404139B2226BA59807A4E5B3CC008C51C13560
F14795845D7FD6AF386280FB1E7C70B9E987F29905ECD40B9F122E1AE5A5B5EC
87675B021FE9D71441E352111EB41F84C9FBBC3165C34863C9ED6C46D85A5EAD
76FEA95387D730CDC57983FAFC88F684E6A2C237143FF92C2641488C7FBC8724
05B7183D2385AA4D74E4741583059D79F3418BEDF018EA67683158D1B773C6EF
553EA897D5F4B3E8411AAB9A60C2FDF1D3759ABCDA9DB4FFB4CF70518D9CABC0
7FABD5959EB539EA679132F12265160BEB350F6DD662B269929C431F13BDA571
E3523E5AF4654280735B63AAAF50D6EB1A77F44DC13FBBD93081B66089B6B3FA
C16BA0900825A18A3DC8F5CE8472C0F6AC2DA72BD9FD18388EFB09382FD79729
426B902E6812216BD5B6AB200E4F65606809E80C7D726BA33F802318A002948F
E6647C2C1AF8F72103F1A7415F526A2CF3C16B800783108EBF9EFB538C274E3C
64685888A61CD2FE2A3912709A71ABE401EDB52C881153E8228D33EFB93F057E
59658B7E422757988D43159FD814DAF574818FC2CBB20430ED5844654068EE83
6036C4EABC2FFFFD635262090F81AD6A35CEB85520A70B252F935F7CDFB69A1F
8A67E106F644E8873C9F74186C527DCF2C26EEA6B5033525C1D78A2696FBFA1E
5C6668641E4C15421F6D812255D98D2B641A34FAEAF8703942158003E586C24B
EFDB1660A6D88CC005055A705CC4D79163209A2105EAC6577EA6EB40DAA03BCC
E2C44B2C415BEA7B5EAC41CC092D15E2CAD020738A995E5405EB5449AD8CCDFE
6615E39270C3A6F3AAFC4B1B997B5F1221071122721945DE6356BA976B0B441A
3333A9B31EC7C2C99EDC7BBDFA0CE085C7CFD4C70D174F3ED7F9F55C21A04F1A
6DF8168FA2286D8C7EB8963A118EC24F8F4074B96C17C6D3B1E5D72540938F55
D26EC7B79CDCF20805884943DF21C1F7CB9221317C8A0A2C723823EC950F683A
6BFB55D22DFB161E1D6B6DB10F78A1E70DA07C43942B964A6D5ABBACCE69775D
A6C664210EF22D0376B41C806A9ED583DBC692208CFB1D4D83A9282DD75BBCA2
375339927906533FC039FEB875DD4E6FEC5D5D66EDF8A007C8C599F051F8181F
A2DA8EB3A60EF978D860252ACFC5659CBFFBAF642694D17BC8EC45E9021D3FB5
D5882F227F5EFEADD582C932F59D55EBE9E09260D1D60B17DA2A733EA88A189F
82702007937BAFE84E1ECDE1EA43EEDB955513F42EDDCF39AE522A11039DAB96
2B34C9800758D65160325837F8FADACFD568B3005C6DB3F15DF83E0185CB1398
EDC35E34404FCE1CC2BD56BF961AEDC4EB2355B3321C8469F0783D71E6CBAEC1
AA94F414ABCA46ECF689BA685F1BD831B4271EE76BBD57C32C1A64E1CFAD9C24
6B690DC0D5BC7A2D67CA6063169F1FE7A3D115E94D83126336DCB8867A795FA0
34CC822EFBD2780E3A78CC0F9EEFFF109D3B8A2E27BBB6A92FFDEF81158A47BD
89E38372CE2D82290BD895D0646AD69FF23D50EC5BEE2FB95A44F2B2E2DD94C9
33DC919A95A33686869493FF0CDB137CB5DA5880C54905AEC2663933A576C6B0
758D49F3155D448D505F73A5206BB2273442AD48691C2A47DF05F6A7466E87D3
020FB2D82219F503119DC1D91DC405030D93365A941D51720E59B6422C5A151B
A8685EA40A7E410F3EF308B8792776E11E16795375478B68865970DAC97B0963
E96D04B6E9D6AD8D11907B246D94B12617AB50EB5A520CD8B2844CCEF62CD5B7
466F76A8368D8F9543230805C8763BA4DF22B4C6F976502D50077BE9AA1668BE
627189993779AFE5A84CA71DD2DFD10FAB2CD911298790A1A918750549B592EC
17784B54ACB51E7CCAE75971841456AF9C4E9B3C0579EB0A5BCB8A96755A83EB
0F6EA03C1D873F0A7ACC08B6D04E2831ABD0593ECE983CB5E976DBDB2D13A7FA
C12A5C7A2BF30C27280DB9C56C4F649456956B785272A2C92025F12147C5C8D5
E39937B03356D453D819AB0C7AF8859DA64EABA78F8C85459E49995EC05E1C5D
85F814AD4FED33BEB3CDB415F449C9B1F415163843D27A9D834A872DF421458E
EDDF98DFDC51AC170E4C758D50578974E1C67BDE0D385104C7C0730BEF94DF3D
9BB2161ED9E2B958A1D5AED112BD7193A3047D23C8AEEAC26C7811B765EE94D9
2CFB878BB725B0E81E119B3C1DC388C0F3635D1C32197132E5B696C487566173
0C15BE7C487CA1A1ABDDCD1A2C502230FCD91FF58247EEC1668C8E7AB83CC9C4
A83EA7AF7C30BBF5848B9A43DC60097A495092459E5E03218E29844B569E2EBD
6271DBA6A5B619FC2F0AB482F40362CEC29A918CCB798C30DA069C1E3F370038
68313353CCEF779B6200A1047B20647CBC2F422E1903428C9C1C55CA1B578B60
B07EED815F4268604A48CF50915AE1A7B21172D02E3D78E253519DC09411034D
960ED81D9C487AB4A715E0EF9177052EE94549A76596DF7A4A0FB2D029B166D0
1B44818AF5389329FE1DB143061D8D71814BE7FEE42E6D1EB7644C10A722A014
37198CD1A228C8604285777D95E72413DF80D5F696FC6E2BEF6049F91E1C73DA
70945B9BCC22483B0FCE601FBC0A596ED050ED7C5513B0E7960D957E19837FD2
27B352E8BBDDCD7D1C12433ED9CE0AF54C73172253EFC739D75282C4E8EE1EF8
F55C6F152328970F18F57580B62E6B59DCDDD7C00CD9A60AEBBA3FADDCA48E27
45359AE31AE1E69EEB562924278CF8D650060CC2923372C0A870FCD439BA5772
B7E5E398285529758927D5AD6635D241202AA5D756792BA310AFFA57355A1CD7
B73DD5401ED7608F3DBF3C2CEE2DC1118746EEA119D9804673924FC20C14B7CF
5EFBED195C67841000359D2ED7FD6B3C221607078148E4C62B2ECAE693F327D2
5D98C9AD193F94381CC6B405CAF70989799D9D24281EC83E6536996D29B4A708
EB34E9AA44ECB7649E3347035449BCD936328FEDB5C3F22F56688B4CE4CE5A22
C8DE2B88B707256FB5CF7087C1F51B341A01D47A5FFCC91ED4B7E13900CB00E9
70CAAC1F6B997B7696988A9F2B3AC897A10789DA53D2DF66C7AB53D2995F020A
0BC9F8959C4ABDF4FE7C245CA0CA9CA597F739879F1507A6001113B11FCC641D
676CD1261943B5D779A887A15B8604A3224BC443B7B1339E01F04B9263555F59
8E184CE235D436D37D31BCED986A2711DBFE9A147695843FD9CF8D6BEB3B9A8F
DB3333B694B547FCF2413D29D7315B04929385712AE14BA10E2702CB8DB381B0
C32BCEA034F240E122DF5C95B68BE31E79043AFB739A9E747AD286D01FD254E8
3FBDE2731167C11208B44433709C64B6264235F1C02795659359F02EFD5A1069
5C3B3E2593B4F664CD29CBEC4D602CC8AE995BE0F37393DB3F8EA2A7E25B5868
5556C172074527E26056B7FD3906F211147BA146D78C62B62FBEA3A04583F3C7
DB5E27DCB50969D6E738FAB4FCA6C32FBC25A59E864F43F15549506F9B6EF436
41F2DAF9BB3C19BE207736AA1D57B3395159250E09A0722970358860356A2164
7698A48A5AE9C6B06D3F7107E4637F9A141C818459EFAE9F6D0D888958703F13
A25361013CE3C3F175219489048E932B6AE8532D33902265851EA5A41A22253F
FA4AC7DFCADAF83D08231D7529EFE236250D218C329EBCF789BC49E4AB223FC8
3BEE7EE2609E8397C2DA3E0F382A4C8057DC8128494EB32F86EEF6697B45A727
83A186DA89F02F2C8CF8BC727AD6F9BE76C4CAED815AF7DEF664098CF1A16744
4F32FB0096B60AD8836B98F8CF2EF19ED497CD01C3AEEB172813683C2E8A590F
525F07677894590F5479F0D8437A309CD564A6F542BF6DC075F7F92432C2CE43
365D4F113E8ACAFF613638F63F75B1BFE40947186ED34030A05B34E2BAD70682
ABC6B83B94740425BEA1820FFA7582158112CDD61C3E288C8C7D6C9EBBB54D94
18748A9DB9D459E73FAB041297D7440CB5996F9D1589CE0B045181F7E024927D
78C174610CAB2FAE24EC95AC09B3A5713D284BC11DBCBDBB7F15B6051FD25853
5F8DF459F49E58F0CF991AF88820F1237A88AD72D8953E25AD506B9556A104A3
ED4DED4B0752327FAABA1B604C266E6B79AF7CD6479A34E1B75657B41FFDB8AF
1C9E3D3CE95EB6F6518AC40027D89A07A5B9E4C87FE8878535BCD86CBC9F72EB
FAA7BA8938D226A76B011D9FDD66C24C534404F6313AEE8115D704B5EFDD568B
D9121F52279AE3633770111F936A36E33A15AAAE3D4A2A56DCC2A73404E970D3
61707292E5C5A6EA04FCECBBE13660D5360139F4B79CA17263B9F0369B66BA6C
E4410896ED9356E725FD1781F6B2568910A40F1A19000F1997187917BA23FE19
C855127FFE601E8ED0AD98E9E8AAE92BBF0645F4CE76FDA0C7A7FD2C3C0020FC
70BED6D04DB4820FDAC00246DB56785CED7E829F5B18B621B99B494EBA7C4042
80919DB4939F4758E242256C0546A502E082179E316C22CB3C936A5C51ADB559
5B333A06C8EC4A42C6CD98A11CF30DB56D6DA12F60EA605290CC0000476C0235
F3CD2DC7C187C3B8E6D1DCB67230EFF3F206ECA7D35A79B6D613F3D66FCA7169
2EDD0042913BDAED8DA7D7C8016D0FBA5722538EBBBC8D37EFD7DDCB0F249FF9
6E2C1310B08510CBC90C93B34EE07C1F1B354CC7B6A68856A2E0FEAF9E99B874
ECFEE099B33FC49D08807696374A4A48ACA50501BDDBE793C16F9C0CFA569344
FE06F0B093B14CDEDB71E04DD2F06570C474B0B414473B436F50966B571C559F
1AE96EB4CC354B33828276F2264F3155D4DD61B0F694672E47DA7CB4ABD9B410
BEF6473FB4126192FE541D41C04B567DF3008C7C00ED5B17DE359DA187810E27
5FE64EFED6873046F14E850D30BCFD2B6A49A29126C836FAF7CF7DEC00FD7823
03816218B37286870D7CD07A0F06E2874DF99ADFD2E19382CC90DFFB25E67F6F
B76610F4466006E9A148F39874A1488F1F0458409D442D2AC5544B686DA3FBFC
65D4012B3FEAB06663D976949A4CF53ED151E32302597BFF0F12D75FC78B7201
E250C009DB008929EEA641F9C588927AA28D9D0219690ED5276518E25CC8438F
ED37F3648AA23B40C239B5C7BBAFF680BB54BE425259BEF284511CE9FD05BA62
00286F1B732AF31F4B1C4A652D1A7F8DD8C00AE31051D442F65DA63402166F69
1C0CF64F103BE90E24F7EA8144C9C7E4D3BB2B1A833D4B48CAE89F91AAB45B8B
BD1CD8687B271816C920156E112A17230A8A59EFC5AD6361F505F1ED38366949
1F4EDE908E6550A2580BBCC12D333F0809199BA481DA5509974335B0A2CA1F1A
4A18719CC1516CAFBB7A3204F702C98A868838438F826C33FEB35E45A818F41A
007E601C7B7B6593B8270723603F097803324E2127A46E9DBC2EDFD6B9816143
E0AB78003E0E23FA2C709320CFA25C18DCD94E943ACCCD35893686E88F8F127D
E4EA963E26BA43CC562C47F2DDC9632F3E1296252F084D6BB74CAC444AAD23F4
9087E3B4F7B2017CC4DAB7563CDD7BB85671489C01D265CE34E1F3D37687AA3B
2A80FEE259DC0E73F83E9859B308297C05EB5A7BE69632558D2DB6E15EECF6A5
8D8467322EB65A2F8BC6050605CB87F380D790A5F0007CEC5F16F1CEEDFE0241
704A66122055DBC4CC3AC3E1F920AD6206B9314B5EE2A45D55AC4CFA726AE81F
36DF415EA8334CC2F26CF23323EF301095C6E99EFBB01FE3F757E6936FB0AFC4
1E8504D553FFC1556A37F3BD27FFBA6D5301445B8B5EA3B5FFD7CB15E2DFD2F6
4829B7F2392F12E2508F95949634071E3405B3E415E94614ED640C074C521CF3
79526FA0FB75CC1D909407C93A51EC343F980BA1679515F00D8A162CFD5E3368
1FDC91F56596DD709A239A40BEBAF05CA22C94624084DA48137AF15A6012F3BE
BA9D5822E3172F75FBB248443231025417596F3A812E0C17F5C1D48FF7CACAF3
38F46A1975E4BD99AD9D53871027450BAA1FC67517CD5B69EA89607A13E0F665
19015DDDEF46F228FBFA9A2B597EF2230C8204FCC642AD0C59D2368A1CC3967D
F6EC4140AC4E1C51BA01611E70ED5E18C5897CA59F354BD2ECF30C6D9D282263
EE95A66B7B588B417B20D3AE846ECF2693940D4DDD5FA5A9342C085C5FD2C774
FDCF4DB4D499701828F606843E980BD3D248872563E9160E4EB16BF9349B82BF
99B2619C7CF300FAA3ABADA58D1BCE5C9DECE27A367026566B91425A2A65C07D
4FBCBB8FB94BE05DFF2B38D88C33D03140C8520D7891FA55D331755876F649E4
B17D08C729A9B845FA4DB9CDCACCD1804B9444C284E42890B3A04DA6593C846B
1FB75433B24AF1F6CE1270429F63203111B6B5FA34108CE6151D158AA7D6F4DB
E64EF67A6DF04482C41CB74EBB80E94653064E169344F16D61B761649A42B061
255C93ECD9B8DC0D2A73720893EA80C82C22CAA7A8676A83FA6E29AAADFD82C6
585E084B80B74379E92444AE54D5C6FF284FD81E544D200A0A4823E4E5D4CC7D
ED2405EE490294E01303458F742E5D683E2176455394437C3A7B477AC27F7585
0CFED5BDB2F076EA4C67812757A1EF9C33F572F221C6167E73E9B60B263364AD
5C87EF75F0F20B0C305C61ED7271177D26C4E23B9C7433ECF227EAFBF7F6BE23
17ED0E8D86B87331E228170BCB47DBA2E9C8E8BCBCC1FC88D553266A132A16B4
D64F3DC8E3A54AB83A73FBDDDDBF490B94EB19F94E6820969E6915600195BAF8
F95762FD3FF5AABCD63218AB9B7BC8F7037F433A0AB962F52147208D9C7C14CE
16BC7ABE5075C3442F67D4C551690D0D92DE92AB8423AC76A1F343BB3E1061CF
4DCFCFD87D706A30814D230D6B6B3E6330059159C189615897A97EB497CFB630
2C8F150CF2A6A20E81D81903331AF2EA0A248016BCEFEB06A3B47E119413DD95
56FF4172F1B18271FC2437A9A6EDD981F68F15ACE1C2701F6C12F3FD5543301C
70C2F3CB6BFFF49506F54C9EA5C41B37AA1D7D57BD7C746FBE8FA97AFF07FA05
D23A01A37B13382227A754C1E4D61DED5B682696A02EA21A9C6FC7C1CF767FB3
E937DB97A6F946A77B1CEA2158DF6A4079D92B507EDDEDED0C75A7BBBF3C3B31
94AABFEA61341C59B612180E4E1C713EA630D7F1405B0467027EC1E27BBEC48D
51C674C81C1F0FA9C5B92A11EDC335D079E6ACC69BD64BF071A2E23E217FCBA4
EABC6CE4CFAED0E15380F671FBBEEF074C99D59E9679880691ED28C1E46F19DA
8388F8A62EE45DE6302B7F254841C7C0A7B110C46132793E5AEACAEB924956E7
3EEBF2D0ADC01B4C91F9E1D09D0B53EA9EB0739F75F0F1D250D95632241D80EE
0DECF26057EB4CA3D86625770B51A7274EF1F474A2AB6103B429120A6D54B43B
81134C4BED69862C73370100D908951251EAAC98B18BF46B1FBEC21F95D2E4D7
92F6232060A2730381C0DF5F9AEF60A3B0C8F3379BA434922FFBE54A90B12646
B3A5FE44632BED79898DE54B5BE945BFBB41433632A244D2CE10DDA45FF84DB7
8BEB115299C3D5CC60F3F1A0E8B2BC9AFD5067315E4118D728838D9D509DA3CE
D8FECCDADE8C5EB7123C92A5F8A6532F0804480805E17E05FB37A385D6433E59
2308842744CE906BE110C37AE06BE770561CD930E8AE76E353293F8C51D0278D
6F09B8DF311CD16B40EB4BE72BA1E3134EB86B4F28FCB5623DA1351D02D2E2E8
4E87654006B36DE2441C60E412CA2AE3686F7DFA49F81BA6B221FAB4F88AD57C
CC0E927EF7D853D4E937E83A49AC57D38A894E8B92C9E465A7892D5DFD4B654D
2973AAAD8001ACFC18FF3B917F25E3FE2B7FE624371BD931719C5A9AF7F4096E
BF1298F103318B37BD96C9AC146B7A62925850B9E11A8AE37057DE0BC5B2799B
4A6B62A9C9BBCF1FC0273E91F585986E868A53B43FC51E84820FEA672BDB5BA9
A55D6C99BE804ACC066D422EA0C81FC4E1F97B4F65DA9D07E1082FC4949E9D7C
1D19CF976D0581EAAAEB4173E6504AC4D2168F1C926D8C31F6EA95FD665B591E
12E4DCF10ECA5AED88EAE8608354A27DA79FD0F96B3E2A4463A7CF2C72E8CDDA
3C6402606AD16969621B7B86948DEAAC9ACF23D66E0FA7039C3E11CC5C1BDD13
47412F12788ED8D7C24466E5410DD289DF78C335D2BE90B5C581D2A296CB6D7F
352A877F875BE5113B3CC5C384E1FFF89E51D55B160039346F9156826750A779
DEC0047602E7D073D70B20DAAA10AA02B9A6E6EEEC07FD93D19F9C0A6CD30655
C920430B9B73AF085CD308DE598078BF655B0067B03B656701A930476B878CC5
4F294DBD5F0DBF2A9A882B30835FD377E00C7DBDBC3A2B5338B14C93F707D1E6
FC0B3871CA476BE8D70C2DA36F39574173F3C10853CD646A6770333C22FE29D5
C4922C5B4D239F0315E1FE76B96B0E2ADB4AB1FA329B2151E9A61200C8D2624C
14886F4E8E6349DB7A169318CBE6724C218A3D6BF983F454E836BB514C044C87
B3CD95AF693B41E239E8366E469CA5691562A9024DA5CF1F78C47031C3C3DFF9
9CF458230A1642F9D6F432581CC32E2D7F214469DB04B6C319DEDE2EC73DE49F
4013A0DC7E2E9371B3E8DDB8ED8DC1747380E0BF357209D6A4F4EE88E6647842
0ED9E422045F45A358A7A162679E52850A292A04BA183BE9B7BA5722421E932D
83657C904434F3CD7B480314A0614101B04CBDDA982E68D06BEF3405EEEAF0EA
7ACF1E9A94780A7AF45966CEEE10B25B9A4A279FBBCBAA096D0FACC20C8DEDDE
1923AAFFB416FB3029ADCFE2BA827BF88EBC67BFD892E35E6940E94893E1CDFD
27972D349C264A28CAE78E3BBCAC1A881DF340EAF1D60DA79B50B3655232E12A
5937209B8A96BC02A0A3F6507D12193075C0BE19428DCE545E76FBCFC9EDD119
5D91EE456DFC158C88A253D74774970B11342D30A798FFA9B269500032C24BC2
D66EDD81132E44128EE1BE623EDD5DAB03BFB8BF3EF2C1C6DB56FDEF4190263A
01AE737ACE2FEE5E0AB44F83A07764C5B7017A8DF4AE3478C68B4F7E07FD4CA2
5B5CFE5D573FB3C2BF3D2905CFFAE9EAF0B914B9BCC35182826B99DC9B1615E5
C5BF799992D38EBA3F71C4ED61B502E510A24171D3E508B67D68BAF10B907035
71D318475C199F43CBA720C3702604ACF56C51009EDFDB54C397BD138748D0F9
056DCFB98DC8888051E28AD4FCEEB7BA24A8294C452A3E6A6E801FDD83FFDA14
378FC3027ADFF7DBE2AD88CA3261C59CFC1EC0418A96E2D3822007395A5D78C6
98C7366C1C453FD7CC6E94C0376FC578767BBE4F591737316A4F657DBDF2BDCB
627DD1144867B579F69E34040E2AFF508CE7AF4B0D544E7518FED869255EB21B
016AFD3655F66750D3FAD238103B812FEBD5C3CD1CD7D37445D9DC55D0A60768
758642CBE636C90AA05E5B55E0B9D042DEA04D480710D369A3706F1B07F28C5A
80F4BD3C2C515EB5BE01853F7F1EA8A073614C5800835F4FEF95F93FBB61F865
EFA251BBF7CAC97E5348D04809C49896E18909ECD6892BFD2B0D73AC817DC5DA
8DD50867B4A0CACD2F2DE3B6429FB7EB712C10708FB12E1D04364D7CF5B22AA0
700568A144019E8E47EC817E08C6A760677CFAF1D482656CB75CF243EEB195EB
2140DC00FD5F6F1725AE16D44B8FE84C3E122D49BE569737ED09A882AF74475D
B676698CFD9496C05FE4FAEE870B692CD097005D1500BF926CBB9146855D0C7D
E64A028DF1E2065090894BC8200DEF93B057C7F66A85CB551EEBA36E8B8DC122
B1432A6BA9A8A674CA2D5F3B0415F14841E48E53B6BA78A8448A960D67BA679F
0E23FA9FD3482F5488A9B780043DFED23300AFDF0C462477332FAE563201702E
1E4BCD55F19A81A4EB89321029C36C3B10B6FB20FA0BF5598D96E9C848F8EF35
025E6485BCB4A1F2072361A0A553FFA887E57B85D56DA207C999CAEC4C445BB1
B0B552EC1A00761415D2F53A866C95D4A6848E2BB7970D17667693B2392D7111
3C43E1AAB21148C4E64E81EB2D210E013A50A8DC4E816B78B9EE734118C99128
2B1240D3E46156F523906866DE7293A1F71DF875BB199FA58D44489B80E04997
F7CBB7FFC71FC82F8D173315A44103BDF54133FABC30765D6775BB68C69704D0
BA5D6DE6BC5E10324344978F194F0502B7E610DC069791E52CE628CB5451F1A4
8808B0AE054CD40FF05C077FBDA7E41941A3FCB6C4DD1F15407BE246E17A70D6
3B06C79767C883413636125CFBA691830B21E3955B49456E7E3F29A38E96B196
2E6E2C529DA22A5A9F0AF66B44344F1DF681219626CDE2DE9DF2AF345352B2F6
616FF952D6E261876517087A6FBD092B0CBD2223900A5A4D8EA5A11699365223
82A6680677B9E3B6FCB6764227AACBD15214654422D7C8807B4D40A830DDD392
F93F6CE1294B62411E6DF77D4A499D9CC47EB3AAC7B89EEEB9E2F9CFC6BCDFD9
A438C10F150D501654D663389C4B5A8891EC5F847FD143664563CAA727782BA2
7C44FD991761CA10FBFBE802FE062ADC1C9C7B163CCA056BA39D1151A17BE5E1
5126B33BF5A994CE3973875938BE310D0033D4C73CD6C95A76CD17A0E2A6CDB7
98809B5F2254D8267FC364DCE291E8AD7A2EEB345D566003B04D0603504C0495
1290F43BA455DEF5A59F41FFED1C2FE09E0AF9A4D08C642F9C07E1C3290A6272
DD9FA088D3EAFB7F4C3146DEA1EF3A730A16F8722C377263A6075CD4784CB799
4F0C9F5DB86C3109AFAA8D5CEF86B63BDB575DAE9F7E1E55AD308CD97CA63ACB
18C6928FAAB6BE26151101B7807B2F2EE631BD20B062166555853F3C54A4A5A8
23A807BA732BECA0EA73E1EEC67A930E0A221BEE8B2CD455AF9B5F2A6343E45D
28AEDC006B6DA2CA24E020A0FDDCC0498D74594AE3ACB0EED798000A60B8A3DF
7F12B1FE9D0800C9DA440F8F4DF6D6E0635BE37E23FB873E2488086BA272753E
307CC057C8B8EF229E16DE8D008A4CCCBC317B47BE42354627EA948063822DA4
79E4279465A6CBD43EB5B5DB8B72E966AF887CD3C3C9D8C72E516C2E80ABAF4F
6CA5ECF506FB8D10A397FEA6A4E3B9D38C9A68E23636A15FB82CE00571A92767
06EC7C748A40418CD85FD323D46131B9284E426F18BB6301ABB5AC71737C1B1B
488C4B435841F637DEE3E3788194F96259F8A07ED67DCE8B5ACA00EA4C0E1C69
E9212C1F00409F1184AE358D6F5C5432DBA9D9E53D52D0265952CF508955B904
2CCE1666D70382E470679026E743D60D4F71F6CEC22A583406AA0C6AFF44BB50
971320415EA8334CC2F26CF23323EF301095C6E99EF9DFEA733F52A53D468179
AC6BA242538EC564F080D8F7DFB7F2397D996F421C900BEB332B5654306BC193
F6DE150E0809CBDB3C5DCCE929A32C7F0DCBA32F57AE6C99C0FF5D90527700DC
510B038AD7F32FF9EC47514E5870CC148B27B151E8D4F7D855C4EAE8DEC82AA7
7763238D81B21F658DAA7AB223DF5A0821624DFBA69D28458375A1274F641D5B
258702019FE5AB5D67DC963748164DA4A09BAEA6C7C24CE1C6C08D077D340DD3
1B820E7D29C92FB5C26ADE2DD3774D903024A13EDE0D58B50937201EB3452B62
CA26EA8970DCA4F35C139CBABD4FFCF1E22AC4A1A230BC22989E29BEB0A1977A
D4F72A7BE9033253616B35CF39C6C3E0846586077E38E1DF1BF4C8C223AF4158
DB1995E9233092F528D6A704AA7EB260B129531E37A10AD7ABE3064F74DE76B6
9F4B120AFB3B01762047E5B3E495E6C242EA7B5C525587613D335148791C6FB3
0D7B71662AD1F1404A836A801A94776AE8FF00313296CED5DAA2DE6C0097EC1B
C552EBE9B4BEDDDDF27B0F02BCEC959192C6F2F6C635A2C17CBECEC40386F048
8798D16E38A90AC0353C714458518BD7849F093D3B4C83C70B207534D40D1E2F
1976A39C4D85EFBE689724B63240C71FD8F9E0AC14D1C5CA1FEE4603A58DA947
73BC1AA531578D30DF7582E296838D7DD1CCD7A89F9D218170F4EB86FECEAACF
A19187A0ACAE8CFD363CE13CA8990DCBB5FDE8F21AB1CB205356746638CDD9FD
68E308DDAD10EF796609D033D80A82CC481EAD70AADE0E2676CAC462A9B11236
E42B64F1DE8F7B8246C840F68A08DFEB68B061C560B75EF14ABA888E8A86017F
B9100ADA3AFE74270334888C05218DCD8124F8E93E24F05AB2FA84A4AC4761DA
FE8A45C3BBD11D72BA01798903DFFA60F6AC177A3040D8A3A09D09EBFEDF3197
A5796A23B927227E51EE19AD01354634F060085FE5EC3F1666585B4F1FA778D2
2FE9A0DCE180C8257A3ACC1122CE497D5BF45F01304C59DD2032DCD75308954C
0E694A20B6E17926BA32815F338AB1A73996DAEF61BAB889712EB1595CA37FF9
328CB650AE4C8E2478A28257BE4461BF0D5737FEF579DD9719660ED0ECBE9814
BD19184B2C0F3B04B2D3ADE2358D36B1C5843C9C56FF9F371C82FE3E8666A274
B7837407112FEBE86D98234C679A1CA1503EEAC4658CE24F7DECEB1C1B140F12
19189FF54777E37337534BE8EA33D99557CFAD0B6155E5208D976A9561F7A2A4
AAA27D75E803D48EB1743FF0C698C2A8FB0A797676FDFB41E6C329BD746B47C1
0CDE73950A2DBF81F7C3B10A749A1436FEB54AC543F23B5BE8837EA00B30C0BC
7FF11AE673803E88BAFA313AEE8115D704B5EFDD568BD9121F52279AE3615F62
AEFAD538B644942B6B97E778000DE2F2AC2B228E0FE93C0725FB5461B64AC315
1558CFAD6E6AD8769DB78634FF04AFD1CF67018D820E1C9CE14CBF5AD328803E
19EA0D95C41FA4A5AF7A016D3C773E040312AA0240D8038F7E1537910E6174F0
EAA9A09F8440838DCF959C980609D50DC093C9E693265E828A441345EA5C4EEC
C58E09D037316FE19495581736B0FEE0F522702E81A866895E969D55D7711912
8D5486A2B3890E1DBD28018ABA77A5991641AC52D310C58FC911D294EE7E91E8
6684176109FD2391E97F76C00327145375FF48E6AC3B2E33AFB72ACAE119D82F
DA474FB08C08665B47ACC5619C8C6C5D8C908B0FDE48EECD9D12094F14B222FE
161C45AB7666C3FD122CF87CF933F558E4660C9FE5D440B33AE6DD498EB76117
B664EA1BE6377A978C1D21CD482B38FB22F21E736C4B6441404AC18D779818EF
92077DEEE932B208820715B8FBAE1E8134BC45C573FB02668AC5DE573D5B15D5
ACF9D3677B4963D4005838679F44F925F924FC9FA53E5448D09F8AE5C4472A15
B636F7BCECEA17F062B5FC6524DA45F0DA3A2D5C32B18BF4A99C62B6D732AE4C
EF2EE710DB3D3C578C86CDBBDC0A2BE5F6D17EDD30D2B1CC373BDEEA5E6B5F58
97445B471395DF6F39D245E0DD08587F66DBDA32D5E8EAF654E12C2E333311F4
DDF124209CF668B9F5C990DE3196B84BE792F51E17583FDF5E3B77EEE12722F9
712F9A88DBA8330981646E985FA96CD828D5BF0F0F1E39055E86180C7D70697B
73BFADE43A08916F06395BB9C8ECAE542B030A5E40CE081122503E483D12D736
7371EAF1BCBEBF03F18C2C839AB44CD1E6C92997949E07B104540071442DEB05
38F7B02AAE45BD5AA802C65011720B337658E1F16E079E663932EA1F9DD8C432
D525376DEB06EC5DD932D3A480A00C51EDFC213FF5D7E61A400BDCD15EADBEDE
3875523CDFFF0F3448DBFE3B1F87CA1A348D8E1439A4A3193EC28271DF4ED32E
B52BDA0AA3ED16B4315244E3BB451A99B211EEA2E39D248301548BBF1283D4DE
3FB0CC652E3A1D12E61AE50874A252291322ACF12EE7FE8A738607329268F44B
ED4E8D3809A6BD6549A52A6AE38C80AFB8C867AF2D622C3D342D74B1A0918884
7B2128EB8B139A5FB3EDF22977D29F3430FD313C4E64190E98B0FE3A2FED197C
64AE45F7A0B885BDD576555B4CD763803AE6795B23AF56A62A5708CE84F249A1
078F5584B2FCB41823CD2AD46279222FD7316BAA58EA64499CEC98B4259A02B0
3655E8D25696088CDE1323C6040FB8F2D23C0B2B9E0DFC9F87AD1C05B078FF19
363D6C5888293EB8B7AC7E9993541A3059D4892B72098784F1E01467DE591787
3A449E4ADE223697243EFB20D792FC6BA87AD98A0BAEC9D3F17AE9C76E605959
DF14405AD0EF2B7E4FB2E203561018F0CE7D66CF19BFDB13F27E7FA18B6D6EE4
E5D1A32026B5D61FF3F307630500597A96A072EFCB143FEB9090CCFA94FBDCAD
69C15420318F852377C83331457AA47AC07B622A1E2D08B39E90FD6AD32DFBD4
E8C89A9FA5772BD7C4C39C4CBD332E7A80AA80E1EE8040D687BDA0971EE623AA
36ABF581AA672B92965E2EBA4725344BD3C039A064E2598ECCF875E76448B6CE
2AAB255DD2B43BE1F9F2C316D541430AD3598A76E18A0E064DD8D21CD1AFF628
2FE895801149ACB1EE001BF7F7B9D40E8F60D0E38AAA2BC4145017816633A8CB
D002ACFEE7F5D477151CAEE30FEB1F0137461E02F3492EA51C9AB784C23C7D9E
4DA06B6D9F86098066056EE4E94AB573C5EF5EA99AA922229DEEDBBC97B6CA91
5CF1B05594EBB037E17185B4EB98C1BC75D4E9D2B265CD3A525E467DF8744A39
C95252F11EFBD11017F3064542E704A4824187B32CFEB1A765B7BDC9F704E15D
73606F9ECB8E05440CDFCDE52C300D8925910A8E0B3808EDE9D7D71412F8FABE
5A241F0BCE793DE22D2B38C930A37B60B63B25352C6B110A1E0002734676B2F1
EC4B37B197D9F48FBF8FFDD1ACEA5B74B3C14607E6E3AE5DF1A610191CA601C6
5991639A89CD5983959801A6CCA7A1184E4A943AE10433C513FEE21018F9C6D5
4E6BE4E1CE43DBBAA78BAA371ACCD0E12898D2C5EE4C57036FAE0CEE2D6A6D07
CDB7529BDD5A66991C520F8AEBA896DCCB922131733A201743BBF0A78C7827CA
13EB93B7DC40CA71BA8F72A4349ADBEFF33B3F676B23F92EB925DC8D7074E422
A5BA1C68F98E3B0C954193A950F2D3B376
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman8-Regular
%!PS-AdobeFont-1.0: LMRoman8-Regular 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman8-Regular known{/LMRoman8-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman8-Regular)readonly def
/FamilyName(LMRoman8)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -117 def
/UnderlineThickness 36 def
end readonly def
/FontName /LMRoman8-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-456 -292 1497 1125}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E7AC5E68123F9DFAD1150FFE135989C22B412B
63BEC913DA6144549F051416C71903E13237781A5DD70E8333F80D9F0E493687
94A83B2F049E14761EFE435983C72A913217C8946E4DEB22A9DB2FD68B53B9B4
02761774E0E713EB4A4FC9C587A325C91693ADBC62DF65291D5EB7BD830949C3
35DF08289D902F15122C50260EEE2B47E043ACF9EC5ACD0C55CBD5CA59BC7431
9A1B8A5D9D205BB7ADCE0B00796F130DE39286DF8195F0A302FD739C6A4DD495
117FF510D4D3A52986DABC0E5BDECD47E4592F241F4D1FEEEBD83FC02C54FFFB
57A301E60E5B25B0B2AB8D5F495CA059A6EC13FFE483B13F35B195D8A38806BA
04CC02C8067342BE4320A42D695854DB324847D78DEAE9C337F868E0DC1F281D
4CB637D6B16D59E5547364BC3C51D5BFA8AC7ACC376094D0067D963160AF7B34
5AFE3F8FA89E641F726FEF6C405DE255D7E6B93A68C93D1E807BDA02B030861A
BF781F4E12B373F2A268C710DC569C739BC2AC583053CB26E8482F794F9B631D
1A77D18D93FF3D3DF7C0DC6EA6922A939FE7AA43B8308936140D026DA9096E79
999C36B0DE7FFABA73582235CE49A74BB3BA9EA02BB652695A949F8E0587D5BD
38E51EDF4C987FE5AE9A6A5FCCE134D7F625BA663A61AEC4938CA78C49623FE0
EED33DA2D08CC78F86A807E791BC9CFCEB5C8DF4108A2F31940E5B6FA9B3D7F9
4DFBA2E7E60C1B615D0C774F1733C71B0CC90EA69D7D4B91920A764020A7907A
A29C1610A05FF2B714570697940A93D2B341E79C50F7D2C9A3C1BDA721B86619
A33A0F1EF6E18C3561948D168918EA5FF9DBAE24E6C0BF1ED456910E73F4C10B
29F2734F35E04F1F550C07F011E8E23D2AF6F0D7B52C2E5F201D6A990FC67A77
3FF5E12466692FD1B465A90F11032519ABC7C0308E276F190F7EDC493BA1FD3C
CBBEC050F7BBAB6E81B7FB2054E8DC92F54695C1588ACAE725782088E328C705
BE178689547E89215817838DBFB8DF7740107CE11D9F1E95F04ACAA904AECA8C
66082082F59CB8E5E7A96FFD63BF90F69931F3D5B5F81C3E234904D5FE5CCAD9
17381670D1548D72FE715FFA30FEBAC715513E0525049188B9D91BF7EBFF4444
ABA5490DC6A5CD8C1BF3EF1341A126980C7890794A85EF6CE32D227A9532B61E
E1FDB83CCE8849508A3EA0FDABE92387B526ED0C9A92315083DF5BEC01ECCC91
62D605160067EB251A8B40D3229C18FF655220D3DC72B74618CE98CDB7E370A0
BA04A0FFC4D3C3AFAD0869003BE33A0CC74D81D8BB0D87E5C0AE932B4309387E
9DBF69C52ABE85006D83B9020CC042DA9597CE1A2C03653896E07940025DD68C
11C8EF41CED336BB116AB3BE6175D6DD1CAF80144DD5D921D9F734EB854BE550
341FD8148EBCF4482E9D97738693472583DD53F4D15F219219825BEA068392E9
EC101A958BA3D4C45B156302AD722B13F05F71D8C40C2ED1766F45ECB609FDD6
6F3014B11E63D70CA13D96BD5AE19DAD78AD44C7C99DD91D71CC2A3E0EF74012
0DE42BF30706C80B42BB37178508EB5EB02F088194A4AEF86083F9A849BDD896
A9B2F6F431345964D7EC4F60EA071D0061F16D88796C4BA0C670D0E715ED9330
13619BC67D712BF7CEC27CE0B7ED8D31A29D7F2D8884AEABFBF6919D7FFD1E7D
0B2FA582811CDA7DEB06661A2D27741CECA6F2956BF0F2DCDF5326BD8683B5E3
828D8A7AE0C2040DE5F9ABF2B4CB8517A00888053AE978BDF45C9B464B9DA129
0584B298711CB71771E933AB92CA36C6D06E8D4E51000F60EB69CFE870326E00
4D436C27CC46EEF80FA1A05AB90D788643BDAC66F405924BF40E49AE3D7453C6
30FC3431FA13B333D69F672BCD4D19F6D70059D309B72D0A48EC241A28AE69C4
8B50DDF960297D39DF2B708BEF605075EE15741BE0742A7D74895BC47DCAA02E
982F9ED1C700AE14F72B455074678DFDBED70D546BC7E2C50ED4DC57B3D87551
CE86D4E2DB7607F065FACA01BF64480CC5A1E88D7CB8E40CD6C4FA69CF3A22D2
52AEBA66664944DB03B6DC1452701BF67FF30DFFE27926F7BC36D2193386935E
6A69C5868A268D1D3E1D71D757DE1530DFCBF7FB5979EF5F012CAF413DABCB32
90E29A0CECA45791C7D4E00573CE94A026B0FA081F6FFDBAF51A7673F6D60381
9A6EF16E2C6DA9D1EB555908CF057ECDBAD28147DAC67EB875748BAE25E1934F
0645BB84A6B098DCC8D21513741301029A9B2BB3A41F6D0503AA0DE9C012E610
B9840E263707E73B995B2EAE18188849E708A4E69F2C5A3E08AAD4A9BBC747FF
9A63EEB766D68A26681F75A165FB9D0C92DE633F84CCB5E4C8DFEC0195E99B6E
47CBE1D39D16881E6FA636A9B0CDA1509D95CA8A85A9EAA164A4716C56D153C9
6EBB269F3BA80EBDEC280D759C8B913411189CAD4224A4D4C8BE1515C1FE4492
D9383063C18A4DB69B44B73455D293113BDC0CCF64BA27965D2B38AF8599CBCF
DB6C84A32807C0BC46CFA13B270AB88AB7AC36E5075280062A516E93E883C04A
C3D262EFF193B26BFC0660B8A3DF7F12B1FE17E8AF3E3265D6206148C02FAD5A
125A6A7A6376AF4D646EB2A26E66C47738274E1AFBB463A91AAB97CBA9741C51
F951D86E0E4C62BFF030F461E614AC870A28CE055D4D77035D241AD41FAE4BB6
93A50E24F925F3A8D884C6E9A830E9148B0D9987F1BF8FCA62A6C6F745E45C34
0DB70968FAAED1226A949C78D176733CA1427F09CCC7D131A22F9DDD18A15283
213F9B0F7AAD043EA4F9F7EEE92BA769DC7E4C5AB3F50FE19F3A3904EC4C34A3
A78F5B436CF000514A8E7BA6FB5B44EC192D3FED3CC31D9AAC0C0C31DD9C7DC3
4C4784CDC350C8E81DD6435FC6A7C2B91B672FA23D9F875C001E76EA33DCB1F8
AF334B793677DC9D0D6B2CF2ED2DD23008CBB0A24F5EAA684B8EADC5D1A71CDE
74161A5086EE45A4C8FB699618C2AE3E8895EFBED6CF7509792BD183F5402C4A
A3E91301863DA4F8053BFCDBE68F1C2CD728BC91B95E7E66D0DE5659639825AC
78EAAF8F39D804D53E29C57A73059478EEC666E45CED43099074B3CE53E504C6
BFAC2BEF3663F1C2350D64791158CA280C98EABA19973BB596EEB41C7FAAB530
481B4AB41596674B6BE12B56A9E6EE5FBF33897F01997D214276B8B091875471
0147A13BA938FA06BDFE812F0FB311D0E9CBD331ECA61B000C13A681B5D7FEFB
9C0CD5A2FCEAFCB4B635CC9D88D8EF06C084C8DEA328EEFD604685676CFFF64C
9F2630CABF2F83D137D226B8523263395579F2B2D33E0A136C429A9D806C2CF8
AEA176A608FC51751104BB96EAF8314E2322C457EC60D2DC1454D461B2681AAC
16693FF62D9E03AB3AE26A53C93306F4A89AC8E95965A3C79C82898315CEE46A
6AFBDF1A183AB1941874DBB0AB81350F9F2283A52F8E07C3D70161F0724055E7
8899DDF3BCC34D14196EA4CF3C6BA6E9934C3911316220EFE099455232455F7E
A208FDE8268D1553651A1C434283570DBC57F42BF44CA3DC5AC833C4B0091084
660574D12B0EADD3B8305BECD06D47F6B05A5E7A47526378D488DE309608294E
D0A53C6BA6B301D3F42EEDB6BED24CEA54F2A2B020D2CF9F5F9F1FFEBC01C83C
BA3F6CB29E1EF0438DDC5EB12AECFAF8C4FCED792AD8C7B9CD4753C9727B327A
CED1EA729FBBF3D9C2829B9FA5A211732443B600E966EEB4D3F920E55F0E6BD4
1BAC278FE141FAF49FAE50A6507512690D2D5104B3992AB11DFE89911266E217
CC46FE08016C3DC5161B74DE04DA7417C7EA8C27B1E7BED385BA0DCD0C6ACE9F
E03A28780D3844CD4BABF0DF9B431F70B6C496DD25F8FA41BFBA01E07AE0F522
702E81A86686C5C030E18A42C47DD0FA1EE3521C98714EC451AB552F3EE72CB3
3BFBFED297799B3A802E0D2A06C44FD9C6B47AE6446BE3AF3FCBDE28D0DC1736
5CDB51FA59DA00CED66665A3E4D438F8BDA315D1E8670BFFEEC078E701707CAD
347208550DF890CF5924BC50D349AA5A9D6474F0070FE57D16CD12153DE8F377
028125057FAA5346D7DD91901DB0114BC982205B9F1A4F8D6982A23E22A3B0DC
696248FABE1876F93CA24CEA8F7E67D720CB772B840B1F52CBDB39B6E9E03770
5608D836C8E3B4CAFE23E8BEF99C8D9B8645A54B519859A7AE18783CA81177E2
6CF828FED0D16B16987D62B6EB45AF87F8582E18ACE8384F4B60393CC6EEA811
8F36953F38E8071E3C83667441D2CC9DA8A7E239B7882556FD131C4DE1C6C63C
0ACEAA1B0280C4A7740C14DA2F7B6B18E5BD4C2ABA9816226EB744128F41014C
24426A003A97B6A1A79E3CE4232E4A1335F1966DE7C21DF351097CCAE500C720
37F7B8FD8B789AEFE644F929E005007E3697B20F5554A12B671BB2CA1398F65F
D0A764A54500F48349E53DDFC59C15DB93E45AB8956CF7EBE3BDEADEFB2AC069
379392D74A6E8FAB207057BF6619FADFF828D9BA797C5A89AC4A0082347B4577
0125B5D86FF38192954C67F3EE4D176E0A4B84C9F47E5E871C676BE13AB244C7
8E629FAB784FD76372CA9417FA67F292A3A7AAF31A28199245893310CCD9B4FC
3546BB0240F44DFCAFA281E4E34420D1FDC40E678BC42FB3835475F09A83EFBD
1DDB3F3EDC5FA135479FC9FA2409826AABDB64A05FB14DC0296750D8A3D50995
41416B91533637D5D5F64E8448F9C661672919A4E35256EE97EB3E52F5DB2BAF
976C56E3E436646C77FD4DB49C5C9C8318DF97F8AE66CCCC01563769751AF1D8
079C211BD6F87EFF5C0B094245139346C89EE39E28C36FC9583A048A83F68049
C707E5FC1473E7DF963941DBD260753B64030759472D938C84A71C114A562378
0C82EC823434BFCFE218A4B5FF0264F1EC9818FC830913DB45A65DC61852339A
38D7BC9D8529FD28B575087ADBA0A53C05DA8960309A86FF0942B14D4A5F9CCE
2C937DC087C6ADA044012C43EC52D384C9F2D60F8105103B2EB165185E60201E
BFB2E1F7774D9D4BDBBC9FD28C206027B020024CB98169C9FAF20B76D6CDD0DB
A9DD35D0960B0EF0C116A96A4D934D0D15FA88CD2ECD441842C4DFC75455A220
0DBC805F99EC797F49979E2085141F9AA02D13551FC49C934408289362F2470B
36B6D8ECBC96CF880E9892434B9CED332AE162EEC85770D858109A07DB6D77D6
124D75B84C9804AC607A6777F03F6DC2235749A644ECB7649E334703291F50DA
8847B7343B7DFA9C744B3BC113A068977147461420540171A2BC01F60262586B
DD5D12A7922945D1C3C332D39E078C132A989FA4CEEB0C836C759C442252F2B9
E896549C80A3AC854E85C80C550CDEC09BDF5CBFC367D364034819F2B5B36DE7
C60D0218F87C92752A5993ACB13E7734163209D8269AE9B7655264E5A5CBFFFE
7514FCC78F39D622E99491471243E8004D96B0DE5B9F556A12BC37ACD579854C
D11DE161BBB8083480C618C1814F112EB44E247501541595873D3E901751AE85
872CD81E236B9B02B7EE66A54E3B87A92AAC7EEA79290016F6CE9EB2A7419D45
46DC6ED22A77B422E28AFA3499B1D859907AEC5BD2E149FD142E435C908DF2CF
A784EB1DEDF28AE7B07F30FC4E9EEC8EDC1A4916452575C7B3F7D4234536F31F
7CF7D9EABCB9960BD4C526766BCE7977A99B02FC88AC0C591F66241ECA8269A3
4B5441CC0CFCBC16916489BC37E66CCF943F77584114CFF5B5E4633099BE5790
E45A8947618AAE1C7859CEB157765BAF324E0B01108315E38FFF635A3F57C728
E8D8020D71C17039371C24BA210DFCE1D1388FDAA040A900CD88D739CAFB5314
D6AE10D4FFE56A86A59FFCC90A00E691EEBC3E6880A66D841ADED0348EF0A843
D0F05CE3F579148DC11181C6E9C4DF55C3ECC1B8B7230C668322C330AB17AD61
7C706160750A5C6E1798B93081C79B445A8AE3FE2921D32022B8FA2A0FC0F4E4
5FB6D1A0B2B781EA1714CBB8EF011768F7FBBA3E75F60EABD442FCC40EA91D47
117C01D70565B3C05D8BF989377808FAA8E35418AC833780EA85DD29EA8BD7FA
6074CD669B124A8333FC4173EDC8861F004219666B5B958CF632FAC74FB900E0
4B0B13B26BFA8A80D5650B240E1F647CED0B09FAA7834F6DCC041E7E81C90B07
39B9B54F8082DD9282BBCEDE2460DA6B95BBDE9D3B329CFAD949CC0D1B54E47D
44B887B403EE0216CD8A286C4D5CE74C0DBB29116D90EA1754B0F0D6DDDE2D63
0E602B38866A6FFCD97DECAC22CA7D4588DB4957DD1E286D45676C9FCC9C894C
FD8B51767B605BF15540DD278DF04F7CA22DA9640469563E12A26664FA20D07A
EF6DC4C3D25B0E6BA61F704CAA380A0E0D26C8811D02A0A094F82E5E522C468C
4529613CD7B585740A4DA7E6EA76D91FC2C5D9AFF98DFC652FAE8CF4B40B1DE2
54CF21F2FF33F31B275B5711FD6B227D212B235FE1AAD24686217338A79309F8
C9962D02AC7E64113A21012A6EA10D9C8D741BAD7871776B6A4EE93F170DAFD6
0AFF762601AC0D694D26A4ECEBF5B2E29A80FBA571890B36BD310D1A184C0849
13958D22575E85FA4A83209C59631C5811D0CC79DCC5C2D73915AB87E8E6A34A
62A5EDC245455943A3DFE5422C5E45E5D0CD32F824E5DDBE29741201F3B326C4
058F2438D94C9A0DA68BD8589F4D60FBC4C2709D6B1A188777C0EF5D26165773
A1CD1C1DF9A1CAD2BC6E812806D30B4821F1AE91968E0D8BF7908242C6E5F1B6
97672D1B35F7604787EA1A502B4222566D1A0C04C0B7C6DCCB7B5F7ABCBA1C7B
BDA621911CE65E6EB2296D1AA6114060D6F0A2AA7FA678C46C315839EBB8ACA5
0B1BE89222348D7CE6316C211267BEED7075B675167872F7A506F4B9E48A1FA9
00A00D64680648F8DCF47A989C23AA8A00773A6B8B40B27572914CA4189749A7
4DBB0EA1CFAFCDD853C0E36F6090974C0FF0D79CC68FB1A5DE7EF8497F2B33F5
BDD57EE4E0FF266F35E74C0043F6C8C98511EC1E2A0CDB853FFE0E0D5D4EF5E4
BD8A5B894D2C4E3C2722BB2F18E949930010080C12CC74EB8C5288E168E18C86
94A3AC394D141F7DEE6553BA479B6B5969C0D267A71A2DD12D6F5C59DD5CD608
BEDBED9AB15A643F7E1EA8EED8C819F9F7C9026CEF9CE1362B6AE20B9B066AA3
C20FDEB26FED0768C4B15D651FA8B720DC21DE0755EEE6F50AB9165C3EDE0435
F57FCCEE637518F5812EB351B6558152553C5448D09F8AE5C4472A15B636F7BC
ECEA17F062BC49764B9F20199F90DF5B338501403614E907DECA0186AA0F2E0D
C86B0A23689C1E26163F674AA342E00623EA376CE310DE9062984F6951B5AA2E
BC98536501922114CBBDF8C880C41EEF179A9E95A7B2A70E3A9170C482316B81
5E836B7C7D1B6B6FE2F8CE38A96655B073C606ECC2EF71B03BCCBF26142DB2FA
5FC7D31442097396CFFFE8F7284E7EE1686F079F72EEEE0C0E225B9E736C6775
3050CEBB0A6708A1C2E809B78A6F7C3C88C9691697816986F494CDB21B6C9761
64FC320F322CB6B2DA0E1594AB99554693CD027EB52EA2DC82F92564B809A3F2
D591D3F9B9F734AC514A3B200ED1151418051744E40FB9CAD1885451F815FF78
3CDE0A5A0B345E8350B8F483C8FE9B17F961F6E6BED4A1655EDC31C235D20B20
6326C7E4F15D6ACA81AFF32F6AEDCDF503383715F45158FEBE49094C3F985894
49C6B0FF73A672307B352E141233CD8E22D235B444547DF7D9B7F9EA1DD69057
1689F723340082D60B20DAAA10AA02B9A6E6EEEC07FD93D19F9C0A689D0E43B4
0D79A6277513640CC4E7992FC5B88E4E341585EC41E81108B629E81060CE90AD
F3FEE957603462E3090A69050ED2476275D5384CC384430A2282A4898258C95B
2F57D49D8D3353FC7DF3726A2A533CECDE6F53593320112D7A8432CA3BC75E4C
A0C1DCBB6CD5E7C8C131C44F718193599D9E987C17802C37E47BADCC1E0EEBCD
027A4CF6A0B098A756AFB05D546DF68D995036387E91DE4BCAEED38C8B1BBC86
66F4AB0353218B1EF2EF6FA143834C770479712E2A5A618FF3F138947E955240
2C34980EEBA1C8F911AEDE793A435F04B0A8BFEE7C64ED558A85840301B22A3F
138D3B45D2739DECDDCDED8E9BAE8EB472499B916012CECABF4989E9508EC480
AD837EED128C6FAE8519F181F4BE8DECF390AF8226AAC25D9B9F7BFB9FCC7071
5B5E938D01ED5BA4A6B60F45D16C05A654A346A63F2CA317C7C7F1E95499DE2B
D0CE29A976B42E89DEF60B84837A2C5E235B9EEB4F6961EDE03C32B68AEE779A
E3F1AF5A2B4936054E3B3500AC0CD15B197138BB6A9C5FFF29E429953217A45D
C6A679FDB1CE311BB051D5C727C72CE99281B406DCB59972FFBC57BBBB493F2C
1B5C38F173A5ECF467FB2E492AFCBEF4C8E9DF3FA6967F6F5C9216D2A6C94A11
2B6D4E11ABFAF29103ABF419D2F80488457D12637AA0CAB0E8D157F6BED3C1D0
FE8A4F802753BFFAAA9AFAD1A68A0C3496BCA768F4AF8016D7A65BBA3AAC49B3
168EFF4AB1EA0051CC413D1078AD46A5E7B7BA4F7587896BE11E54EFFEAF8F40
171C316F28FDDF8B550E3840637F1864CE423FDF8BF9B3AF739FC73D34077A75
7B96F86A71F96165AA3EFB39B7B13C5FCC011F38E348E2E564025D7176A1DA12
C5F127C127C759CE5E87C067C645782375DB74E88971C070FB2E12E5EAE345E2
4FF7A29AF208AD97DBB93AADBD6ED7BE07C01D2D490B72EC09A99E846384818A
44E541E4E108DFE5E2946BD38CD0DB6335FC4A6B27E683A4B83116D297C764B6
DCFA3621899D8C72270A9A4320E8DC181020981DDE1B410F30F7E8F77C2A4486
5D97EEB9EFD4AB7C41035AE6BE8508B137772858D1A89AD21A4DAD367B21D4B7
1BCEBD1B7733EEA500102E39529212B65E7565AC5AF02343C4D7977A09FAB0C4
870C8E6F613285A713A005746742E42507DB9E1AF76C75BC88E4DB3D178CD1E4
C04A6B041D888A84B1E8D03CFC7223A383E635AAF65CC7D6F86DC7AE69156F65
5E24CFBA3CCACD2EC564AF37894ED35B90B4ED5911988ACCD6357281BA264302
8A304E0EEECC3599F1FC77504661892F60E5A560333458DD227E62CDAC33D56B
118DFCC4F09721BD57C38734D3DB8B5385E3E4BEAC16954E2670695108D4D6B9
20B84E040C63CB915CC4BB5E507C9FD85B65CC1B53B2921BC4B6837326DC90AE
A08B8FC25115C2B59B1671AE16E0B35E28093FC3BDD29B3D6A0508F7C936125D
DF4B6D79703CA2EA9AFA59F879C1D700F88C4C679CE7F3C6B6DFDA6F1315B25A
F83F3C001D25BE4D8011E948916CC450222FDD184A0643CF73971096295600E3
5350718D28AA6D2B25E923C9A31379FDA9F7BFA8DE2C175AED0551894938E2F9
A863B3F62A4266E23A13459056C077EAE6F2F7D015DC4D520D7684646F54CEC7
6AC98678B54E6E3A103EBC1CABFDD80EE0D2A55BCA706D9B820D05B81C78F8E1
52CA7AFB47225F6D9519498F979AB08B72AB42EC156EFC503BAF445CF5BDD647
43F6687441C0DA178687006555EE19E076E25C4799D60C2CC73610B087F668AE
BDE88CDFBE97B8C11D95DF2B43C2C1B991E045743BA616B17CD4E332608CA2A6
999F8E27C6B83CEDDBC6FBDE23A88368FF7C7FEC0715F84FA77D3B65D73DB649
3FE38E0387AF448B9CAFFA4BC15B304C7446A71A59F056B37F04B3FF957F9521
0E59D0EEA9C3401B1B713E91C363CC73F203287F5B1708FD0685C575449D29B5
1B30154E150AD7DBE726E9FEB0B277D73B3383ABDD138A2812AC5E2A8EC75CDF
E91A4647903661FDCE35099B7A551426924C048EC228781C7A75A1F69DE5AD94
4A590CD39AC2346733918FC7A22B23D2574425D4D3739ACE775C6F58977185C0
7DF4BFF453FE60FAC91C0F1C634BC8303F88931ADEA3D4B800D58CFC32379D20
2E9FE870D53EC343C11F29E03DAF35E795A2D32193DC2E11E51EAAEC0F6DFE2D
CA95810E3E8A6F2D62624F8FE4885E026B5748C0D34E64B2F0B703EED4DCB43B
0B196925A0111897483D3BE91A069EBDEC20E7700686FE88CF8C9CC8C7329763
7FA716F15967558A1E2DCF787236F068F8AB4BF55153715473FA5EEBD150CDDE
2AF873F83EC677CFCF23ED940B3ED7CFA73F120911D6AD0C4B6C064A73E47F4D
7AF8A0DCF9F836D14410FAF6EB447EB37A3093F8BC87EC54C4E0C42B085B6516
B27A911F54C201E4F627816CFED662D19C21824CCE6C17232DDAFB2043F674EA
73C9F043EB73E6A0511F1D76A26E4E5ABF7653D4E191CA3B5F623A44BD83E2EC
4116B2E307AF675A9D995F60BF5F23A3216557921404D2027355631B667A6E45
E7BEC208C3B4A68B34E3E1AE0E2A00464273B91877B0B41FF1655112063F7BD3
D2F830E68C94E2B6B56F00251395F76708D5C94D3E2A485E4525DC31D736E71A
ECD6A1C35513264577990FEBB7C59A47E264165A49F081CE8273E704E0692FAD
692758DB653AF6DEBC59D7ED6CA66D9DC53F5A2A0C89BB0DD77A7E131AB9DDFE
6A5A10F02D98C706A82E351212FCB66B4CE9F7C58B813487ED71DD28C0C2CF3F
F10A09B396758316044F466A68B204A45017A993D91DABC2960E8363AE6A6F4D
8A5BD4578FD9B1D7DE07EAA36050E7E0546354A4B68267334AF337B596E4F15D
3B890F27A4DFF73C11D67B44B7BDB637868345AD88A7D1DB3387CEC69C9E0775
F71D7B87D80853DBDF3CDABCE64A20D4CD0EE7C4569AAC25006E96A31F595844
55FCA7617F2744370D43F5E2B9EE5862A0EDA5BF150E373526CF55A76CC97FA4
7FFDD7D89449CAA54C2223533E3493482391604EC3CD33EF1F0568C4B9219AD8
063ED4C879861B97A9FF87F80D8F8693448054C109EF02499A9EB93CA71FC9C0
D3222E949E21E25DCCAF4296A237E570D6EB12BBBAE986D79303CA403B71A368
ED4178CC13DD87BE8C21EB3A9ABF13F7A9C46B58B977853AC5A9598B71BD06AF
A2D779C29225888F5E2C23E1B4BE829E3D5C3D4D773182176A93892B3360A978
8FF7C58FEC4F546B31566D7C3F43D5829E6603AB0012BDB8BB9426E5EE16B5B0
0EDB7D6C76F14F86FF6976E61463B1D34923A19B1743CEE654C9C39665AADA2F
E3ECD8D94E943ACCCD35893686E88F8F127DE4EA963E2086DAC480444449DB76
A321ED1517E750F551AAC934621D32D3719C72C2FB8B8274AB54A6853DC67843
98A6BB0DD5DADD995E6E2033E6CC70BC0E96636EAAB676E724CBEB3762684C3B
B8CF107864C3D34C29F89C28469F2430C99A07C2C56AA0A1132E7923DAA394E7
EF44C3BB72D146BA8F13783167A9DA37A6E22E7C508CFE9373FBF75793D018A9
17B10B32ED08E7F6CE8675149432044907336EC96CFFA5BC0890A3FB0719A695
0C452FDADCA2233CB4BEFBF1EB66E2E910614F0C02936959E2CDFCCBADDB75B6
DFF0F66EC28CB8D9AD8BFA69E2E477BE97BB7C6E8AF465FE7C2844BF832E4D54
880BAF264A44318844990909604AB40535E4200380CBDCA96015D3822CF6263D
36E44F55442C4053B30A15AACBDCC8DB585D05EDE499689CEEC138A22AA5523B
695DC529196A79F159CF0AF48DB34315A5F973442115235ACAC2670230C67883
D29FCB7B0C10E0F50AFA773ED04601FD02E569626641AB9D664A70232F0EF82F
448559F8CB85DD9909A74AD691B5A4AA1A8B0E546835F9EBF4B1BC42AE15548C
546BE3E64BE682605CE4EE1A7A565F4212F5F7235A497AC3E59539E01FDC0E3C
957B2EEDB33AD06C63B767DFB1E92A0B711D0EF66DE32F63CD69865AF2014684
7A7569216427DDD9336FE4BA59140DADD4CB70313788CC991B61ACB6AD7863E3
0EF2DEECFCD5E0AA7F029F52D3308C57734B39E016FDEDA848A63B7CAD78CB67
365C4228D7404756AFF88FF10A172C60310C10FC124398414313C3DA64B8B5CD
A5D619E559067BC2EBF2FD59D7F9E14B1DABCDA48C539701A25DB30E22B0EE39
F7F080E0543FB75D1649D0A728732E3701A8BF70A3C2FE2263BF87271B5DC461
5D281B73F4DA92823A4FD661C6136913AC652F49975BAAECAC0E7D82AC7CFDD8
41F846225BB316E904B71922BC9474D03BC93FED60C902138DDE155AC5F7D9DC
A52F5EE2BC41E415CBEC45468CB483E95A690A776E288BEED7010ADB1076B232
57F948435A0A1D354C0AF52388BE94F3F9B3AEE160AC879F5726DA61EC82C0BA
3D2AF8649CE5AADCD3CC336BC012FD2C4E34855FBCC2E72B7679DCDC16C306CB
AC3C0663A120E4F28F9F4A0FCEE7B11A31731DE6B46EE9D1C3D61DB36C4E1984
C107C8FD9285F08FC3C879AE6D42023BE0EB0DCE0CBFBD33673C5BA58E2B0215
80D63C76BF196393628BFC2C330B4F75B2FB0D5A087CE736B14E6BB73F4BF372
AFA5C4A05A721D82217626167E369AC65724E0E0764503E7291357E4C4F9A672
5247F3ACB290054C79127E87094BFD77579D3BA8BDE0813D641BD081EAC8AC5A
0B1B1B140F1219189FF54777E37337534BE8EA33D991010C5EBEC25E048C243C
C216AD82933080F74E7FF4F5838660536DCC4F9E890C18E8E4AA4B404CB08B7D
B3B822635C39B92C18AAD0147814BF27C8FA6DCA0BBA0FFA5359AD58F6EE355E
59BB68DD231AA12C325917C9CCFE8C05A03835605E573A5E9DB59361545F5AD9
8E4A794339B0132CF741AD7BCFFE1FFFFE8F5B34581BAC224F8CB6E7DB6D9AA6
689BBE293616A6176B8BD6BC657911886CFD4A244D9C62352A2CF2DB8831D815
BFC5CCB48C39254C760F1916817FF8ED4A4D2A8A6162B4DFC3D2A17BE75C34DA
0AC42B92571D1CB295F60D76E01D14A8F55483013CC106B56125EDE0D8FBC735
88593FD61E5A0DC97EA2E4AA2D6C07BC29765F19A202CAEC8CBCA4BB45C49782
D9B2884339D885C6091E885A427ACE9890EF519FBD740A4E6663380089C1C890
13E47E2507EDD79BF25B181AD308D29C23074544C48617A3CECF4206E3629520
D3AE254B77057D96CFB2204866D8B8F9041C564626D94B23D6B63755279D438A
287273E8F583461AB0B92B85B73942EA553AAD6E4BC7361199F973FD9B3746D9
83B0BB9E1675AA41B9F6713CE19B67FDAE1B24D89C50C3C54B4136149F76989E
8C5E52CA1FFEB7DF2A7921D57603B41B9AC5E0FB1EF3B024D8E0CF410380BF34
AC17B2E42C84A0B24C1063C6147B3E680C69348DE5BC5F443EC06A1BBE8E6481
A48A9E0D0A267C9814C9F50119CE994EB691FA38948F3C1F7E3BCA79E878BE93
657480EE0B20A204A829E167AB5A5F79284EB978ACC96226775B037B92080453
2521E7EDE4696D5860671187A075E0F09CB31C059ADB0351F9DA69CC08DEE1FA
97D2920568999A59AD14685C049D0ADFE3ABFA8871E73CD14B200DF449FB9D09
F917E5CA703C7E92E1BD2B6E39E53B59DF689B910BDA0A0D31894C3C4DBF93DF
351B62952C6AEC9BB506A5AFD9D9C202A4A34D52F4B1460E41AC69A342C663C6
09417DB14DF4082A54778E94C6E4B4BB39726EC682E85BA7C7B988B0CFA983FC
AB9B2C1BB525143CBC8BEF7F9831A0E0A137ECC98C6CB93C3142FC5C99973AF2
11F2A2A05F5A756073B85FE8792B86D55DFE985951304701D12D3A66EE38027B
F502A36E4B87D76459808944194483C1D8B6354B2CDD077F222C24B661713294
A95BC93A85507348C08215013ED6ACB0249616263DAF8DE30E99B6CD54AD4C1F
93701CEADED92F08424BAD2A76790BBB18E9A73A3AC40F568486F7DD5443116E
4D38C565127A5E1F4A8C486D974A71CB8C29E633517EE593A104F3E07F80277B
E4E8ACDF170994CDE5DC0AFB32A9BCBECCFA292AE5BA0FB513964058E30DE048
2714F6E6F933D8422CA28FB1C0BD55AC360F8CB00472F160B9DB1B4A2301F1EA
27DD7817A5C161B0E1876A47F399E09D4ED56A73AEA5A2B1D5C4C6A2BAEF7F0B
809188CA821FAB51B444154738A54B54934509953BCA98CB824BE6E3FEDA2482
48457A91624203BC993409CD3E28E86F10868948EE507B47172D7B52B0982803
E19EC6484CD39D18A81F7389979EF408D778E57338EA0B134629439E6B8AB2B7
52FBF5AD056EF2A9AC6BEAF1A2F42D96C36248BA8AD72B6782887B17C171AECA
A006B229369CF06A6E34DF084EBBB3DAF7B5D21F6CFD57C052B2525A740B80BB
8B3C209EEAA6A4B2422F75140C6B1693E8F11832AC295BB1D4ECD9FE817B07AA
754B523B6C5A5B7B1FDDB27FE8CCA96BA7BFCBFA62794496BF380BDA1F468602
B32E6EB0F0EC43C9344593E34805056294CA6641B9CE61C958091ABDF028ABC0
67885B5CEC609B3B8E9F9864271F8A4AA5F5D0C34BD4B4E5561AF40EA385ADE6
76ACC5E3282A3F2F35F415C5B593CA786F57CC222389354F9F6F408CAE1E4180
3749A8A0F7D3AEA2D3586D79D5B248F2812B349367EBF83D7E1F335DD114F814
92453F5050DEA499563C86523C08C94F417CA514CA597A7973DB0D3A6929C870
6D29C8F9469F07521A63FB03CBE9183B3F48D68850162A7AF46762375B3B86AB
4FA930D1B50C8AD964B732576A4881AE9CEE27DEB401BEC77347A049AF60C860
AA9D845C3EE9692A939C59A84F7612738FD10561A78DC0187569098950EFC78B
5050682C9EC67D91F7299AAC56823CD4BE926D0EE4E8CD070EE6AE9271978280
C6753045C840785F033D885B728C25DFB3E0E96C71479FE3A4A5CCD867E5357A
9C218E27BEA2C25F2BFAE740EF719D1C27F71B50303BFB33BE5699D7932B91F6
629398A701E6BEB6D52F1957018202EBF835F73C6233EB98224973CD08AEE3EE
A3D66C3C979D1F573109C189915E0CE863C36799BA1D959BF559D2B8E46D00FD
0985C57E723DE55A2ABED9B40D7BE674118BC85A820CB89134E4575747438DF6
530A3C9B160D225ABB046E9CAFFC77013F4B7689E4DA16C4AC387CC480488506
1333608D46B78A084192A8AFA2DD43C672552C6EFED8191B8839074F73F9FD61
88C4727BD199CDC8B4D542205C940ADDDBFCAF37BA2500213239F12DC7E00B64
B4C5C8E46642D95E4D5E8DE9927E16E5582217693A530406F803C21AF93B4DCC
5AA19DB2AB45BF264FB98953596E755E73DF40B4E922D522E2CAF63FA0A8D22A
F657B16B54773FF3E432D45103C75A2A0537B9FCB7B78BD90BDABF6E6B3FD434
FDE1329BEFE5A0C84E397732913EFA5E6DA89722A7ADF729F45DEE8F3E99966B
A0D5ABC11E6C5F38361FB563378D8C5CB7F8729D436B65B80B3B65370D3768F4
E5FDC99AAA25AD6822B22B9CC8A0E12303B36FE978B03C604B50A5F91C47346D
E482B3A922A0E91408D5756D66B87C838592437274AAA30B1535E3FD373BD2B1
592F80217EFCCD59E2F43F1A225A568F8A771E103B18182CA876162E87AE32D5
F435F3FF0B01F6598D33E44DD04F6367E04C3CBB3400BA3C1943B874CFB2D7AF
9D861C5D5F0BC58BC526CBED223A031BB54AC96788F939E3774A65EB9D4782B0
B8251CFDF3D178017820F2D0ED30472C08BB6064B355CCE0805A6B7C6A9B3D93
6151CC6D7F485E4E870BC7C4BF3CB01AA002B983934DD7DF499EEDC5920F3798
5232D8C861F0FC7C25DD5AC81B0B6E9338E1559BE5FAFF381BD82A6C71C26740
94646EDB60127EBC1F408930DA173B4CA5A62F687C9C0E21F3144535F0FDFF08
0176C321F77478E1EA7C8D88CB58CEF45E2458B4AF11A7366C4FAB27ADC304A9
9639761F87BC27979656F1A784A31205E7FCD7CDAE6896C7ADE7111028A8BB64
EF2EA43D7C1FA208EF44EB316981B1CBEC41C9F40457DA1B8BDFB99D880F1B26
12D509E1A6263BA5639A90E92E0363F0B5A7A6942C8552F4AD90CACEDD8905F5
42BD304D2D1798BABD827BC8A689C3C3507EFFF2971730371FFAC10F5AFDC7F9
B3E00D753AD1672E2FBA745485880E6AE8A4F4C694BB6BAA955D9EFFBBEDF426
2100ADAE07838F53B0B7C64331A13816323CE98C0A44F40312B91E66F516835B
7EDF02BAE8B740656A02EBE0C2E2442F285A81A0DE2767675387CA88D3E224C9
E5E4AA0F68375EA6894B275D26BBEC215C81BDA1A9E6396A592C606AEDA97EA7
194967AF4CF6DF30D6963BF4D2BB639219910900DEF856C43D283247162C392D
23E79518A8FEDD636BEADE3CE20163B38F6CE760A719D1E9B7F33FF2DECE0163
2A1A1E5FE7E08A2CDC45E40E5DBF84C4DDA1D8C89CF7B69B3CAC447A2D2CBE22
433B7492CF32B6B59E943262F2E6EFB223B25C16F0A20E27F57EAB17D146FD2B
6C69375E9E0B1B272B51BB1829FEDEA5CBC466F243547ED3120BF4959153CBC6
3778C1315F60A208A5D130F81567439AF718D3B7B02416DF5DECABA1FF77691A
A267859AD4C6FEA6A5915F4BB60337AA67EDCB3D314D27C43C08B7B723B9BC4E
B7C9538A2F8957401FE8BED36EB2C52BA18EF531DE09B52B7093D785F438095E
5AD4C8278F0385DA62ACDF1DE9348FBDC32A12AADFA6B1B9A16C5F1DEBE19C1C
27AAD6EBF4CBBF8A7D8A0932C81E373C26C2B8B8A2A90B6D6C9B00B56052E8D8
1432D9B107BBF43CDEF5D2A41B5CDED1A9D574718B9EDC38DCB6B3E5B2E3A3F1
14CD151B2B93F439EF6E900FCC5592E9E7357B597236A903ED35AED9257EE677
F1F27A09BE521E7C994D1D49ECEC8ACD83D9DC1A32DA0DBA2080E21E924E15E4
80A3148A7DCBBF61ED7769F5DD218257B81D6C955061B4CF384887BA2A9A504B
2A0A92D1472147BC82CC947D4C7D771A71AC1645EEC33E4C86774BC4D3A6271D
D6C27CEA2D32409DF97C2A92B344786C67F0385889A6967942A943FAB5E5B26B
8567CC9606DBD0A38352CD22E77594549E5810ED4B2A01419CC245078082F137
0268AB1F0E9E41C1E7B82193A0F5CF51A673F9ADA89275D3947828C6A9675B8F
BB5ACFB75A80A16B6503734A510548DE1788FF9C89DFBB823DF700E40C28EFAB
D4BE7C8431A12536B4640FE61DF82B5E597B9C20D9E72206E93022A0609D842A
CA6AA03E96F8C1179518479565A36B79DE786773EA72EDB7BAC84AC54B45CD26
1604B15334D99DB727A758A924BE0D051BB73DEA2B8D2CE40DAB99A669F70EBC
4901DF9C5469C868EFD492731BFCAF203B8009E97A7707B1CCBF6FFF66EC1EB8
714F7F44BFBB41433632A244D2CE10DDA45FF84DB78BEB13C70646123162295E
5C1B8D5B1F8E0AC21F2EA065FA81ED9E1615938B81AFA5C99B02AB37CB7492A3
032BC299E1E0C6A18218DF587BD534F0297E3615F4E68DB6BD2AE1AAE0A81376
F86BCDDE43D2EE0AF274AF99DF6CF3614DC62F0C46763A0BE692D47598441E70
11C41A695669439EAE704970FAF1BCA49C711F6B0E79594F1CA14632B8CD0EF7
B323D3DADF42D431244F0A759F69D60EF70620125BBB8ED3011D4E2E1A18B3FA
3821FC62C3CBC825F8F60761CD44A5B455EDDF989254D0A7238555FAA6229598
EB54F16863203613AAAD505CCA785EE521B5D53E4F6D69D3F84C44ED4CFFE889
A9470690AFB8ECFC15340E1A9B84991F3AAE219469E3F323439BF51726A76F67
BDAE3220D2D2D7E02F4D95D8E30FDF8339ED63CF34CAD130E0880843F700FC1F
6065FA37F248AE52A1FBA983C736F12DC9CC7CBD8B3D7488FA3187A50D1E287E
005528532253C08645F0BE1E25404BF8131379A057266485F1C2F842EF5F146D
57D0287D62D1A34793E173D032F161AE017AB7E3A91418DEE48399ACBA6A7224
324C88FD819B5DABEE0776B1A98FC2D040C14DD87114A9B084D7324596C4587D
F29768E6F31E94A1C96D41BCA87F4230D795125DBCC3489C04F227D170EA0C1E
8E021294FBF579DC4BD7D71A5116E10B5BCF752C369CE03BB374617CB0D89B74
A174C6AF59E146AFD5B53602750F77EE8B09F3839574A5B0C840E7B69617A157
AB0CF1881601EF240E2838EABCEF94344ACE8D6A0F557143AEE3EE3CAE154792
412FD0F9478322215E9F59E69396C35AC4097C48D66AFA446E378D6300D9788A
CEC208CF1CEE59A30E387E4067822AF1D7550E5E7E677064F1C1291F0B78C201
65898565EC5A3E0ACD13B07D4110C5EF052E53560BB5DDC9D52F01753FDC5EBC
B8388014947DFA87EDCC6CCCE12F74A60AB7B789DAAEE741EB538E3AC7E38B33
3C7B2E51E8936212F232DE54F659A360EAACBA07E9AE56AAAC654B31E74B4C68
45E3E6B8E600F5C6F70C493018BFC93E0DCABC26DC1B8FA3FE14E2B233569BFF
15D65906C7B9A952C646ACD11485A859038696FCB8814EA6FDAE15BD2436448D
F2CF7FED61BCAA295453173D7DF585741851AFC02FBBE3350234FFC2A7A209C7
E1DD959DC6DCEDCD729F65C26996C69E6486DEE35F247C439B8FBB6DA43C2B03
60A20360880286CF5A98C68FB3334814C8AF670EA9AA8B6E77856A3C6A7B37B3
9E92BBA5C42182D54CEDF845F1C42E9EAC8E5E51949710ED727C5D7E7F3493D6
4C64ADE6A55284AD768E0D17EA1EF887E36190E875E72A697F4A8BD963531110
8D162F9B7210012EA356DC107F6DFB6E00260EDCED9A6FC8E5B7B915712E24DB
D585F135BD8E491D8F710C5F31260C5AD761E6DF3CFBCA6C029A8E6564460CBE
4D5EE06C24C4F502E4EB60250D3B5714BEFCCBD19F5EFD8182629081199D09DB
775D7C76501F3FB432D886A12EF6332152F0E30D38E2B0F504BB8EE5291006D0
4DAFBAAC1CC0B2135AA84626BFE2CD17DEF45CDE0864135B202DBF7983071104
BEC1B29BCE1E9E7A09327BEB82BEC7BB8F1C1D8540FA065E4DE1D272D9C544D7
AC4EC43D61AE55987BF22378DDEBB65571E3741842C5343C21E274982FC4D3C9
C087AB67490BEDA565E8A75B9FBBAE5005FBB62F1934DF397035272F979D7960
71E2744E63A57DADC8B74446496C0A7A05E9284D88561E43868AA57E53EF5EFD
E42AF4548806DF779E9341DCFD25B33CB1A8765948A07202655B9B2B756848C8
16DA10BBB4482608B049A940DD7C07B609FF8B63C6F84A94C87EECB536C27FEB
B692D46FC0632BA494E2789FCA096DB81ED1A44F39DAEB65CEDACF22B781FB2A
921F3202D010B9982CC3F67BEE63CB585BD427A7453E697F2D4D2F5D53ACA68C
542E7D45A579C9B5EAA32A2AC951481ED7C692CF08BD1EA6C5B30BE280953FB8
F82884E3A4707631B5ACFE00F965AD38C18B08D25950D3113C4F8E8BD12000D5
559EB14ACCD6ABCCC5D383DF70FEB8ECBEFFE4CF601201BCA873688F3FE76B60
E3153B06CBF22921C4370F23DBCEC97E357AF5F94D5AB81E26D859FDA3B899A5
7C0816B25B275EA53D953E61DFF5842DA7D5FFF6A22353EDCC22E93D0F4E0864
3B54999630ECA27C290C4B07BD042277C28130312B636501F19610AAD3F47325
733E5D75A616A5E375266723A462105E30763ADBB1E452D2C21AF5AD8EB18F8E
814A2814494DA0EC487B691D0A1BC41AC444DDC84EF818060F4C05089C1E647A
75B31F88489E4CDD308957A09FBD40723A05C1F5A791490C32785858538FB979
3E0F61F648EF2A0C6BACF948E98D29500AAE888596D0262AB625249432DC7611
97D0054C382800C28AF3CA811218068C3AFCE0E7A8D47D69BAD17359465FFB90
BB57BA5514C161507697792826CF7F95E057A71F653023A1524A12E3B7991D54
782946A17700CD6CA22A69EF104FA84EA7DC5155D68D07CB895F969E8B53C040
3E4BA6794F93AB919D044B4B58AC8333EBA1DBE770760C700CA6D612ADA57D5C
F598FAC3C116F69A81EBF379FC0DA0AD60FF354AD6D30165D25BF8E03E0D8D21
CC3D219702C791BE64960BD7E3B3806544CC2C714B9AEF4C0736C9D40573CC05
E53CFBA93FCC7E92DD84206960CDE2FDC72E480A3926A360D9932B81CF2C5ED6
56E2CA57CEFF63AA93E01050FC5006E25BA750372C86A036185BFC21BF840BAD
A02ADA33A74E38C401710926936EF0908A0C47C11E5C59D1EA53FC5615A35253
D968BE418055CACA35CC4255EA714B77B1F0561A37BDFC9BE2C4005AC52A570B
9488225CEBDA94C49A657636AF2D9702BC4518593FE4163C8FAD6BE4A2103364
B6AD954A7CADBF9DE647CB0A2D8DE182227D1C69494FCBD2F3B8C9FFC06EFAB5
9D37969B563396178190F4E341C9163B0EA0B6B3B124C5607F9FA93DDE49CE03
8EFB11F764EE6FF5F2911276A5E1364C9B926AF19C0DF70653C7EE2E1B9617F3
05CDE3E7C4ED843CBB2EC1D1392AA9121679BF791A6809164532D7CE3126709F
F083B86F2B04A4FCE9C00A5845D1C7E8F51710B4F1A4DBD8E6BF4B8B1D1A95FE
72145C6A25C355CF5AC97D9C34EF16317DE90C690DC77B1CFE39001B3230D879
41B6B7E9466DF794AFEAAE2E9F600E5BE1D7A929F8C67001C5B5F537B3DC0BE7
DB4BB7146489C3F2DCC3F43E0FA99CFC5C89200A16E40C281FCC16F7C9725AED
3342A33794670A88D7BF2CD7D58538CB6F1A527FD75D75C300CF0FF42ADE1727
30371354D21F1595BD946BC27640DCB069DDC07DC84CA8A62F9D15236EAE30C2
A42F080B4E1642BBEF309B14E9D9A6736373E8E10B6C92AD03FC30C76B0EB28F
D20AF1751A73E37D5200F5A884569CC5B545E6D36223AB972791081FE59397EF
9D69415C6DD7623ED70E3B8BE0ECEE39C54556A4D75D6F5145C5DD5771CFC193
2A19D7626D40189FDAF1286142524FB20749D906A8730276B538ABF47804D3DD
30B4A96EA7AFF4868D26DEAECC45B962A67731C7EA83A6042F0985408C6C9516
BD95F04DE18003480B1A3D5B9708E0F8B94A6179D5B52432B20683010D01B595
495B716758E8C14BB7A06DCFC4285BC5161F2F7D6B4950A39337710533DF6B98
03D589221FF6A160FD337083C1550561C721344E73C74148C1E8613E99F6B78D
81ABE86B754F6E599939B1432225CA439D6BF8ACD321FC39388733CA1C0B86C4
291E60DC73CCF8E1F76D7402A05FF14547300FFAB1FD39409175426C6EC228BC
11C69A884657E36271363919B140CD6DB9ED4184A56B2DD3F25D5A9F620224A0
A463B7BC2C470BBBD0E4367556933433DE557922C20D8C1D4BC1F344CBE90F15
495FC0800761A6A974597A6591BB772B7C2854732D7F9CF8F0CC740618BA5DCD
AD4693F4E17363864CCCE0B78E16C2BC75772E05F668E491182D78018466DB26
E0EDC30B2506930DFF22B41D6C75698D18ED153CF2CB9E52946ABE4EBCAE4B08
3210967C9F4EE52F4B02A5C6A8EAA948DA9BFA7CF6A3D8C46514C0CBCB2F5EA4
6AFFF46C8B1A5BF8A7BB32F7D29BB515DE1F0D5FE36069BC9164CDA5DCA33030
A51D088797D8BA9A06A447948B7B9AF556650BCA2D9F293A6C9412681042D76A
DD5D7B55E7FC9C1D6B873749AF2C1C09BC37D51F5DF6AB2944233ADA378D99DC
A7283BB1F958719392C09593CACC8628E1B6F5F8A48A9C98B34D79C81D405741
17146FE2DC854D6D8A8B12EDBAC86B03B0187A0BC417AE51711F1E3DD111FB44
995CE3D1AA6A444FB9E9F623584E00F2E103CCAD60EA6658FEE3E21C559E87E2
B7A5E66258E966D13A58ECEA201FF4CD0948C0DA198AFA3064238E26315894D7
3ACF164B9371CA485F2A947F322EDC2493919CB0BBA1CDFC7B05BE85D1DF560A
3CA37CB433044238FB747EB6E236291504A2A7C0A4EFAAEED1AE66B455311148
7BCBD4C88F0E19D6E2CA5C01C0310BC2FFF16E64D6CF312EC03C040C4F4C1B8C
AD65B593E1E03035A656BC2690435AF5FA6A10926CE95CB6BD7D2C70960F09F9
E3FB1510EC15431EE198AE7772C2CD65E68C5865CA7006E6C9683DAC95E3DE65
CFFD198DDAB74D3DCF35CE7CACF31E8C1D859D45F35E20C5554B0D72C262A23C
CB48B5663BDCE776AC8AF5D3A9DE88C7D61C01B842371D586C5A4D3C3A0CC1CF
CF4A01F9BEFA8EB263C089CE1074C82E4BA4004559544330668C1AFB2FDD4A72
EEEE8CA210AA8174F4D2E991E7A981F856409739885A994617FC357101308BD6
2BA71A8CC282E6E4F865AC8FDF8DF56A813D10BE69B19DECBD09D239CB562718
A47A2340E21AE06D19D1F676074355F7FF6C557B3686D801E54EC5ECEF84C6B3
0162242B3EF7756A035C0529533E59108C550E85D62CD92F6E1087A57378BC5C
B9E34C0EA2AE82D3DD876AC1A68E635E5768203B7369DEDEF65254488F91AA36
F910D0EAE72FB04C6D2B44E497D881A16DC7532F7C483CF78D98C0B0F8D853A6
AB8D32FEDF1A11073D679699A2A95446DA7D8F3577FD992B46486E8482D66A81
82466E40D1EB2B71F11EE71DCB66D0EDA9CCBD2A7ADD75476C6245655E2A5531
43A2C547F484182407EBE10F565294A1991CC4CE97543BCA99F217DFFB1D50F7
235376BD10C994549D271E1D035CD02F98099CBBDFACB1756BC71A36AB5C4F67
32E4D5D1EDF0D6B90EB77DADC3A90F91F35C2F983AE6A4AB07D283706CD7EDC2
FDD9B6FECCE76B1D40A2C813564C19DF23559A52EAEA9F42BFB43E355FD131C5
85CFC8C44C51B6C011B9B967D1BBF5C3004166BA50CE10680C308885134D6FEC
55DD2D0C65A4C4F014459D696051774D55EEA20D9B956D426580CBFA62794496
BF3E311EDFEC78122B6CE52DFCF82F1A578FAF1838161382271B04EC83BCC38E
6C2346B9D2FDFAE8DE6FF95C65B7EFDDB35B729C79E1DE9CBAB48671D1A36766
DAB163F3922CEEB03957A2AE0F68791140F5869A9B15577DBC2040566B128442
79398F7D180E7EC0626AA3139FB13BC1A667ED923FD72084F80C2C1A3E519F1E
4A8C8584A38E57441717E3F51F5EF7039DD184011B7B7F6505A11E4649F0D01B
DE8751771D1E94A2691739B8A83E6C297F7C6DC52BB1354BB24316CD7292A305
A7CF9EF256A4F7BDF763BB1ED2EB04BFC8F9B23D724A564559DDD7974D40712F
0163DEF0EBEA03D4133B462A15A9186C6D7CB63C596B0D577B24E114F561E21C
5F81B68BF0B9EDAC698863266D7EC4FD6A1D6D8D1B6DB30D674067A02C645C39
CFA550E6DF01593A14001A68D4D76F8B8479CC7565A1C8C104DC302AC8471A75
A54A9F5ABA62877CA3CC4F017515D1EC22573A765001395C851D5B100633F844
AB0F96F1FFF3C0ADB4A63B99930B70AF8F87F62CF81E9C990A17DB0EDF2A084E
7A3EB215C17570F87FEA1FF3167597A4E9FD85E1BC8FCD58CEDD5B6DE63036A3
585BA475D84C286D85B6CDF0F348A9853F0BE3BC2513EB0DCE49FD77579D3BA8
BDE0DD9ABFDE2D08B847FC4777299D957FB0BF5C479058FDE77F28DCCC21EAD9
5A080C6E06E00E83428532B8C684D3C9C365437CB6EE53B215FEF58924A4EB1A
750C95F89CFA10C3CE8E1069DC3F8F4694FAF25CE6C3C52266B9571E8AC304A4
81CF8A7B862AC47BC1C28BCC10F3A509BBC237C3EDF7C7919182CDC2FF2A21DB
C9EC10C2B121966B6859554552B5952AF469A5898733F7B6DA5AFDC65199028A
B36098E39EFBF340A7D53A6774323AA4424249D1C3CD211174F965D1D0F7E0A7
F7A93C12E3821201FA392EE0172602B6FDE34DAFFAB291CE7204D9D66A0F8268
D4AAECD6417DDDADB6B31FDB14998C197C0126634E2D4274DD25AE37082F566E
73C4C3C500CD798E325C588B5B71AA347A2C6A41E086DFAC2247BE094A885352
C70B1CECF7E6AAD23C6AD9A3AE11C6BA897ECF13CA428076E6C53C0BD9CD7D1C
12433ED9CE0AF54C73172253EFC739D751D577A4F1EDCD09993D20C046089A98
EA5B70E06CE96FA595F1638DF4851784EB30CA1C58CB167D5481A1CAA9CF1561
34C82BC2BE6F136D0439FF5B2585A53C7CB0DDE3F7007D6DCB2A974E04CDD341
41696BAE8F8DE78320F07D30FDEEE5F77E621B130E4B824CE23100BC08DC671D
83BDF56C9BCC3D58D6FB6BD665B77DE274035A7DE1AD88C11BB40377B0614A31
A24D8E6470CB7157973F561F9C283F781673F441F8E15FE89C0641C6F08CD733
6DF15A745D3ADDACF72A6531650DE680BE7AE13C7B18CB980502D48E67906123
52CE634A6E161FE4A4780E85F5DADBEB48B6289DF434CC3B75118870C05B051E
3DA7AE134145C9BFEB0E526D408712B810070AE4EC29A27DED0A252F40A609F5
13EE630DB0A4DB43E905434845636BBC2B8F77CD1CA62FD7E5AF7951EBC52405
D304EAC41E27E9EB78ACDDF9B6FEE71DB7A58198414DC5C0F5DA378CA90CE608
FCC8C5D9EDD0C81B630213486634605FB2DC8090F2CD4669680E1BB64E758760
3DA8F72733B7F3B44F48E78519E114A8BDC93D400AF7115D22C038283E870A8A
1B58137E9EB8E942DD70CF3A33E05F8EA1F87900ECCE443EA7466BE48080A4B0
D23FEB2BE5AE5EC74743709CFFB7874CB65118C8A39C6522267C021CA4C0E99C
A14680147D8580979FE5FCB204DC95F10D6E5571D4EF1651F1203694BD7EC943
0C3C2F7970B696DA577C214527E9A5EE638F8C21AD1D13D18209F1219F9A1619
C6D86621AC0F8E11F72D917F2828CE535DA2D0F052EDF14B23E0389F82169E5F
E0D613468676A21638730B3AB634985407BFE1D6D0CA544386D209958E82E39C
166F96689658A7C9F352DFF83B4D7FCB6B79C54E4F1776B782CB46CAD93B451C
F6BC41F06633E6CA268D547FA3B451C7F1173235B1C08B9CB270E509091C9F1E
16BCE7D84470D790CD376B60F312DEC324B31B9925463626648DD1F190B70EC3
57B350D466B4D20EE132FE168BE61D4FF9513551F79AFC8EE75217B016F08681
20D7025EF368F3062D2628EA70F932572FCCB5E6A0B770C94CD995F8DF541306
EC7F988756052F3A645121F2F29F2718ECCF609D9F948AE0E5F5B23495A54199
A34F6660AD533C27A8EC75E975739EAD6E35011FF6D197C9BB1EB31D4CC8F70B
BF39971CBF0B811DA5D04537013938A2D40A6E0EC74D3C8F83DB12FF288D6C50
BFEF1191D4AEE04F231AE604E764CEC22DEEDC7D76AD4AD0963A60E2B212ABCE
0EB67EAD5D0D7757AAEE2DD1F33F17713B5F677D42C61A15CD072B159AF3A584
9D6315678543443814E9D5189F81941F4DFF68E997B6F7BEF0C52DB9469CFC0E
9E9A6D795C2EB0FAB6FEA260B384C50C1A2574698D6A2A4388877442606D70DD
0EE5E56361CD2703264B69BD25A5D100A5796DCB087F8145A1FCCBE19B198770
E475E108291BA200B24185686974C7B649EEED04DA82B67391B0AC6A8B50B1A7
BB0AC974DA1ED971AB501CD4E5EBC5564BD6961275ACBA918DFD7C077104A693
DE5A28210BA377158A704F46F8D097D53AB04E673CA6A7499BDE06067CEC0E89
57540141BAD899AFC4C8A656A7EC50ACE67ADB7B4E926E779A09F2EE7F6697E4
06B507D64CFF4549C9CD067DDB711D176644423F3253E80647FB4AC5E9B1C99F
6C94394D91C7EC0AA568F7684A6B37CCE936BB457EF030C54E6609CBF4A5DC01
AD6F3500F327B50EB05EE95085EEF705993EA37E0CA2D9BEE0AB4AA71E488096
1B4872FB99578B809358856E4E99B28E138E2DB585CDCB3FB5F744202CA584A2
93F65B0EB3258C71CBFE3F8F8849D02ED194C16B0DDD9A95990FB45E3B2D0748
BC04F58B5B8AB1BDC2EA8159A3D4ABF94655F14D1AEFB4EF56865B20E2CECCDC
BBDDD028E973830BDDE3DE50E1E93F9FB1D3956AEA76451DF62E9769BBDECC31
6B0A134B0A6BEC64098B40A473717B9944B9E58336D06C85ED384553717DEF1C
A841C45C0081B9F281BA7FEE6A051F24DA4FF742FBEB0E316AD709E353480E7D
D748B8F839254BA9139D345103CB03226F4B9D1B1B470A6263805542515AA19B
5E0E9FA83A47EBD2CC3BE088FAA0B098A756AFB05DD46EC766B64C7A343516E3
84BE772CD5002C9EC065CBE5330320012FE82090C7F6030BEB64F242CA33E781
BC152124EDFDB9EC7A08F5560A9CC17A8DCC93DE9C41DC0E43AEE3EE3CAE1672
DC1918D057CABA61FA9B11ECA74AA6EA50796A9EC288B58413DF7821859BB191
D53398A26D610D53AE6A1F5B5CD4180160BCE75CC544A647ECBBF5F3C3A22519
1E31B8D60DA92B85DA12348BFF8EFC389B725392C791F02CACDB8E99B0FE936C
7052920AC5C1BE025E51E444243D854C0B10E2FBE104EE488385A8F033713B70
DE16CA20A7B813C15A3F83076CFA0D5785DA37AF7EC11E8DBA8DC447D025FBA0
28D34D04DB8A69414C6E3C488391DCF8288C2D95E222EA6F455AC5FBC299780D
BAA19ADC5AEDEF9C514BF9FBA3A854DA481FBC1CC4B58095C9978CE3718B9A9F
AAF727F2D8286177EE27BAD040C66279BC14D3A0C5FB48201578146A03988752
25D8B82A862989C246A99792851F1CC404819F69A8D552A18A299D8F6CDED02B
55BFA40718E6844F1C80382099B2A005C484818BC5325C835DF77C04A3F39D7A
5B08E4E4B9DF1088B5D2714F609AE2705E430C2941C19AB6FB7E261BB7023ADC
E0C6B2F44FF369069917F3BB200B8F1EECD7E920FA8C8CF539137A54C6C78728
7755650CAF0760C2A3EB6F9DC307E128A76B25716388C24A39C5E1B3C64C09BD
3F39D9628F7F6E96C8E78292F24BDD629583004A213EB52C35F93CB3430677E8
A6CED086044EC2091C5C5BE0FDC1856D175A4C12FC8AD6DC2CCD379ADC516F99
B3C66C7D1D2BB2EA983D8FB1FBDF3FFCEEC282C0F00CBBB760F47A3B4814650B
9437FE42341F275800E9DBE9E13CB128B888322ECE5E140163A2811BA7B883E0
37E1E9E57214FB4972578E1F7322697C44246501C687CC4B298A1530B4215C3B
20AE7EBDCA5A5985B81967AA791CAA3CC6CEFB636125E1301CED2C0E7FB5DEC1
D1C283A4475CEAF9D4CF4E1B9684D8855A6EBFDB495DD527919765B2CB68F60C
178B88CDAC56EE02E71CB861F900BF640BE1A6F380702172052082B89E2DD088
5C187F6A128A94796971D68E551B8C6321FBBB703F048AC6F28BEB42F248F395
03CD0D8063A65DA66EC749B5A578532CFB07FD78396FCC397BF303A1653E9FB6
61BB9455558C353E220C1970E98DF57796C609FE7A9F107DE58BDF381CD18139
960CFE928A76C33E730F739778B8B6CE653245AA60D404B3187D0FEB65CF565A
912A654AD8B40555C4CB4E4BC1D7C2248A6EC5FE336EF19F48D04C9D5A081651
CCF19F364E1A7F1623C48FD96E4A8D7951E560A144FD6D71C5643316D9AC4964
453FEE739CB7B98A9B995434101F5FFF2858F677BF6ACC2410A682A831B2F612
3FCCBD73E709B7DF13E462ED77BA4069E32413E6503D4DC2FCA7AE4C781A2AF6
751AC2366302A3715D85BC30646213E8AD59DCE3FFC7FC963342019ACA0FEBA7
CD3268D06EDC9C961F361257D41DFA162A4DDE3DDEA1855C2DFB7F28CA33067D
35107E25C31677E08DAE9B9FA3E2260E0BF7CA0B74449ECD34DB1F1FEFB74FFF
985C11372129C973CFACD535CF89A430D7C3D779D96255845A44FFB46A93CEE3
E8A0263882542F7F103D14FCE9708F4737959B2B859737ECA0E6AEEEF942FC33
E279C5C9DD7FC9563CE02E9DC08B593F7487CB390BE164A70173B7AB13AFD20D
5219A7156212A7B57DD9965B120A8C2F4FAD459D4943657ADD842FF3D6D11438
30B37BC29FA176DA59B0240FC0E7C02D0BF476D768D438A2C680A4325DC5A5B0
D8ADB5563588D38C1151A012779EAD9B16BD70E552E69A1C4D7638F4CE5850C7
0EC57F21B0982839AB8E8E2C82F96700D866AD30BB0427BE89D487090183C684
F7A17F8ED87A4177E1103949CD12715E4988DE1919048628CFB416C87C3172D9
9DB6F9A66664C2D168D8EB39DC6D4F4CA355ECB144B568E536EC77A07AE34D22
58715A1599CD916AE4DA13B77932132FBD3B8F4279E1741043EB837C589B4CEF
AC955BD04F4BCB9D5F8EE35F039B09D77B795FAA9C987C3A1B4BC2D791D852FA
F752E8AB5344E8279638A023CE465FFD649C3C85B40300181EFFB6FA3628B1EB
9EAA51B861EEC948584C8BFF38E57541A9C9A4CE8482AD4BE58057CB7DDF52D8
294DB91CCBE65334A00D9B0A1E1F39726A99C3F1DE84BF1FCE3E587844F40FD2
CFF0CFA97BB0E76B366370BA0B35DF4D2D5321199EB48642444846A8826589C4
79CC00F5A15AEFF0A0F73671736BBD469360117D1E1FB75C31E4EF8D34F2EDDC
BDF6B8DAE0A53AFFEF94FD342BC212F20DA3AF073C9DED0369646F6B36693E9A
3C0BE49246752254B2B54A972B3583047D43D202EC047CC23B86F7DFE9727DDA
9DC6806E9B9557CB4844083E1E189798BE416DCFABE8DF63BF39D4B882FFE5D7
E305A01C6202D5017614C862FF6E6DDFB20AE1B843ACC7DE83ABB701E8ACADF8
9E8F9B0B086AF6A25C69013A095E5D0616578F72371D5466B8FF94029D622FF2
9E2C8B4244E4E16DD5DF92847AE57C85675CF04BFD1410B56E616F68C39C6A56
31AD03AE4A6A86F7EECC22DCB84028F14724C6C67710FD57DBCD056D03DBCCEA
18433E79136693BCF307614405A1683FFD28A6CE87C68EBC700AF88EF7E6D9C6
45D44A0B70BAFA52D8A57D79602D654BFA9DB8407826BCA2FFAB874EEC43D840
1EB8B61BAA74073890BB920019A390C53B68588C0738D919BB7312844619D2EF
EECCD0A65DBB37026729AEB90253B022FE6E2A44BB0F68B19CC8756AD1987C4A
8477C26075C8A819E2C16D57A7CD7630AE1F32E2A525AF97DAA06827237A8743
40CBFCCE8ABAAA25B91CE004CECB6A00120F09A4CA1A035969C0D267A71A2DD7
DE810E63F394C4C8430BBD1F3153BB1E66022BCB537DC800FF764C914B4C11AE
A7B23988D184F29AAC5C2749B9ECC541568232CEF707373F07E753AE55712F2E
5C5BA8B1BE4AF7B655ED7915395A1A52DDD8F6C69AD7377E3BC967D7B1F6342D
CC35BEB2EB86AE5AB1D2CE23F322E6403D1F8700B04CEAEA603A0833E91FB4A4
4AC83C4B78DC146036351104954ABB269B117E393AC5E328654BCFB4B050FA9F
C85E67561B3C7349966004035E11CFBAF7F4A7987833EB5A841890506F9823E7
ACF05C20C41189CB753812B2CC6054CD1C591825BDD36FA9C48822F17C1071C0
C7FC963342019ACB352F37F1AB935126E72E876B04C421D979D8E244B5DCFDA6
D0319C3C3EFDBE19BE46384F6A35048679EE3B83784F6E3D7422242C6813C8DA
871C3C11C444DB6BEC4CF3670414C2A7245444DD74DFBBA718FEAB9273AFE581
9BE1D31040559F763E95CFE230D480FD64E97E43B29E58C9B866563552C4E70B
185FA62A1470067E126B0678DB534989F29003BB0C0A1C22EBEA953069DF9BBF
7E988CF08D6CD49F6B5FAC77CE35CF5734A3F53859FD9E1D5455234F366F8919
BBA377177966F80D71D277D9A29A3B03EA96BC30446FA34F89ED1837EA86B45A
73365E146D84E1BEDEFB59EB7338E7A3A97D8B120A00F7C975FF818253E68DF4
F605F5D980FDEA5766BCCFEA88F549F4FF7DCDA5DD6F5ABDAF12E0B10F88050D
AEC86C0D95192C772C129F71427E98CC2ECABE772A174EDF95A39C74183F41E4
6F2C56BCB59CE6AEF7E910A0B9EC43D3EC315817DD65934A6057B1351BF5739D
B53E8037C63F8B023CEFDA1360E320862F2CA6E0258507C460D9CEB29539BDA7
1BBA7E79A8A11520BE2B47FA5C0B102FCC451CDF5508519B9B58B5BACA7207A8
E469C325F8E188B5D7D1ED800D9835E63710225A5DABB9F437B785E0C334C779
3D35801BA5832A72592402E3DA7436F10803FFF25B29C3CD32B8140FFCC0700F
A116E97797ADCF647FCA726B45639F0B44CBB65948BF6E9180221EDD0ACCA578
928815D319AF750E9C9801D5D8423A4B836B0196960CA58A51705171C742EA76
98A5FDB4685C29D7ABC599CBE21843BBCC7A54DABB2DD1B7C4E962FE33D75FFD
F7F4302834506D470E4CDE6AE111FFA48845C0A7FF2E0CC929CDF9447D83A66D
DEC126F05A3C85F4400A796D49A47AF2111C9A3A63189F65A4691664E373B5C2
4B3EB36CB7D5F86AB267E7E0B2AFCE4DE99C0F28418B2C29755586E721D83B81
2DBCFF3775458C66FF440206141FE8C8A800DBFF80C2C9A0030282BE4FAB357B
C9D0A4563117574C43A8A8D07755F62E2E897C1AD9E6A375D7771A6AEDB0E026
41A975B981D23B6ADAC40C00E20BDEC7FCD299F74EFCF2FD14611518E5FC8203
F851BF811AAE848B8F7F77D5075DEAE20390A6BCA196798F6C6054F05F09CA34
9F60F4C7D0AEAD521AFFE14913B22B6848FEAFE8686531CA16EF501C2F7EC974
24F8EE353C88FB958EF86AF0A7A5F6B0F62C30EFEEF4CA1441C631EFD3D0D990
76CD65BFD9F684CEDE9386D1A54316372F5940AA8B284A394016D11760F6B062
FC67C339B55C1F8578F6C817251B977A1E24E9A65FF1BFDBE8649C4CA862BADF
76E107548B077B0122C6A6920DA2F749174116D15060CB02ACECBE20035F074C
D8C3E69F5AFD577FC50CBC8C6ED040C9568CC2EF436E499FF187AE1801E18119
9B1F80D0700BE35AFAC768642C3F07A2A21D43EBD0A7A6903110F1BC42EC5FFC
CE6840E8ADC084E63A7C5C5322762975AEC0D0D84A962DD0A04F4B6B420E0A98
12D9745B766BE0F3D7F6438FA7E464BFF671439E450632F1E2FFFB1DB6A72890
DA790C2691A7456F566A83597D9E1EFFA052985DAA45786E411F8AC6D254E74D
C1322833ABF47E1867EC9CE37E9BFAA10B0D8A7279AC40D5EDB47386758AAE0D
B68A07DEF72DE86D4041A1AF04BBE3A28297FB84BC5BC19777A3F38FFE48A3D4
8F4C3AE9DAD23114BECC354E38911B1483E35468A28AE327FCD17A869E76F875
7B605BF15540DD278DF04F7CA22DA964046956386682974247A8299D8F4BF422
EFC489C6A256FC5FB2E085ED4687DBF7EC1ACECFF6C2490C6C463524FCFB9E45
53F394B7994885AB3ED0612296ECC82EEDD03C6CEB663D9CE900B12377D61108
EAF7897C5AF65A58F9C877159DD14B0A79024E601D182A267911CF30468E5558
8B2E07F07D84F8FF69E3B0EE02B0CC32FE842D8965FEF679478A65DD4C94A68A
70B3BF29739E8FDDBA2C82DBA1F2B96366D635C5765C24B94C85426E37C3B5EE
1F61EA56C921305B45B1B8FFDE2A09CF6301F485C8B7DC2E5FD4567BB004E3B5
E0039FE7704B8D86E980962317F052E4CDDBFCD51A4E1260CFFE758ECD59EAE9
ED878D028A67B6CA3AD2752C9A5F0C21F1EE87DFB6C5F68FDA199FF8AECEA880
F32C623ADF0622030F030B795AA0CE8D74EBCA3215FF4B2EBA5E902D9C5ED306
17417F403ADD5B2F28720B02548F82897948B056A866797292AC7023CCCCAF4D
FC6E99DB2CAE37F6163465973FC34F18A96E3BB7DCC4F8FFD925675379569A1D
B1723E07A385333CEAE39FDFB167D87DCBEA2E893E1D90E69E828F3C7E4B3D8B
81698CBB9FDE2DD6A4C64592B79F511EC5A8780B2770443184C8FE3AD9613A6C
E706DB90796FB0CD95E2E3A435596AC9BEA869A5C6AF8470D26527E73BE19DD3
8D47353378A0CBACF68B846FEA8F760EBFCCF49C7D65C9DAFAA0A59C6F1257E5
E0A4FB5A8D08B96311C845ECA7BB4B18E74B4EEADDE0FE0B5D86C9538B9E3260
EB81496B54B8DFC9A597910685A9BEE4CBA868D352ADC10A5648B084896BE11E
54EFFEAF8F40171C316F28FDDF8B550BA71FC5086C8055E0777706FDD6A42201
B3B00F44ADCB9C71FBD42AEA82D51BF9669126F15AAEB8C95877928207810A7E
8FD29F50BEC1BD11A79BF0A089884DF1DBD66479EB71799DADD1A6BE6D499988
60482B626C62849273C3E8EF9FF13E29DC064F3C70730B6B567A9AA1CD07F508
E68A7CCB8E4EDFC64B53FA54CE628FADB2EF290978AD8A150F12EEBF5F137AEA
F15A3EEB91741098C5E8B1BC583B00329B22803546300C02DE5D4CB24064C14F
C89B394FEDCE0ACD8EC2D4647FF27F76A95A7998201DAD83C06DCF3B69DD2276
833528590B06C086922459442CB4C25AF577F22D21E2C2BED96641D41C1DF757
C4DA702C490ACF62B8ADEFBD2DFF9FA496A3FBEAF9140B86917135468FE006F1
59D3299B37AE5AEECD0CDBA01C3098332FD8CE6C0A393AB1BDCB852F0A4DE7F4
0568FC538A0EA2E76E1F62790DA67887A5F0BCB5D84166B43FCB760375D26286
BA01C7C0E4B8D109CBB479309AE973BB998BBBFE4C486AD89EAB0D0C2BC080AD
E2BFE27697FF9C6A98C0F94E2411023F22CD2045F22CB217DB07076D4391E99D
F321D0D871A37C34F20AC988691D35FDF7B2A3B17C6456A86FF9C72B59ABF4DA
174C3EAB376C080E96B4E8483BC97B95AB09FA3237B199BCA9AE4F87B6EE9503
97A0E0FC489E66C587B67E692EB202F29485EED01AD96C5A2EEE04A350718B7C
2A2C0B9BB8973BFBDDFB74A18F72F8D22DBF4E006F303EADF1E26987E4B9CBC4
86B94C0F4477C3751BE6F455B48BB452D8EAB1CE63B736201217374D2E8430CA
A0B8EFFF57F7EEFEB4CECE2B9C81EF87C4184567EF92004555FCFAFB1849466E
74250E026264EA6B108B443F6A4DB719E4FEDBA7F882054BA0E6B528F4213904
527169E7DC255D9507A6BD73C40A0386907A14A80F27CF6EDC902B83D15EE853
A5DFAF99239703FE05CED0A1614E60F47D9F89D1C1D46AF5304326F7002E8316
0343900DD3859CCFB180F8017A8449A3E9398A9BFE69477C79F8D3DA3363E6D2
C402ADFFAE6B3B6FFD58F627B164A6E780D3B3838E8D2B8E98FC6F6185F7C134
38EA9AA5461BF33A9B085DD0908EF11AC8DC936D23DDEC6010BFFB0A0FC3B539
2E27761E72DA24E4C108C309E90A8C6DAB6DF350D2575CA478784ACE8B90A7EE
190F692D11BCF43C81F01EB6D381A7047573816388541ED991DC598699A43BA0
06A3993ACBE8F75502C3D655D9F1298C77D8C644F0F8A3187A8197CAFF1544C7
6C128632A537E9C8716172385C18DF8CEE4B9E59CE2420515A0042EF7592DEE5
25D4A018A88CF79B4B972AE6F7325F973370C589B66EE4ADBDDFCFE12B66291A
897CD411560247B4D041902FE65B0D8A3498A8A37BF1F9C5C075430490AEA44D
1C9068D0D0208F7304AFDDF88F35E1F428DBE74E70427663479837036354C6BF
79126C436F4C14079CD216A6C58EDEBAE85CA2899048A5B1E2FCB489F7124521
1D73B0EE1912FD3ECE521A91A67086A7B3B707AE72131AA7FF5690B18843ECD4
20763D63CBBB0C3FC8C66A1DE3D96F5C361ADF4BFC4169EC226B2C8E5DABD16A
1F78C77DCA1277328B7AD72AF93B62DF13D912B9D7B1B7E0041EF67A68D80E73
C006F395B41BC6C656C70F34243CC3EB340D42110B7CBF49AE3DF8B6189BFCD1
C4FF3CE485E1A6F156F9DCD3B993B31A7D89186F59A6B49ED5F6D9F3B9309B62
AF469345588D6723C4036D41DA43164BACC8ECAC6EABDE91AF0733274256B42E
C01BA2C8189D5556B71345AC51F1A5DABBC8114201E03961015596BFDCD08FBB
40B11537221E57E7A108FE694A8C7A1FA5C03B6E07436B6560BFF5E6119A7734
1C19ECC2E78F6BA5E79950549BDCCFFB6B2286EAF130825F3AFE76608695CFE9
7AB3C6AFC8FCF808501489DEBD17C734D458EFC7E40836601F45D0CC61EAA6FA
EA5D201EABBCCE396A6B3EF82C41D778B615C21D1B4451A9ACC99D10B2322E42
089693DA081DC87FE819E936D310AF8455122F4C6B61307071FBEB6E8DA22943
19365218791DA09A09C7AB12BE2E64A6DA55B6DEB5B700B92453683899ECE7EC
3DDFF5B0B8CCBF3D9CF551AA08694406BFCDB1E8169EE46ED1FD0594991D9434
65AABFC39478745B5D0A6C4A66549B09CC3E1DA68F1D835FF9DD3FA117BA63DD
76425B1D5F66AA868C22B9612C8C65BE4CC71CBA58BD8E99C1DDDC1F129EF788
991BF75E0BCF31E3CBE92822256BDAE8A4C5CBB5E433BA98FE67E25971784783
6C58DA3892211F2C244EF9C50621D8425F61493A5EB7C06CE2A69B429E0F8FD9
878ACC0E43D1B98E110C4E9B78AFB366EF94DF434A913AAFF8901EBAEAEC410E
2B39D69E56A0835318CD72CC4BB057E3D6E3CDA040C79E40BD7CEC09B38F50BC
E3284B302ABCB2A283EBB5CEDEA451F65F5521C8242D03E3D85EBB3BE1A6D4EB
F7A9FDE0E880D694EDA8C6FDCCC9327BF4BFA6CB51D6EAEAE5C86FE64C0BE668
F6725286E15CE9F10BDC5CA2B1A6FA5694876FBBECED30ABF088A7391B55D965
6F1EA40F052FAF89B0A2FC84F64EE5B79AA6B2D3D7B8A0E9B6B489BBEB82A37E
0E7B0EAF7AB0AAC17CCAD6353F86BB96DBFE1BC445BD1A2A8F07815C7E080127
212E2F7A5DDD2991C55C0E730BF29455F30F7720EFF731CE03AA13715DDF6F70
34D04CCE3178FF824CEFE84A13D91680DFC5A6948598C7B8D858B7DB051C3DED
DD4234DC99658E4E65EAB17F8704A1CA4B84C03D9BA61E622439BCF89C0034D1
2CF227349500F3C2423E1CF15A667DBC12350FD44C35250329D51FB65784DB4E
A4545DBEABA19E637D81F07F1D9787FFBC7EDEA104B69CACD293F725231D5DD4
25D6951D85CB49A945DAF9EA05D93E29818F0FB9A187B8E5D3349434ACD4C7B5
C7EDA6764D72C16092554B943A800A06E01630670DC48D4EFBACC3E1BCEADE8E
E1F7C6E12D419E74212DBA2EF02DB3F2600A577D24B660C83D41E7A81D23EF8F
33C7FCFD9A27D45420410AB18EB852FBC192430F0BB98E34A63CD0CB21130588
ED3BFC4D1FEB21C496FF57608A2E31DA8DD0DFDF35A2475ABBF7BC7E595B60D0
C3B0B5812DA0D25446FF3497CB91C672423FFF97794144F034DF888E0842E980
8C5916CA989AF37977AEE274FF2E44CFDA13B3430411AD9E0B7892E6CF95AAEE
3EDF06790862DD4AC786A855E28DAD916B3978B1712EA887EF69C9F1E6CEDED2
195DE4C959980A9F5E9B55BDCAE498A4419A69F3E7D0B0881AC4B0EEEDC8E05D
117CEB2D47C203FB1A7C83DBFF5DD5B0ED9B75A79A208DF03E52EDE8C0E38F7B
F8364281DFF3210ED1BB61053BA36C1216AA87AA83A854DC37FAA624469FD25C
13C086CA38E1A3B18ECCDB83D9E1ACF1AE47BB3E34461248821816D28EC176F8
1A2A228656D34F9BF6E871321FE1C1610EF2DA0F6D1C18654405915DDF9AF713
AE188DE24B1B2D5255246B5417DA88F96BD9BDC47078E8123BC7C662F8A2B514
C2D6A1301796DD1ACD6E388AF098BB4B92FE55AFD1B886C9EFD94657B2A440E4
E8EF8052FB32A12C957DE74B8AE41ABA2BE335D0C3BC727557475B74A690EB52
A8A478F579942F105D057C24845D9DDF784D61D8EC91E9271796668F98CB5FD5
253E821048CB3C681597AE54204F281A476375B73E2B45561C480E7569420FFA
819616F4E8B12F0966A3C464BC03703651ED6055EC6B16FF87C3884DBB16719F
A3FE6921BCED74F04BF1B180B3604013BA41FCE5635C844035986442DEC035E7
578EB3073444646CBCBCC25FC86D1E22F1A11A867DDF211D75F3CC1208C3D5C4
E2B69BD4004778961B0C710520A197A3DC4D41B023719495ECD5D6832EF90A57
B7930B0CE8A3547DD47F6A028A065931BDB4793929EC72A3E0BD368D1883009D
AD3C2377122C271EA78196C4084E4473B5E3A689AF959AFB2ECBADA5862E9291
3C1B26358408AAC69C8C7831A6BE19714FFE64DFB43B61B91A2069A44F42CBCE
67DA9408FE076B92345826EF14EACC810F03A566125E537B0D74FADD27AFB446
F88B46F402C7315974B7DA336CD67FF14D954C08D98A9BAC222CC8E521515BED
2834939C352D3176FD4C2D16191D3426DBAB98EFF3100A763C5A898A46ED3B64
5B29CC9312ED925C55E4B0DF0EFE0C7D1EA1EBB373410ABF56AD76794F370548
21B71A8D818CF298B7C393863223BDBE2E71165AA175306FB60A02B8F1D69DFA
353D33323FD09359B9F11209CEF6DF6F92540C5C81A8CF53ADDBB7162E89009E
6CE060AD1BF3EF73971A3329C0CDFF7F26CF05EE9F6A0A934DA17FCA61A4D503
D34449928EBA0115978C8C1953ECCCDEFFE13A2F2E43A5C604F8098FEAE629DE
D7BCDFDE68D774E1AD09F6E1C6BB9A2B70AACAEEFEE224955725F5FAC9AAB396
62E6D1D742076EE46D653A33B41B9BA563F78138255FFCF1ADC361CE2731FDDF
7FCF8F71E3AB98A02C2DB73D1BB0C85087D05295B99A29D92D6810395AD760BD
0280E5D3F0F328B4519C28D25286B62783E9139A569DA3975E1EF3DA22CD392F
F4D9CCFA61F8AF7CFC74A0815F563AA8B95D0CF54B828E5B0E2F71173944F9D4
F9EBAE4D10F82C5CB187BDB3E2F945F5B85CE0969D57C76833BC3C199D2F6D34
BBE6B267F1AC1D472C3210D89110533B1B5C9910E6344C0CABAF8FB5E34B720C
D825261A802B60B3D19F2DF2919F6EA424AA604D380D1AC566E31747011295F6
8DC271A4D11D25E5FA6E08B7855F6CEC83249C6108A6BE41828C3BF23174333F
7B021F7A0EA29D462E7B044D69CE36C5897FB76D9C5207BC8AB362C4FFEB4432
5B83BE285A26623C75C759E7DE43403B5FD6C306DF2B1A43A67B390B8DD56976
F892FA8B5B30073E136E227A6B1F23DEBF600A45C9D2E1606D5FB8C172C7CD09
E43D9732F9FFBB68671C5CFCBE085129A0F46626B0AF1919C4F3EE314DC20DAC
D90369E72991CF4C9671BC783CC986400359504B7D6432B0BDDA4D74FF5FED7E
232B48ECB56AE881680AEF4BA86443D7787326EBFAFC022B522C978D36CB1025
C79412CD8517FCF8BF36CB0596B939778F6E17BEA94F8683E047495C42351C11
1069E76A767D4CDC36FD207050C81D179AC05D5E50D2894D9655F7E471EB00D8
4252F673266DBAA76FDF109DE86E7BCA4BC35A0F63FADAFF43CF0DF18F09B1AF
F5C86FC0E8E24F451AD7BEB4D2808CC770E85D299EC133321F6CAA8CD190D6B5
90F98FBECF730F1BAF1BA1C82F735EF3052CDCD8B4D5F6FEFACF7D2DB9C18B57
0E98C0EBE106CA43F061946D2077A449CBA42B47BA8247924F1C9A9719EA2540
E889D483EDDBF8565146654275B55B9133F71D405552574181460130A955D085
870FAF8C0FA99649B4AD2EF7A969F94E82C3C388A455BC98A21234CF4756337B
A8355408C7FCB00B7BEF6E47AC865C40E9EF3C0ACF0B1A73EEF444B0FCF1780B
92895CA332BBF9344EDD4DFED6DBD462D6C63BD508AC590C55E158A161A6CCFD
A1267C6508D748FBED663C94530C7ECE78CB5D59BFF852884DDDD25854D7554C
A8091FBDE738ECAD9E87EFED83E91176FAF07A9E7F5A3D7380FC3563D88A791C
543BACEA39336943991503F4484E3E440926C0B39B097024D629C262E82E4250
60CF3A1933AD0EB696BA8FA2EEDB951ABC19AD147800EEF12D5332519BD9C7CC
D6B7C4E962FE33D75F4182961BD95605961BB4348685A2CB7412698DE74311AB
A3825A3A407A75821F8FF29A06A1E72F3177742925A8B0D8A16B1BA96B59CAF3
96865BA8EEFCC5E14F8052DE23AE97A0A969847A4E74382964B6FD68D931CF90
692FE0966D5DD6FD949F529320D3A6E841D8C74EAEE44B804915FC7E87B91BC6
5A59663F9818759A034E22D52F6A50ACCD3DB0061C328B5E3285A2B1132C6D63
9F8BC3C5E3A94CE193614893F2F2A1B0D13FDD48469D5BCC81EBF0B3E729A681
7A1061933AE54AA83E0E58D61A027253A94F93122DDFC52F2E10D72BF4E7D8E3
91B49929DE42528347B1FE22811A1A7957B2B140AE74B8D924E48E1A38D798DC
40B89C47EC27B51A60574A8A226A6BFAFA2F12135B68E08E4E62DC8F7A07049E
5F9511F7428810964C610A99FDE8173C5623BABC4D43D340B5DC382AA87D914C
1EC201918AAD99BC73DDA8EEF36A7A3E93882450DD076D9F368AAE110EDAA1DD
2738AE836498DD08A310363EE9B1B8114220275704F14451B4FB1CC53041AAB0
01EB374342C9D0B158217B79C4DF1B68898888CADA09283B788EDD183137F1A5
6BDDE3E6F8ECFFE471D9816D51AAF64F0085C8DC6D7D43735C7816640FDD38B5
FE9B57F2B1770B844CCE2BD527394C2B013B3D96CF7EA67C279502C1DB18C262
F3884AE722FE9163D222799B1E685305F8ED25325368D41D20A771F58BEDB820
6835BA48DD5270BD54D2EF50DC82368BA2A93A52B79D35FD7D0E8D07E4173AB9
8708D95438940BFEAF8933A9545D5F55260B16382C91E4A60A0B159E1B565F0A
9AF573B488F2376E8A21D0CDB0AF33D0326EEB5E1F577AF1AF60BD61D12CF1EF
A5BA659F74DAC7DD3431C375347F571FA7A9F4D33CF215A895E5FE39C995FA79
B88ED5BC8F00D6D1DE19141C63F10353D9F2E030BB3D89D6BAA4914BEE1DDBAD
413F
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMMathSymbols8-Regular
%!PS-AdobeFont-1.0: LMMathSymbols8-Regular 1.200
%%CreationDate: 16th September 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 556 156 0
%%EndComments
FontDirectory/LMMathSymbols8-Regular known{/LMMathSymbols8-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.003)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMathSymbols8-Regular)readonly def
/FamilyName(LMMathSymbols8)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle -14.0362 def
/UnderlinePosition -117 def
/UnderlineThickness 36 def
end readonly def
/FontName /LMMathSymbols8-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-30 -955 1185 779}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF105BFA1C4BAA966BE78FD2F618C28B35E2A9ABAF
CFC1090C3FB0905252C41AAED38054D177019225F56A500BE560889E991201E0
4F9B605C0D22769EDC54E591E36E37E5FDE707BD42C0C024454DA2F639F72A9A
562B5C1D32C6F47FC06B117D908616531A8379DCE1701F7F184859612D9F84F9
0EE31AEF799812A99147A8CD30D5F8F8F035757560E05960E2C327020FEAE317
24C484AC0CD3C1AB9CF35516622A022D6CB83DEB8126DF04762C901617B35492
98158049D5C65DE86143B7F36D36233A115C36DF60D3C55816B2B0B341102AF0
90D7D4E00A7611262CCD366F870F0EE8175688261513076B608C7E160A9A79BD
2B66E2E2A89CBF6D1703854915ABEAFA09718FE338924B5AF1FBF1209786AEB0
0026C38A2C7E208E6C306BAAF037DFB0F3297EE1ABBA65247CF72D0F78A9BC24
038966CE124B94487282B69D6BC0B5E17441DA55415B5369E451E2B0D705FCAF
3AAC6DBEBB8AB0313C4C201F851DB96CA9EB49357C3C1AB73F0CA2110C994680
5AC8F0D760C03F71C92CEC2E1A3AB84813D389BEFE7E0C28FC76FCA70704BC4D
159EE8B490B95CB09DD01A4122A686AFB8B9C69381C8C303F9A3B695238C3BB4
CB44B3BBE50E2BAE63796BB51D945469BB75C69F7A758180B77CAAD2CFD5951A
23580A3D45083C8368543DD37AB49705B939804C12D4BDFA730845F7E42A6C9A
B3F0A376F44DC297393B85E8A18C45C99260BD499DE599CC0D76EBE4AA7D70AB
348FA87CA9A1000814C4FA99B4EBC35A0298AA29563B030707F3EAD9FFF7BFB8
3B347C4A00BFB392E79B79F413E67A73FBB006EBA896A65CB21BE940A0940640
34E08FF806A114ADD3FD42BB394F76CC77DD869C46DEEE20839C9A2FF73B840B
0ACF238D333719F5947DD4C39B8E3F070EEDDA1A39D526319828FA9F47F03D8A
245D8E215B37959566D26DD98185223E4FEF01676650EB4E26C0A425E6C23C50
4BA94BC88E08614769C017F6D4F14C52D7189D4AF8CDA367D8B04CA8D3F2307C
0A7A179419A80695912F456637F539123745CA8E696E250E0BA6B7C6277394E5
98A8799C29B6272613C152B0CAB05F3C7795791EC9AF2BDD416861A3D13FA858
BCB6ACF5BDE40E5DFBC1A171A7280E8FF4AC0D4C8A2199E9E2BAB5CB9131A76D
EAC166A7C449A549EA5111F1750CA2C6E1EC6F00CB6C62BA52D17FC66E06ACC9
1E6B858F9393AF9AA5E69F799E01D301B647DA57225C2920E3BCEE9D09CA5C60
F22B07F24A26DD8F4D6F9C78BFAA8D12A21531E713B80CD03A5FF4F3BBA2AD82
3BEF7DA8C97C30F1452006AA3B1A168483F6EDC4089ED02E567923AE6DBBCCA4
8C246A080448200C2A29C34AE6255BC79B73AE14B980A7C357681BB0962894CB
DA32FF2B70B21AF4D158E0F74652684A7150D0967F83E13EBBAB33588541AEEC
0DE8C53851845A44FFB46A93CEE3E8A0263882542F7F103D13C367EA8E1ABFAF
6486A9DBF6668550BE7858F5790BC87C66492C0FD34DB08EDF842E1AF58A09B0
85A9B7FA402029FE2439769D67DEBDC8AD8C861E90E5322951A2904FD702766B
36916DBA8F9C96141BBF4788FA435556B2B4E1B37DE4506ACC4224CFC00A8F83
33941A050B51B9508758F4EB2DC074D799F5116296B8822ADD743A043F9A6426
88D10767A9F99A072BD4C88CB579B34687BA4953B96DBA29F33211B12A0215F7
5F2F873E5074A7D593DAD0EDD97270FB9A87BE870321A49958B10E346203718C
ACA3E953E1E2A74FFEB0FD2DC6A1BF941DEA5FAE10DF5D09615E225407050EC9
D4A8A4EF1D4C0C97B6D22FE5C5FDD6BB11177772757A5E24C1E6B301C72039F0
DD57452323088A8E1C8640BD1740781D9F5739F123301646C556A7D198EB920B
B6BF86083F112C54B15F6B8F7C545108767DF857B1CF11495E3AB7E7AE29B3BD
BCDEC559FA7761938B9376CDCB6972B92CA5D50FE8E609CAB16A7D5DE4850C6B
96097E8827F5E6BD8B2A042FABFF4899B256631AF82627EF13BF943365262AE3
776F96DD3B5CC1A66269F85142AFE7680C106582C2B3AFE769D00571752F900B
C4DA5A176E21FEB752C384A20E4530F9148EEB23A3328CAB05790C6478DA290A
4DEC5AEBE8C7F3FA0609ADA3E14238044AC60C2B101298E03B26415C86BEFE44
9A1CD96482DD1472F253C40D024D9FCEC953C855257699ADD050DEFEF6976F67
A3C252B56E44B0C7998844BC7C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman10-Regular
%!PS-AdobeFont-1.0: LMRoman10-Regular 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman10-Regular known{/LMRoman10-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman10-Regular)readonly def
/FamilyName(LMRoman10)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -146 def
/UnderlineThickness 40 def
end readonly def
/FontName /LMRoman10-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-430 -290 1417 1127}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E4018CA53FFC8B28E49B3AF8134528F971DEDA
55E9075B8973BD0B1C001D7F241CAA67472027935C0A16779AC34D17950388CF
0E0191A473BE7581A249D043279E83EA19B511D1D8FA3933F37C594054DB8297
45ECDBC2E8976B243A996D477A529B8667BB3FB7783D0B773B952A4520909BA1
EB4AB2FA4D38CD9B2CF575F8E0FDB2E85A6D59CB0AFEE208F8B5D960088A941E
6E9BEBBF2E02CBA386FDEE2F4A0A453A960D80C90142B34FE01BF72F67105E03
114D181D6A3990035A36F1ACEF46E884A818302042894B42069DD5885B97B047
D34FBF7245DEF708B5E500E71FACA6F55938C1C9E03601F110B9B96EB91E0E1C
58D594B02A771F8480466FDC743843460B3AFF1867367D645017E2A7C96B0FBB
A9189D995DAB0521ADF024FABC33682BDB8605155E5D1813E23B4A9890D852DB
2AC72D7543ED8D34C8E29A88758EF0B5364C156A3D213BCD9060892C3754E0C8
E5ECD8CD5A580EA0561ACA1E90AC5D7729DFA7B1CFCCC98DB829C1B2EA250F4E
B54CDFB18B56D98AFCD392F4DA49FE9F9CFC94137C35FA857342908ECF4D0019
6506644F2611FF4E67B09224177126E4E059D7C2A941A01BD875FEAD28864048
1DDE56A671FBC3511A79E5EF3F153E265FD840474B66B830CA5A09455CA1AFBE
B124FF3365AD824CDBE10A17B08E3A47282CE6140B0966D4EB82CB5B034DC6DC
5D6CBE6E1C99160BB1F4A87545E4D6D3EC7E30BF52F8F79A877416F69BBB5EA4
07530D50EAFE96BF6AC0F277A8A357761836E499F221A6DDE9AC0A03ADD0EF91
31B26E4332321F4FD59C51B515530BEA1AB37479F31B9E6E94E5470A0BF30403
FDB51DBE8C7D053D1B5FF78EA8CA01F3CE6E1E8E573F5EE8C282321B49B73D9D
3E9CC4C3005DEB4CA3A2828B2D8BCDAC49F4AEFA7101055E20CD98B420454D0A
2C7C4B3933BC81AC0FF01C1D51D262D6B85AD7B970750CD0D6F2500EDBAB25C3
46F96A6028A1106D2DA63EA507C071D06D71D60CEEC9FC68AAC0ADD1DD74B262
0156612EB4B21A3F4ABD34403540C124221FB9DA5EC6C7229DA9A1D033AB828E
9D80023B2C8E68FAF7A38C925E0587A1CCE432EBBBA598B201F5AD036BE7C8AD
B8C411BC79646781C4519B89DA648B919EB362176B83298EE2D8B405DC66D81E
C655DFFD1BB283F3C5DEF1495FF97C798C213036AD02BB07FD42EC5932E79727
ACF464295E75CFC635036CF27FFC42DC2919CC167CA4C2E673040B7909AA26E8
123B3D9F176F6510B9526E94D4E38E62F8B9B96E2D2D51BDA2FB7C6992B79CD8
3E40292315B0EFE711C8FCB37968B8AE1BCADE6BD8A3BA1009B34137B90D924F
B2784C9E13F0795427324E80C175BC99140171AA2F40784356690DDB982F55FE
EFFCF946C6DADBC6A907C7DC28850415D9AFC1C8A868801B990CE2D26AE40CB3
4EE0281A60063AA71E48DB8A35E05C2BEA1ED5BEC68717E95B7597AD7CACDA2A
6A4E8808BDF0AFFBA31BE1697149D7BACECF4481DC61CEAB7476A2E00CD8EFF1
37E476FE5A098E607E25ED29F4BF3409309145BD0530C8A76E85F59EB0890ECB
A12DE954F33220ECCE5E9CC4B52E97089790D08FFEEA7D143DCC7C07BB2694CA
6709EE19C11515E6E967043F9162C39D9BEB2767B7B31EA068C594A63173F7F1
67F3D6FE97087D19F73EEE205A47785EF3C453E6F77A08AE9F93F4060DD19EF6
6DA5E780DCCA30F180F8DFB0CEC4602AD1201C63D91450E7B5F44AEF32087A03
0D933A941134E74040E6E7E797E18AF57941DDF7DE2072ADACCD3BF8D4CFF06C
5B946E21D0F5A799CD011CFFE4CF0F571B4377AD4768FBEBDFCF6B49F09839B9
35B1F7AB20DBC872DEDA90B79F113F5A4BE581DB49C5EB8C9033B8050C143424
1EDB333D1DCB862DC543CE420CC26EDF9639E4256570975B25C6C1F06CFDB2FD
9035344017BAA39283C14E3AE66A14DAFFE2CD87485598645C39B92C18AAD014
7814BF27C8FA6DCA0BBA0FFA552B9FFDD54BDD8C7F84484031FFFC0AE8932A64
53D2632D9379F30231361D03BF91F74904C7106B6F8EB6ABBB29858F65E937CD
E31D67C847719779DE0B34CECE88A8F9A12D46B8FCA50DF4433B0B8AED6A63B9
E6512B667AC78A09A780813B1FF02AA967B12AAFAA0AF1B3DA27604A975C2DB6
FC1854457C67C54DC08DB989CA3267B2BE5B8178E6B7889A33771F86276E6DA4
F83033522871198AB3E954EDD88B5059BFBB42AFFC2738CA09B628CC646123FC
9C2BB8B9149CBADE7A7953FB4FBAEB6078B410935DF7D6D5064271899313C4E5
0DA12BF2F08521A17641A2F5541EC8419514939892C0E353FB1785CF9CB67C88
AF752C2A0DAB509A424DDB9649BD8A846E6BD3D374BEB6B9DBD5C10FF56E2000
AE4AA5B339C187F52630B52309834F266D778C720FA9BD9CBC1F322A39EFCAF5
85107BD5A5C188A6409352766D80E77B1270019E0EF57F31E9F13B9483F070F4
86122EE08A4870456161458B6C93A1602A5EE583461ED91A90CA5B743636AED8
1E5142CC0A7DC998CBCF84E39CE3B141286A5994C60855979B402FC1C092EA15
1A6F3762571629775247A6AC65DEFBCA10A51ED614E0C7FBC7335681207464AB
F8C4ED5B883E7A4D01199AFC3C88B0E2AB5FE014A84377451081CA0390DEBA75
7BEA45FA3171095052B839F7A2A9E41737F4A4CD704E8EAFC757116FE3012E01
AEBF584F6B34EB3F9C4B3893DF4E25B71CA17D427219E0E2F3F7ADB530841948
1FC1CD966965C72E9490C31153E2A0DAB73629A1DC0ED7C058AD150C4D5BE6CA
FCC7D71907232339F3FCD771914933CABF613F0F9FA3E206172B0B4ADD1D9744
00A8C2642147D4B652A8F1A7E5BD064E369FC591D4739533513C202E9DA91CDD
1581D1A58898DD6564B1710A88AEF94B888C52681BAEE1E3EFB4DBC694919D4F
41D01894C91D8E03F68DB550934E5D783537D2B57CEFE23ABACEC756F5D1EA5D
A74192035D2304EC4F9083716CA7906B80486BB5C79752270821CB12BE7ED0FB
9FEAA580CA187AA3C9475070809AF6881F745EC71298D454AD31AB998F5821B8
2070122634D5A247EE4D8672339B1D90113137D4FEAF3CF3A2456A8712556956
C5A48721B1B1E140ABFF7793081B2B092724FC0F129DE772236556BEEEBEBFB1
FAB1037FB0997B367483D2C8C0D44E6111CEE2EF443F84FAC7710AD0368D542E
8A629BBC3C6E2D85E984AA01B575B37DD1D9B0D453E3A73EE7A34FEFA5641BDD
67E694671B6250DAFA3D85E0A78E946C78E33A284D4F92B73D7AE87B13F108F2
C4611CD948F30F56B984E409650E9CDFFD63D996E25E5C0E0FFE02BBE2237537
8C945F31C26697A7ED159B529276995292581CB9B29A54F4F4B2D472C74909CC
47C1675DC6FB9A932C0552F8FBE17F4D8771BFC6109E6D709951694157B3CA9B
1F3952D101D6CE60D1A0A97C99EDB3FAD64BBD337BB747424BE88E67FEA44610
51A1F65159650D3A2FA882944E6E8DB113CE928969F6BE3E3B8BFB71302E87A4
5A22ED99B04853D66E5A22B56F79FEFE917A6F436B823B1A2FD914DDADEFB5C5
CA3A43E348D017CE2040752BF94A98902E608264DED8C3241F06469FE18C377E
448EDBB0823526BD66B40F0519F047195405629408224D070207499DF2F43E7D
52E442E3B6E9E3B08F88C9961E81373B96460077464C7DBE6C7C7887BEB3F685
B182706F5DB4C7C4BC2FB81A7D040EC5A04E5C5434D732318AE791EDC71A47F2
AB39A992EE304763BBA1AA81F9D74B24FA7EACEFBCAC72D673540922501841A4
F7EF18CA86AD20AD76325914FC0197DA6D7632947C4AB3AF2133D1A1E2719511
F62BEB9C879E76B74493C7D5EF38E01CC031CB4CE13C2EB6BA2695E1AB97260C
39A7CF8F690145893081D526990E92C1FB18CC4B968D70DFD13C6223FAC9AD31
2E1240ED981AECE8D13DC653D59255F868EF158EDD781E9D02889907B23F00D4
F6A0D9B74E591BADA348B09E22B1A783A8EF2AC87D34B6407522AB33411ECA4F
6C765C85ED1405A5F27B28A16751402AB278A8099E29940E719DE1E109E5BEFC
2A4098E77020110C37A90B5BDBE27995D78FD99C5784B2B7C7C509E9B93BCC29
35CD2714C50B246A7DC70C99B7DBFADA1E01B81749EE49A70853CD45FC323019
A45BCA3DE39C3E7618C6322D264556FD657D9270933D8B167D2575CF146336BB
1C76735F3B09470E40B0624E52F21809704749F6D81E3B829D163D9F61E070EE
D8CA803E56CF227F71EB8061B83E035C7138A7CFB6D6CBAFB766754C0E8934F9
AB738930EB75A2713CCBE333CC60A6A8F2BFDB043ADC0B94FA3370BBFBC61D7D
25524B08C70599D58E7521F58D26AFECE212309BD7BCF62735379ACF3309DDC5
C3F30DD7D3A37804BB23274D7B30DD69E1B2C3CA70F2F79FA29543F526BB808F
04609B43776382C4389362AEA7FE4E03637B4599D176F103143DC04D5B5E53D8
568E7911839EB05C8F4A9E9C911D746C4C8EBC0A4E6AC3CF08AC86548A8FD6D4
7450B1FD87B119E547047F43E9CCDE1C1F8645DA03EEB02B27E36BB6C87F39D0
505579B2D0FF4DA9D4AA971DB4C82693DEB59FAEB3A14C1547C6C46C24FF3513
EBC97357AA2F25BCDC92F98CFF9F3D5881095B96FBB30E8330499FB4803EAF74
920BAFB89889071729076D755021515BD8DE5177013854B10911605F872456B8
F504547AE968C323B85DCAD9AAD5FC33F29A921D427EEE0E098E8591EA7F2D7B
A5CD8A91C01AE80B672831C286C900AD20776B50D4D2004F7295D860A2974B73
A9E8B594BC8BCA8356DB43399E6A6918A887A64B2EEE98060E47C0F371681713
13F92A306D1A7DD5FCA29CE223138B98E6C6BE9F3B305E2E4ECE098AEC270F11
2CADA74CFF4BD78C5DEF4354211E3953CD7AD90239C1FFCA061A21652104F54D
4CE1C6B388B901F937A299F65C3217180D4BBDA87A96F4C31014265EFD9206DD
DDD45DD3F56823BF8236F0E6B94537D9CEF904EDEC7EBFB0E60995CF6457CF0B
1D76EFC8D22A8E991888FC44FF9ED2954B7A9DF5CF6F256C8A86C3D98CADF1E9
24E6C6725EDE1262199758B2B070504BD81147F35D8989D2CA44BEDE6B8BA09F
511388851B9D9865887D4EF8AA7AE6AB234B252A506EA2EB59B1AD40A04BA972
EC6DC7C9E4ADEB7E40045F10F38E0C8D50CD28D96A028BE7C67D1CD148404CE3
0DE9213AC26B82EB823194818E6DE249207343C37BE9B926EEDF21E1D52251D4
37D555CB1FEF227CD15A08CA2A245C3C6508DD3592E809E0C72380B92F4B946A
7BAF34835CAC375077A843F61978AB4876871FBF42DF8EB5F877033452F08D41
970883CD836D1668B85BD642F7F50AE117B3ACD1A1372D5D4D2555A2E8E23E29
D8C8C5F39807B5A01188DBAA07A27A116C80E837DC740E86068952F0A57E9027
C39A603A4886213EC782000DEABF71EAE1B8944E2EEF19E1F7FBF442840845EE
D13FA9B4C5CB1FDE6F0DE20AAD69160BFBDA23C2D29311C4F82514DCF27C6B94
A8E727522E182DAB2869CD2C2B0F39016EB778060F35A6FE085A1BDB04A65CBB
6605D4D72E11338D87D5B0283A4B81EC83D03F502E7DBF202BA558B4EB271C57
922F0CF3980A02A40CEB2FEE42B631C999B71EC234FED7B269E5D91564F0AC54
D70F8EFC63B94F73ACBB4CD279716F68783C493794BF12502E04FC52064E63D0
05F2034A1E7E4192D1193BD94E99C0CCF702D9EC100066E1490894F5ABC92A92
C3F42F4101AC88024884C018C7D0DF65F7CEBDD46FADABA26B5433D34C2AEB07
6031841EA02F1C9622E0B64CD190A4AF3020654123563C5D6ED62F112077A1E5
88A8C8499A8917CAB23F00BC124FD93096D2603BC6C1734124CA3176AB14F488
26ED2E56C67571DB18177A07E082CB873440C4648D3FFF06A1499A5C7EDBE172
1759C1BEA3DE43B426C5E175B059005BF2911E685D076FF12D01742E9AAFACF2
CFCAF0517858C28A24FFEB5A26E46BB5B788713FB8009CCFE62C17E001C96636
A8DC58B71D4BC720F615D2873CD11E06DDB3A7788888A8E713D0E82FC861C0D9
ED98E873821095C6BE6CA909BCEB6C9BB1B0730BCBCB20E22D06AD1AAE225D51
25AAA901A78E86386D29A7CCEFBAA8F35B4813CC9D289E5244483DFEC10FF237
E38BC8E19B81502A19E0BD113AFF02F4E365A4708189A7BDEAB2D32A6E464AAE
B3505AF669EC3FE5A7C9320D907438DB23A82D8CB9777BECA40890C137564EAC
CE768714D7430BE1825C90D88DF40E753607A06AFC0046335F97A2FF20EA44F7
94C1DFD6B105FDFC6EBC6D5745C10D2C3BD560C939B80707B471D13D7A910F23
91FA6B63F2E6A01890368EA8F0D42E7A93B343C664BBCEBDBC0C99138A50E5C0
F57977D929DC9CC159568FBF5523D79229E9BA352E4193A44EE745F76035DBC9
34588B2B8FF44C8368C9C69AD17E91BD78559AD4BE219C8B110472F95FD5CEE1
A7EC2A78941AFD0B102C6CEF9D5BCD4C4FB87316BC327ABA5D5F5FF14BFAABDF
9FC06879D91DADEAA25F850083BE6CC26AE7437664ABB66CCEEA19D0BDE898CF
328861C3CB4423FD2C0C1AFA95A6195FEF30511D5C87876C863364CE4B089A97
6F9C29A14A61785C42D2C746A98194782D9A504B2A0A92D4E4B5062855A33404
2E14145F4684AD22D461E740FA8DD232D18E559DAB50A977CF474EE1410D7097
785D120CA5C6E051D096CC40E931BEB074AA9E32BBFA361593C78D0D2EDCB1CD
D560A14E93017099D24663633B06BBE3C20A2718C044731B6DB8007749D1B605
F397413DF968722DC03BD138B0559D3E5887B7EA9C9C54F8335F55CC3F1B9135
C70CD0214CF04A4EC5AD120D492F25CD6E1E80CE87C5709112938ACF9BB2E011
87FC035CEA0FD5C1147D41630F1CC9B82B395BDCE1885A1D5F3441B03AC321C1
5CDE681DBB192993B553048C58C55F0E420DCEA46CD16B75173C5D37047E511D
C980EBD803E01C35504C4092D93AE476AB15324149043E713261671835DDF160
4B8DA000941FC5F85C754D5132402A0A94EA3D0E37D6B9890461CF1C65AB7C2E
E42288BD17DB983600580BB1513D30983C4FCDD1836FEDC80308316401D8B181
EE2A3B114F68DED3488EB9ABDBCE6E73EC5A0AD42D7735045D594C43A33EA29C
BE2AB98CD0305DD935D8F0F5EE3205A7576650887883B3C9AC23E217F48154FD
6CE1454F09486B47A5A18DE65034D0CC9F9F66DE2BE45C2D6F1AF8B10F578B9F
F66D78D738FA85FC454C23236FF4B665EA0E6210060F6439E9CCA612DC7ACE7A
D12F478F25D40CDF7D23E3E543B75A97A7BC960A7F742A2C89212832C36801A4
C384B89A91D53E0CD886C7BE0692CEB0CF29D9B4BD53E08D9FC1A863599BCF9A
717F4DC319B4B59AF009C11A91ACB087542F94750DC53232E62ACC3C660965F4
5849011BD76FF8489964A7848FC6F3CFA44B7F502649EAD20FD32FA1999CB88E
A646C764BD2088A3EF00A4F1862F2CAE2F8B6A8DB26A1287AB3DD941A92AC57C
EC6D4CFCE0ADFD99BDC3BE161F4C1FBA9B854899BDB7E9D09A1E25A95E9789BA
DC6967F96E550903DF9B81969E38FA3DE2A058EE2076C77C33A93F2FBAECA0A0
EA98FA4C3D1F8700B04CEAEA603A0833E91FB4A44AC83C4E86308B6E89C99A84
8AAAF1BD143560B559176CAF28B1D8B2C8370CBAD5873329B24AD4A743F2CFD1
8B26B1128AA48F72767FF2268BED8317FAFDB532191FA35C2984AE7C50481FF3
126BAE5309893814BA28263EB863D5E6F01C423E6C5D3289B152CE19FDB55A11
282FEEFFF3E262F26041CB1AF30804A3CC34C06C6FBA8AED582215711B0A17F4
1B505FA0B5F906C537EFCDEE4C69AFFEF89B74C5B83E2DEE7642AA85B1615F9C
BA1C3C3197223C98A1ACAA495A6B8B8F1919AC158DC63FF4600FDF993CE8D2E6
3DAB7E352BE200322BBAF6DDD2628694612A7790EA8E1836533738405E9B7AB6
9DC77FE9A283B3A8C6A3651DE8AF71499D39CE0567AEA286091BEA9D6A443A5C
D35747785C433D4E18A02ABA38F55742DC36E4FF07A656AFDC3D0A32CFC097B0
5F9D90CC4B614AE7F58F3BFAF22EE6821291164B14DA11FB16C0E671A6104082
94D05830E44ED3E9908B59DB3B3506C60D3F766ECE69AE23369AAC3B5951B557
D62C7728D6E3F13BE05939C2A6FAA336EFA57001DE299223DDBB333D71003681
B4A816B378AFE37543607554F1F1B427784EFB366CBFF1CD7CD5FE3CB61842EF
56F134AB25DCAD2BD08AE61E233FE6FA79017D1883C61EF0334681CCACC5D024
F39309DDAE717CDDEBF80C88974D717C4539732DAD1226FE504620FDEEEC6266
41060E55159270B4794F9C0945FEAC295D17B4E252D015910B847534A519CFC3
2D52169510940A9E9AD636AE141331BE35D1D5308C927BA3940B773F20E5B3C7
813663D33205454A1A4B2D9173D593615C4459845E1AEEEE1ABCE3E5328D3F81
11610DB32C86FF6F9DBA1B8D6BBA3C4AF64523F37F176F3256E298D22DC5F1CC
F1A67A355219E2EE13D5D6369F656836EE0A77206E8236649E81A1F0E02D8D3A
3C8FAAECF7839D20329CBC5ACB43482D3A3A1E9C3A426BC7FE406E89FF25FEB2
34CCD7F3FB3C608FF37988C7DE6A41FB1020DBBCC762F2BF24BF424BBB2D3207
9DD408226AEAA0C4DCB8DF16CC6767B0BC73EBA052FAA5311407ADDD4BDB1061
3A860B10D2C219E96E61050B98FB04425912F484F5B79B9C0735F92C1B4353B0
76358780D1547206329F302AF6853E5DCFBFE199A76734AEC487BBB103A8547A
0090F0342D48DFF9EA9821454CB759B3D82921AB4B9278E652C2F30A8A121781
8CFD111E32142FFB160DB6422A5884151A4671D631260FB1758BAC67E14234D2
5747F1E68E0C36FEFBD535FA5C64B046AA8835817140B76DC22B5453AE8F3F76
C69B9F10988BE7D061F539CC8711030D2483F752706E27D43E3102CEC57B8A58
6D3FF862999D20CD6BBDB23762249BA7031D4D97DE2280C10756DAC422F0B747
E427E5DB0B265FDD57193B8E7F00C2162FB111DC4972B51E59320793EC60AA3A
F4A3F68AA5E11F657F898F59F67E0D285167231B9F444D42F17CB182EE584117
FC81DDB5BEF8EB957F817C5699C7293E47DAA4EAD6D47F00FC6443EFCDCCACE4
627CFE80E82179579BFE305B9AA1770E8E8970E70524F9F7AE081E64AD1F71D6
CC6FF054661866B68CCC383E5403F0A734ECAD86937D32FACAB6B04F3F9ADD79
94C11CE94999A3F38C88115D6082DECDC2125A4643102DFD0AFCD8682BE5CA11
AABA54285DEB171209CC4CF8879A65088C7381B9029B67CE9029093EEBBAEDD4
403C382D29751340F63D14C45D0C8ACE829FC3034643F4B76AB7BF41CDB0A2CF
B2CFF7A3E022256D29AE0E789DBA81CB4DDE7D4A970A3162D903EDE2880C20DD
FCB205309DA145A55A2C6763E0D8BC8A0BF42461DCA1CB7E613647A93FAEC756
3535886E28292A422264BAEA373D5F1AD84FC79DE23E2BA52D8EE1B1D3F80318
8614D6ACD81856288366086F50154919E5C99CF62A7700E896F5B69456110B9A
8BBCDA8551C3C14F979F3CBB597AAE41210AA7A444428DD055DD35D91A1DD465
3800988005F542BD304D2D1798BABD827BC8A689C3C35078CC3502DEF40DE082
B544B4AF7127EA6D5B8FF5A0735257BE29E36A29B707A51A697A4D8A360D4017
19C5FDD791A1C640D47AF86948448DD00039DB41E9C5BE1A7E6BB48920932280
BC552ECD04E2C33B76A0F6172098AA76CD4660980EFA1C84D5348740B8A4885A
BE1FC79E81913524DB238155870C6B9819E5842664A4049499CAFA7351D3D3BF
FEB9A51236038D4452E44A34F25718B7158C40F12ACA152F1EE78072533F8900
CC3A1869BE48305DA62447B28A45D6F516078C72A4B155A2715B713EC359F680
FCF2663644C985191135F0156722F0BF1DFACDE42BEFD5278ACEC4A55F1A082D
537B3C1EE890A6FD2ECE0EF3999DB161EF7DB88DA4B0C592385D35F705BC2A9C
CD7351AE879DBB7FB52F25A5A5DFA45DB0FDF9B94F0AA69918932E563C8827CC
340AC4350DD2FF1A3EA9F8F3711A16CCE9A37170F0C02A9C7143D722CFC08677
6227901157114767FEC20D2DBA71C87061EE8BF523D591180D29A8F8E14A7959
731A74DC4B215D7EC095EBE86A3CB7C28C2EA7E6A19A68B64EAF236A3468C0F9
453189A1DFA55A9459D1C5B8CDC769D992269E6EC4631B1B75F7E6A511DBD978
F3032D2FC6BD54FD7664FAF472BBF13AC7F619FDC4AD5B38CE04E4C555757F69
C669C5EC403770F681C400FAEA98F62F02633E0F85A780A61DF255239F9BC3EA
AD652E6D5E754B9ADE46841E52DF90C3F0D7CE5DD684566DCF0B43A0B0F975DE
AE2F7601EB63C39D6EE8C54611D9D515EEBB7192C63D22D02BB2A5A27270225E
C95173C09068553725ABA9423F4B268C58072241D2DC5C080E7881848222220A
63605F00205C205B35DA93F4D000126B2CE72AC322B4D962537889CF225B3381
6EB449BF2C28599EB66F071FFCE3410C547A9B74D216032B72854A0B8A6ADE15
EBBFD5CD2BA9FAB7E75099FF1B68329B68A2CE587608555325EF062CFF465B6F
184FB4C37A50F08B2F1CF6E09E92D6215A5C9BE511CF326505FC5EF2B72DC40E
3350D5D5358B49CD7A1713DE7AD5B63F462A77B6268B7AFB245DE6EE02BF2A97
B0542A5CFD6CAF309B7E10ECA06B51C2717DB5BDE8E80D6F29B33E9FE12AC804
AA0C6670967F6C3C2A7310CCC64AB48219EF140A1D9A942543FDE90924C9DB3A
5D667E0AF18066F4318101305AED22847F855960CC952649426FBD46FBB5728A
CA73B436527795BAA59086831567FDD5B3BA6931468115577ABD8222985FAED7
B6A1CC891D07185666E6E74DE886BB13021AADC9950E2EF1FB69E5350B281CA8
F05E2830521A7BE2EF1D993F75619EAC1B3A7A437612AB0E8513DF8F0F44E933
75553EA81965C83F6CA655BBD1410B7E8F600CA820DF8B4BAFE515BCC974BCC2
8E06AC06B07BB7E08BFA5CA8C5EEF8386971DE077781A9E67359AD8E75DFF208
727DC428911CB820B9211D2A3C6BE6A3ED0A5A2C1C623A6D6615F24FED298A68
097564A8429CB235119311B9888D0BE96AC4BFD340BCABB8EE589A69F749B180
3E3C1EF42D935EFB4AEBC656854ADB4AED11740BA3FFE21D9099979EBD752E36
A8EA33F541256C368B3217E226202117CFBE3DE2C6DBFB0BB25BB138BBF69BBB
484DDA6371DFFA6222F88F0886C7F8848E932CF0D89BEC7E504189315DE0E931
69236EEC7E3C7AD630E43CB5B3540FE72436B7BDC9E33F6D4B2E9C167ADE4932
2A5AA48B228CF68EE0032B1968EB88119A375D4DC1AF6E4FDBB4862DB295672C
BEF8C0780AD1CED1352575A76E2FB6DA0EA3472267A89135EB528CFD0877E8D6
E31A02A87587DC7D4030E320C514539B504A31AF3D7A4DD413750FA4B723142B
B074DCC9B55E3A49B384006A6320B55B1CF4B2482D465B5835341350E215B0D5
5DDC1F173119E073DB7DEED7DC4A04968B69F792644FA8B0757303F40F4E3D39
ACE81E6816449AA859A9754CAD99EAB3F59EBBC14ED7BC71D669091521BF6739
131AAC92DD77A116EE7E81836676237F88C519F8DBF39EC35FE36E3D2577738F
553F81135829F9118F4BFE20CD51190F2806A37A4B011776C7A572D2FCF18871
BB569C2DB5B9A3347F911C34150B85ACF4262B137D9E0FAF538F8838EBF6E79A
1ADFB94FEAEC654AE20E3A693C2D57AF9597BDE85CA476C09617B1CEE6A2B48C
DEB0450B99E5E00DD9825D72B3A9D95383171187CD0E33C8CD308C436B64C763
C407654A8C311D3B3C8F5901B2AC785B222E5DE6A3FC2A9B0662335A2DB9C80E
B7BF67101B1F500FEBCC23AE484F2222BFD38455BA078A1A500CB006AA6A7D46
70530EA460E36E1FCC24D0148C458B745876A5FE5919C3C624E46C02C72E1368
8BC50A383020829462604E0B5B2CDA9CEAAA07D3BFCE05B6A2BD017FA8AB3942
D6C7B09C6F75C799F437E74F0E185AD518B7E446C30415CA18B5F59F3C4DC209
7CCF7B2FC2F789BC49E4AB223FCEEAA22FF3F71E5E5E966DFB605D18E4B1CA2F
59697989C41141C74CAECABF8616AD95FD9ED3B11C918BB38D14FDE1FB20C560
4C70DC9E98857AA358B5F754BC18087F2F7BC99B501F212C04DDCF148251E923
37D102BDF468038B07C256081F5B8F3636CCE0A293F905974A0B37050C2ABC49
F5FDFCA8BE38549AE53F72B85A6F03B58AE18FC178D906B9BF3D12A818C8EBD9
90E7A12A38A89BDAD7E6A192877F8F9B9C3E5BDF412BF0E8C92A234BC8049091
778F36D558DE72E0CF1737994854EABAF8C2D221E0081D853369B8ADE0B18E8D
FDE785893B5EFD6019A709D99989DBCD244F0C11087A077D2103E494406B1DC8
1032B618349FC6ED24879F02A9B2C2924CD9E921B84C4E6C0ED0396E44A5667B
7AD3375595524D22C358B73374B5E7C4F285F9BD614A00DE6825572189A19315
AD3E7E3EE742E2EC53C778F677810DAD0C8F97E6FC8724E306E2E37B799A57B8
009493929890EBB3F0C168479B6999AD5B3C3DFE28AC43FD186B6BABA7FFA776
83212C8FAF6DC682C841008292750A376D0398DA95DF8AA168A651403C2477DA
990FC58E46BB65AB0676A40A8130F05A6CD8D0A2713820D615BA8AE46DCDCD93
BF182F0D752C9EFA34692B1E9877D715480B2CBC1181E6A95B05E9285F173BEF
A5424D243AA8BC7E87176773002363255E70443F86B6EF38C81511BA8FF4887F
3EE4357A421575258AAEDA4B5DD9ED6E3482283ACB506A2D6812D4676F3F6464
94832C8EC9EDCF022E141A5DE5496F54EF7A0050C0D1D2166C4A311A0C52ED00
D2305C70A416567F5EE877F0D165C4D4E6B00BF84FBE6428597412531988959F
3897745D7159FCDBB10B6459273EFD03520F2483A9E7FA0938D162FC5890998A
99BFE2406581D64F49F46B2D453844BEFB1931DD7E2CE0E540A398AA83F57164
3D64D9D9B4DAB92AE722C326065E48F4EC7FBF2E1158F0535DFFB59313804D69
60AA6F0C136BBED6E020CA50ECC4A6C90A628121B6317FB8E40E11E48E61DC6D
B3FD911235DC5A823A176D8387CA420A441980D3E8666043259B63FD3CE13E54
945B0A6BCB5633B1D580346D913BACD9742B308D575A409EFBAAE5D96D65773E
BE8D69A606A70A06E230290370856A89FA8D56529F252E7CC538FD5673744947
AA98663DA46206E7A75B1E7AC0247834B4558985AF6894363B2114294E668644
46DAA5CE2591121519A4117747BF9CCB78F9F8A3F5D44459BF81997F9E7A34F8
122CF87CF933F558E4660C9FE5D440B33AE6DD4220A093310E3E65B053A2EAB9
C183BD44FCF0C480796469C934250A5CE240A1171441D03FD75811F371B3895F
AA14A75448ED483C51D41076C0FE99D988D612DEBF78DD7EE23922F1A25B3421
F4AB7F9881955BDB0AD3FDECF4CC3BFC8CE815CF8DC0CF6D4C15FC110A14C6B1
7D87AB69D8E840ECB176762EE87EB04071EB8061B83E0359E6BCF317360AAAFB
7C198CD8DBE03A3CE7728D8819BF7826CFD7EE20738DE07BF2CB6AB91D17C579
3A8F9EDA9EEE6F64F51F736877EF6935ECA18A5F86EDFFDAB7E32A239E731333
107A831FBE6A6CAF1BB6D934295DDA357EB9FD1661523AE5AF8DDD8B198AC29B
D3B8DD91D49CFEA23E7D6EE63090EEC569D8FBEAF4E5CA52AF81F8FE49557D75
B147C85088703C68C018951631F2EA80DF28F24FD71D502A040CB4DACDAE1FC4
F892A2F092A3E45C31A6DF9C59631C5811D0CC79DCC5C2D73915AB87E8E31B37
12EFFC2E3FE1428B2DAA1853FEE27EF30CB0A494BA6ACDF6788877A3104070C2
23170140A7516D83EA6A99D1E4F756CB95EA4C2F9F4541B4ACFE9CA666C46C7F
031C67944AE235F4F872E636F24BA68ECAFED13668242C92CCF7FABDDB6C50DF
2485AB8138E3D841A9D8F9F80AC1BABB452DF2ECC9744C9C500556EF9EB6764B
4F8134DC429709776F04C4D5E4D04DAEBF5C475C7C3EB2EF7E035707E5A69C6B
F3D0C6660E636D6AD25B03A443509DE32694DEB838C8B360EBFFB8D45798018A
310214EB1672483CE4272074EBD88C9DCBDD1E51AC1353F7C1C6F691546B9315
12AA015585BF3EE444A7F201B20F79ED641D0EE7473C6E028D62D173D45A6D17
B4A1D1D916165B0BFB018964439FA7B3877858BBA8A26697C5929DF8B06BE1AE
01528C75262EF6C5B60BD81D2770945D3D6BB88DA9FDDAC13FEAF57217EC230C
CA301F89A1016CD564EF2EFDF0BDB775895C4746ECF87F40A23A8418AC968F2F
B30D5073CE2A53F750B082C4A6590AD501BDF6EBCDC02B48008D082AC5C1C042
7AD24E2C9976490B46BBC2187317D00BE0D30EB7BD4463F7A542C9A7373C3A43
39301CE2F890851EB3E99946DCD9A40E25DD883D396E1B7292137CEA7B60FAA0
52E4E631CD7AD08606E816F3E54E20DE4C1F23B16A9440AD00F6BA5601CEB6D0
79BB75886BE988058F4C5A79047AF8C75EEF3919EB6C5639046C6371F2024871
88A7BAFAAD7699E573E26B49D2D3520CE7EC27EA837EDAF9DBBF7EAD3B2858BC
FE820B4633E69F61EF0A9659847F8BDCD4238F576E09B591DD088900D4590818
6740C9412068CEBAB515DF56E83B52503F2A044FB87D284384D6AD0810B5407E
1085B1D5104BEC91C4AEF5E1E1F02AC9FCD1D87929953EE6CFB6C2FD8FD23C18
CA4063BCC8EE90AC1756B426A936BAED123DB1E3297770D868CC596E737A5234
E91EA9C52A86F396EC334621CC131F067BE82B7A00167945245303572FCD07DF
901E78AA828FB9ABAC42443EFEBDA80787A0F0A9682632A59B9D4E948DAFC6D5
74A33B9CE67A5639E34DBF36BE9F30BE03B0B8FE5F8EA006251B9E33FFEBB1BD
B2FDE76B58AF101A0AD64320E0217F90916924BEAA08BF7FF02DCAE8484C13F7
C5DEDB4EDC72B4042D30D14E8F4D415C5AB2A72BC3F9A63FC847DC244530BB6D
83D8451BC66D90AA787A9A653A4F75C63447142226B4AD05ADD80A9D7DF9C7A1
817250E78AD0204C9DCF16C79410605D4D744BFBA60FC22E964CE10AF512C228
F4CFC3DD85AEE7C9E61D62CE0FCACB72E14C2FDB87A97F47425D7D53DBEE6D4A
863D81138795F521C6A95DEC14BBB3E5A8BB3613EA73BA2AAE3FCA5D2E78ABF5
0BCFF51317165C88BAE59023144D99A71EDBB90FB84380ACDDA68AD46AC7AE3C
09162E8A4FC6CD4741B38836CB599DF98A21C5245BD1435E23F7395871AD1115
8CFCA33C04ACFDA3F0707836091A6260F217D91D4EA2F2B6FB87E2E004C0C5AD
DD2AB665537FEBACD5BC7C774D53CC63B57F7C9A28A5F0EA14F929D5598F4437
AB944A06B5EEC3343EB1EC04DCD09A2A4F2CB04C74B200EE87D92C452F79B850
8B5A3F364A4DD82BA880A7A5CD59F8F6000E1978A9EBD18D33DDE269A3E70362
6A0F204E36BEB8606041ED5927BF69A367EEAB44967489A34B460172AB269789
DDA62F516CB7FCE827E8B6C453F843B10EC212D258C3CAD385E8512B667AC78A
09A780813B1FF02AA967B12AAFAD9ECE68CFFB45E6E44703FC7AD68DBAA09BF4
E38DCE8FA46EF5CDFAAF3113D089D7C85E5859F27B8DC4C5D864F41B8B3B0F66
D6FBE907224496686847529F68DEA6FE86CDFE2FEB8DC3AB2D124146E08DA532
B277C8A73DAF87129F39235E00862E70D7E93430EFEEF4CA1441C63290D48E72
84386F6082C2362E4CCF3E66ECC33C744621B1FDDBC9F587FA9AD60FF1DD01D8
20488450336225C64FDBE7F75433FB87932A162CCCA0114944A1AC1E57C446C1
533D84AFF286AB0086008147E26E133E012707E204F21F5EDCA106FA0636B029
F12E6809CD8308A1512A4F3BBA0E02AA42C71D9E27302A88E52BB8B1924F057C
43DB0A92111ECBF02129EE8DF16E063B7BB9D34606831C82F4954E3E9F458653
B6CA43CE1F9164BB0FE39FBCF2876FDF951D8F9ECEF97273B7554C01E0528548
562040B9FEDE9638C09DB8EABA360ABADCD32C16E9F72E34B4CCD3A3F1A87879
31F61A705F34B65A7D17B8BE932648CE9E0B7240BCC29C59A4D84770FD34E97E
0E6CE2C95CBCD1A7AAD2312A280F0C0753434F33D438BD8EED69053BE9CBDC74
E87B613542F58DBCA1007FF58CD1A3F9D87400FB8A600F088414D8992ECDA0AC
C39AB210921E327FD8B10856C476FBFA10D11E87A61DFE3103AF0DA9F627E710
DB3D3C578C86CDBBDC0A2BE5F6D17EDD30DE14918A2AF0E1ED9254513D2002A9
CCD73361CC952A8238AF64FF352BAC31D36B071C4B68DF8BA0FE38D3A0188439
4AF829C39DB36BFA67124053D79DB19F848987C0F2E57CC79D75EC3262338CD1
3F13C659D762DB6199447516E1A5D4B3326832B50B45C50D8F3B912D34199D95
8BC7C6ACBDEF8BA575387DD0D73162CDDD96166F795C46B8AD5A7ACB5C30A9E7
9E85CB8BF53846F45871E08B42AF72B3F3760F5FA35BCD767FEE4E9808EBF054
38BA865AC5CE19DB05CF529A5DB0DFA4F1AE311FF2EE1311CEECDC45A5A65A71
E268231C07EC0F3AAC2337536495DDF6085A1BDB04A65CBB6605D4D72E11338D
87D5B02C7980703D1DF07EF2E12C9802AAB56426BFD7E71A8056C4D40E53D42D
AF400AA41C55881CED39A6EAD01854DB545A7D0E46716D81039491DB446916FA
5F10B5FF1AE36BAAB8A07828702857EDDDC1030D19928F2E260434DD44D61B33
1A026E3D72A9FC0E15EE51F97141125A74C5BBC35D82385C083D07AF133BB1BC
941AFDD9F34D5E0FDB49915C613B9E6CA03E2FAB053421BDE071AA7232D3FB8F
2F4E2C4C544F441AD84AB5DE68AE07093F707C67DB1DC2AF85CBA7D0FCFEE888
CC7FFDEFCBD573725714DAD9F6D32D04C681C42D15D8B8DCDEF77987C808BF0A
56664166455D888CA8A3B820DB6BE101296BDF05D296180E1F0068E431EB425F
A04DD315AE10FD3A72CBDDE3AF4825F7C3B591FB74909EE16F53AB0F444AEC23
3ED419193715DC8998AC0E556F16DB74C13D05E062FF908D37AACBCC9086AB4D
09E359B41CF74AED5B75C01085EEE6959AF5B321D1550C15C0E4AD2245D110C2
485C08BA84E13D79C4875E249580B771CDADB22DBBC1715016A91EB885A51BA3
F73CDCAD65BE718C0072A840C5D661E2BAD9236D480D9250A1EEDEC54A0D75E0
C853808E0E457AC644B40C5D496DCB96A463116389EAFF5982413681C556258C
6A96EBFA86A669F671B2056B5206CB2889A999E7573B012EA2371452E23091C6
5D76AAB3B0B47745CB8CBF9EFB538C274E3C64685888A61CD2FE2A3912714563
19C9B1F9D62740A6C1E4ACA130DD76A67920DBB1EBF803737388C01B84BAC1F8
C5D2AA3A3E6BCD63BDDD75FB5390E6DE2159D712C43EC39112935BA5FBC2D1C3
048DD4A16B2BECF9DC186E0B3479EC564EB9E63BE5C92779434A3938E1970D8E
A3CD40C7B8FB442058996268D90BEC85B51D5111091F54823FDAAC9DDFDDFCC6
DD12C114B7373759BE4A62F1370FEDE056CEE265838696FCEA5BF7EF4865F3EE
0054B00A9EF36E06722397867DF4DE78492BB8EF96B9D0B8AD794FC37229A534
DDDB4A69FCB5E94DCD2FB69D65D8D970C3C755E6F464E23802978FFD29A0F681
BB7C42AB16F3DC305839233A6D79FF1A8152419BC99C0B233ADAE39DC533F1D1
0843067264DF39491C34CB4BF88039971CBF0B811DA5D0453701393BCF3D6251
E80A93FEA61864BCFA907DA7513A5D5AB90346D805E2A2205BB410B3E1317CF2
47224ECF9FFD37BA6DB7283B75010E5542A389EA2F787A4693E254921B8DED4B
654A34C1C67C390186CE712378CC6217567E4233AB90D231BB07679EB2ABDE89
5E12261315A776E2579686DB956486C96942AD652B9188F2FFA1495493978225
54956039FCDFCEF8BB4382003153E604C23D313121A31905074446B1B55348E1
E2CEB827C74133EF89CC4C0E3BC93691F53282A0F0627B5C2BF0D24FF6B79AC8
74474B73FEB6FBCFE8F5D07B521EB0F086704D2F749380E92B97B1D4D15A6A6B
4A8E7F107E2E4ED3AF0A323F4ADF5BA2DBAE0C452EB77B9EB60BC8E8DBAC5E44
24AAD00B852219A60384F37D44F4096D8AE632FB2EBC0DDDFE6674552253C086
45F0BE1E25404BF8131379A057266485F454D5AE1081304809DF523EFE64D400
BA4D22773664235629410B1866D7A52B5AF7B22EDF4D13C1A0F81659D7C22C7D
D495DAEDFC651D4A939CCBFF875032E159EE437A2F68FBB9A796AD2042FF89AC
01843A0B408603CDC4D27FAA68D7A5407E0BA263CECAF34FF58FCCAD408B8B07
D84E95D6D79E0FDB6BA53C1C524097F7E1070005FE0374ADBE880B8E044E4662
EF0AF221544DE5DDC61A54CA0504D9C77E08FCF101D33E908A71B94B57A71E99
C8E97C95D6264824385F1E9C6AD73172B8777A6A9C884E2131126C9A2EA19A80
074BCB3432256BFE41FBDA108B3363B7102FEF09C25D849D7DAE91025A4C6D38
DB16CFE8E67900498C2F9834799128DF2B034852C673ECC4B4C9D77AC775F945
CF1F96E80E3B5528D4D09E1B5E78B3E352007805470CF8FD960389A736A651C8
E9877DF4A9DE3457D17C81740DAFE000798A2787814333C50AAFF69C863E0A44
8CA25084B8F3F8F2E1057421744C063FDC483737D18DA220D239EC30F2A4A83A
7E833552D0A83643478A3A066E2265E93BDBB105C2D5C2068521B1D65F4055C3
38C3101D43BC8F4B50E4D18E37D86325B248378A1DCD06600ED4C433F802A055
BC642DA69CB9C0C3C86327BDD6C8B68C6C14DBA851306CFD37C3BCE8AA1DABD7
95C477FB0CE298C342355B81E752AF4D91AEDB312FAD24E279B120EC195D43DD
298F750556198C024A0849365795E0D4CEB53AC09FCFDE40EC0A2F76154EFC83
56EC90BFD09D2EB451EFDFA251E9C4B888392C07F151CABAE683193992F71A1B
3D33AE7ACA07B528365AE5233ACEB384A165B2D50284860A8999BEF98BE52924
33CCDCC16C0517F50F406270CF873290E99A3BD506A8578376F78C0039EB05BB
1BCFB9788F34E0A1E89410480FBF4F9B7273BF9C21DB56697EA83892E675B312
9DC52A00D34F00D2B4433E55D01F120C19F0659221256914071E40F91E422175
B0B92FFBE2C5A9839BFD9A7C3AE5D2B7E74C9164FC764C168B3F14196D870F88
2916467E89A6BE6E65CB9EECE72625F9302F42336C8325B4972E875507636B1A
4CB0913C12A8AB542901AD5E7B28EA43908F716CF825DB774EFD3AE4D7F6B695
E7A7A4ED77EE109EFFBA1A6971678EA3492A1641851FF8280D2C1BDD3A42C2D2
49B9AEAA95107DE25BC5A014E43E107F0611BCA32216D81DBADAA3DF3C2ED508
A5547C4B8B182CBE28D968BE8AD8FD28A9EF8EEB25F6A230DC6AB0708EA90668
8B5BF77DE0552ADA3E14BC0B82F2CC37AE635B8764722887CDE8DB8724D14D4D
A223CDD16E6515EF06936511E033C53F89D5DD6407BB98B211697941A927BC72
A148E05BFE73E22391AD1D0DEC1DD4E91AED7FE13BE59AB0F6CB6B0C091A7A2F
6B6EAC7A5B4D39DAA5C0E94FEF733D60E8E89DF07C2A11C0E1F89B02D061B7C9
EE6270690689B0FEBD0B26DA3B909CE9A4FB204D7735ADC8F0822E69FE6393EA
E0E90E7FF7BC2333D4E0215D5201E075A8C4C7B1AD1EBF980096EC4AF841E416
430F8B44048BF93E98E66BA3E83FC00043F27F1E73B67016A5054CE6B4AB0A2F
50FD97666B5D8929A96E6D27DD8B231EE3322A5102B01F5FB9CA6867E652C67E
CEFA041D118A875D72F4E29A9CAB9E821B14F15B5E14E666526031CFC139BFF6
46F51DC5F7F319DB8265CFFB6ECCA09D6157FF1DEE444EF1A6724AF2022FE7AC
5F10AEC634DB5A4EC72E15DCEE6D998B0F691FE4DEE7BABDE53BB0D3F91FCACF
76618DA8FCC16348F20358F4183719B34248238B44052F75CA6D2D249929BA4C
2DED2BAA764A41DCB7D007C9378D0B6590CA0EE1B91FA23D9FD4292B4C730C54
CCBDEDBC27C886EA396C89FB414CAEBEA0EBC4C4EBD6F256BF0A00D19CB9FBD8
55ABBC9553CC600A72701A3C85A2F647F772C8099CDDB5F3D586B9B5A9D9CD9D
7AC974D14233FB6C00C5A8FE4A6821D4B1F212C29ABDFC67268BF1D3E3D29473
53648C62BCFD951918E3C38FC1840F33335BEFD663C5F21C125165A6507983B4
F3E713B1FC438AC303AE9B7A5F45D61E02D0AB82AFBE793D708AB98D5B730A70
DEAF9D6A80EA0E6F4883E39FF433F5331050894E44A16A51FBC10F2F4BD0EB74
75E396C85116AD2BF91C5E6B4441A41ADF3961D7FD5E439843D2BE6EBF356B8E
F15E932F1B9CE429F3850ED936A4BEF78AD52C58E87D8DF23E84FE05778A4195
76683C1339E7B6FCEE29EF790A51910B0238E0AC09431CC195677796930442C3
D5ED499C93EA6DA7C4680276A02541AFC56DDF37F6F60ED189A8C53FEEE7DF42
2104F1CEC21087B663C3DACC2AA029909FA5E5C57A79CE2385E38BFFC236639A
83D72BBA5A644DB6C7D10B8DCA687FB2321C2CF442724552A03DDF0BBEAA28E8
3B5C94175DFB9E11A2CE006C37053E7E9FD8A52CDD6E8F228ECF8742A92AB81A
520C6820937C4EF7A7AB76DFFD907C8B8C50EDF382D945688D606142E4B244E6
6A85437E20B97683C69DA60ED3CEA82C6FECAC5AAAFCF75083F65741B1017E96
CC181789DED779BCDE46F1D9E6E73B9BB7ECCED466FE1ABE97BF56C05BBFB53B
B1612446BF7C0E7CDB50FAFF50203F08B85E74C4DD08B8024F29C956C342A719
1D93FD67579BAAF4C5B29EC7AF97E7C8402B2C7BD06653BAED8B77D26BEB7B8A
F90D0682E89F0E9162A056D041B5F2C74A612BD655B38DF603DB446FF3C6B593
9318FB977CE1D9A30D98FD23B10F40A4179A6694A017D695064BCED8FC5E0BD1
993772BCABD0A455BC7E5C77CE23E3FF07B8CD35DF6320A1EE1E270FC43E35AF
72E7B36E3DCF1C4DC905B343BB72416574240E31C205E1AB60AC1B2610D72BF5
C0832AA63EE771FA86C42730D9E81805BDFC625C5717D4CE3E694D4062097920
58DF95E309EA2AF7D1E5EC95BA6DDBA393DBFA8C3C93D85460068EA4A2F4EAB6
C4248C541C5DCEE10C45F01235C74B135F924B2832924F86F4921448D70FDA50
4FBB83FA72ECB6F79F18081AD9AFD627C65663CCB66DF913DA1C619AADAF50BE
37AEA6F113FC8635F70145C70C6D603783ED842A5282BFDA19318E1F48A578F3
D89DD5EAA2982C75A52806768E1E86E659E1020FE645B6CA09EA5F707078BF01
E3EE886FA0B35416AC805310F3AD7D84D027324E19D24245A10E071416F358BE
EDB70F8524CB12BC34CD34C3251813CE12B7620D9A4354C3450F0473D5983C86
71BC0EC4F54A9B7A7F52C295719E6CEB1E2B2930DA1463937707D0661275B66B
BF342FDE26F6A94321C8CEA614A5A206295152CE0A04DCDAC19701D58A8335D9
7B202A5FF663188CD00372D5F1FE361E388ABF0767E7BE27FA203AB4536C63E8
4658AF0F0ADA3BD897156E72985C4E6BD2E7C6A96DC29BDE6718249305DD002F
50F36A89F0400BFAC3A533E44F41CDD215033EC03304518C35E55502546E6268
3AA35636606DAFC775360F8147D40CBB485DBC4E559069D50B198602D9A94F97
5BC8E57910FE940125A576E4B9BBD385708C19535E2BF50AA2FC7D4B4D2AD7A2
FA8C47740F3834E6B5DC983157D65B4FA5262EE96F5E8E2E8CB9BAD86DC5E21D
D58D7E54398EF4AFDA5A404E194BCC39BEADEBC959A8D01F20F126F94694A527
79B387B62E677AB9493F1213C9B5356A9CD88C2616430A0452193C353608A177
E72CD5BCEEF0235965AEDBF2AAB6D34F4564D288AC1B501AF418FD9D6B8576F8
DCC579206AA9F21A1C50D4BD7B6FF82303C2CC1B26C78B74DA6A52A4DE356AEE
07DA1C09CC4CF8879A65088C7381B9029B67CE9029093A96AF97F44181C189ED
DC426F4D950C13B31CB7B479C38EE15F034ECC85F78DC9DFEC342E27A763669E
F26D605E63794D01CB48972C196E0C10B2F50F32E1E3EFD8CE9E3316D059F2BD
5F29F98634E432A2E11FD0DEF1577EEB1C23415C912EF1F70CC3895F4598A5BB
79E23DDA5C9C7BA36DAFC8FF3EA182ACE501CF957CD9DDFC74A510E8F5B4BB96
AA7C31C873CC0C3EDFF7B23D8A22E7E606E218EEBE8A4703D4D84D1B7B4499E5
85B500D54F9D09641A683DAF8038C03C57418377255201AE91F48B7FC35D1ABF
12EFAAB723A7C816D47A9B3FDFA93E8C92F733F953814B292E99A4B6AD93AA4E
6FD216C7B7A8109CEF218C03B994916D5EF2A997E3D910E754B16CD1648D0D9B
DAF2E90F712DF8533B2B6D42AEA28A08F8A12C4E66B8D0996B3C557F2EF91826
92255F7A98CE9B93A645D17732DE6E9C8E81AE5C0DA212DEFFA85E2C93AB0EB5
09DB3B5F7D502EEA7777133601A5FFBAAF6FBF423892149E4AC897917F6E490B
5BFC1EE11AE4C309F99ADA972CCD4C5C47C34D835DB493AECF6389494276FDA4
925399C22379887742EE60A9D67E9BD70A8BE51524F36531122181B041DFA1B7
7304C21C3636EFCCF24A6425D4C7AB66D5AC4D1168DC5C66DB2C1ADC28A57391
4AC5222C8D98CB9D12F49D560B38FAA060611926A12356177D21B18A37B9FA73
32AAF569948EC55BAD355BBD85D66D6167A1698EF5155DFF6BCEC22ED954560F
F7A1971E39FD52F407E4BF5F3F15F919B6826AB02A989FA4CEEB0C836B4065F6
50E5565495A5978375ABDCD02EA24E6776FDCF88FA98DCED579E0B7970CA869C
E5F98AFEBC1391A91B145827DFBB1F3D0BE971812A7A83450DC0675C45C27E68
B7BB05D4EC307CDE098225A478F5F2F4C32717B3C9DB794DBF2975364992B399
6EA3B4F30C40106141EEBEF552F924CB26E9AD37F597241DFAEA7979DF9E1754
D92365F26CF6367091BD71D7EA1069F48D987D3E76BC14A663494B6A54765B2C
56A6AD522004CF1952D55B0D51CAE21CF0123F7E32B5C5A66149BD897EF5F0DF
3BEEA6276C9DC307E128A76B25716388C24A39C5E1B3C64C09B21D2C60459327
E48CF0D64EF0A67054E79CDB1726E58C5E0AB7076AE4634FE43454088DC901B5
BFDE965C762EDF8A0DE77A1F4BA087E7E54F4602592AEB49D4AEA35C5AE31B0E
D3280975DE77370B3A4C7B16C5FFC37C0CF2DA9F9AFAC453F01520EAD132A69E
350E84241DF40E93E667E397298427A0A7A59C4ACD748A13881C130EB9AD1F71
956AE9DC82EAAA0195CEAA1443A1A6684D8E8C187271907E4739469EFE5675C0
FE6A19FEC02697503A8436EBB3DE636A8E4EB10E500A144A602FAE78B968D1B1
7DF406499A2B12B953D0AE1984D78EF2399E862A27510A1E29DF2C698AB39B21
8ECC7BB9128F40DFF158529DACC58E38EC9F0B780C2988095FC3D498C0915BB7
C8B87263DEA9750F5D6B84A0C17F76A9F49D5697EE87F8FC5605CB9D8098FFDE
654522B62ACB96596E7F84AA941BC542785FE3A19CBF0E048FFD58759987EDFF
2D519420CE59CE4BDF4907ADA234C6DE77DC4957B683947D513A325C930C245C
7C4B18D30A7046A27AA007D54F2A1D812A8F5BB17AD84B0C414D416641505EEF
70B3490F7EF4F8DBCEB0C201C64F56CF4AAE64E1F2AA294C00718ECE686A95BB
66E9002D608A929061557B2FAA7C415012E5609DAD4EEDFFA3C5163BDF6F0BB1
92C8BB84303FC756C511864B743D5814B07B9FC3ACC17CB6A528591EF6B5DA1D
AFEC73B8F3419AF9EFF1090AECA836F704056065B3A405BDBC8C8E2F26349004
AF3D296585FC6AC72FEE0CD054A5CA5522B0F83620B26F55D7620C2C1C392544
7B86C43DF1DB154A97C0CC38585047A032B327CD22EC3F56360E4DA56184BE96
77D3547C4F27656652374315C1AC4319E18341C0A3D1002523E04BE24E0A032D
BAF708E596E8403631869981BFEE1D0526B20FB55FBF1205CEBCF6B1BF7F26AF
21C21D9B1B916F4F603DDB68D5C2E42EFDF0BDB775895C4746ECF87F40A23A84
18AC95DFC9E5D39349BE33448D2F6258DA61AAF47917C66C7D79404469F39080
4B9039E21F1AFC9380F26571E3B2C0966D0A13F56BB1A0E289C7A999A4330CD4
CA8DAA5B4EC3BE56EE588AA8EA7222305158759D3D702A85311C720E1513937F
62712B8A590ECC217E6BDCE13F09BDF18D95A555FE84DCE9B493838FE10BC530
306D2C11583E49A7C53391041E76B7BC14C0E3C03464CEFE78EFC1A193736D86
CCB53BE427BDF9D42B997DDFB57EC2C439660BBFD22A8C6771364CC604446A77
975AA682A1E37C877AB7232A2DD583FD795AD2FD055E7B3A1C57F0A516BF05BE
2CDFB5AEB07D0372ADB519233DD4BB1E32E3308C03D55F283DF5D3ED82456F5F
F014DDA97FDB080497081108B5A0400380EA3BA460046252E2CEAA182531481C
AF00E1E3C8B5345709E0843D17D3C5727AB54DC757EB0B27C2BECE3E39354BAB
BC6606B1DFDF91D076228D14876286D56974529CD78CADC41D9815A364DD46D9
E3EFF27C4492035D2304EC4F9083716CA7906B80486BB5C796A56BC65C70BCBA
DAB10AE54A0DD44C28DC4763D04D67994226B51CADA6D39CFFDBA38C11C7238C
738370C489CB06979549C7FCEE1F220DEF7CD6F56354DFE69300C91014F9CDF8
2A54C3EE8257A7A35A79626604E7D472D5AC3CA3DE6325CD929D4F12642CEB3B
6349FFED241A50B2763388CF4C4E5CE4CFE090C28F6ABA7456AF8458194B476B
F0FB5A606F7A211F72225DB3DB146BDB01C7EB1765E7B82DC191365103F27EC6
5E777C4FCFE93512716C82B5CE51D229B3BE5AFDD189B9D128BF0081E317040E
340128E6EA1FBF971CCAE4F84C16417C62E5891600B72E787BAB2D5F893EE00D
41CB48E35CE9C08D0BDC362F28C274C63378573CA78C550B45EE3720261CAB35
E3399B27925C802BFEF566834D19E8CF42FEF3EA9F9173DAB08D8CF41DC6D30C
3B8744042875AD434486947FDB4542DEE0C5255C7B2F6CD1D4E290C7CAA39A64
9CFCBE58EFDF277639390ACBCB6F9C5C70E555DFA1D8EF22E1869DEB557294E3
41DBDFA8FE95988647EC94FD87729EE873262F0FC065D56EB983207F1478ABCD
112D3ACD5D2EB86D91C2946D5B9FD8DECF9B210557E0784EE5F628A19E37CDB4
1CE908A51A3A0E51FAA60CF38A9C82BD05B8ED6DFFE2645458F781186DEE74AD
FAD34286908349280AF934EAE9355F75676B21D53206AB65DD1F7D4230B48982
9AF4F1C1B762DD12E13CF238935252C84E876A92C702EB5CC07CD313A25F3A0E
257751978E5B0B9CD71102E7EEAC4CAD991C4DA475602C98D1064DBF03040BE2
EE926389B997E7182C83525F3704A6431624D00AB8FC10B49B8BB78F81FE42DB
1827F994E9EFF86E090C5568984037781A7CFA7A9CB4335D687A58F61800FB46
DD1719B435C268C6BB20D3A288E01E2B9173557BD09FD2DF7CD369753B77981A
D11AC315AEB0294B62BAF5C7D07C9600BA99CA64A8DC5F8DEA7F6C765088BA1C
774F9086CCE35404B02EA8F5DDAF71C4BD05C92AA7C03A7F891467E7D491B580
3E4E32D24FDE0B7C56732957AC35E4B9E7046BCB6CAEF80CC2EA9C37AF5AC20E
96B00E1F966F05A9768824045B88C5088B012E82869A09552C199BA84366ABE1
553D2FAF26EF405C4D00E4DD9F83370A2CF3DF68ABE0CCCC8EC2079FE9F74D53
DAB010AA035CF38BA9EB3E3CDD069A8D0083467D88AC57C62ECEF68A2F14F10E
9A79CF91E2F23F5348B811342DD3A2B352DF1B67C1CE24D66DF5DBE2E04E2562
7838C93E0ABC541422736D76B0EBFF4AD9F19B4C11FB42E6A907DAD90271802D
FB0B3B29ACF32F3DDCB4DF8B5AC385B0E9932908C724EF9F976D08BCDC3AD62B
13E1AF63B076ECB3C414A1976421C76934BF679E354989D7F43374E15A1242DD
67E90AF41078AEC60C1F7D1E448C74467F8D71CB310BBF816DA6306D7C7C3F52
3B2AECD6C05A0A8366D4EBC86EFDB5476C28FC1B1B3E5FEF3A3B94CD552E2928
8AB0A6C8270A5C9A1C1B39778132988F62AF56BB1C140022F3A432901B021C75
5A31414883C29C68C3260535835CAA5EAFDE0C2BC5D68E6F05020580B5DED910
30783F8CB8D653258F70E467C0A77E0A3D71A628ED2C5458AED851AE1EBE396E
177C09467EFAF26F3773067464CB460F7DA800080B4FE69807BC5F37C37F7530
7C68061FE700D1E0F0E43993D3B05E305FB06C893035B2C0BC715F29848F6101
D04E84C65AF8E73FD3EBCFAC71BD5CAD1B04B9A3B61C87B8BC5CF59F64B790DA
DE8D58756157053F86FC3AEFC522CF56EDA6F3147B3861904FBF8BEE6DB3D13E
6C365DC3211967EEE2D1AC50EAB6A0858F98FA558941D802B666A82EFE254436
F63898712D63BCE010820B8BE216B0422DFC5718733EEEF10A2E54A8082A9925
B85AE29A28D43710781EB7D551626AF111575219377886BB07786221F2C415B3
480FE8DEBF394D18921C6015EFCAADB8A330B36B22482CF96FD2696A48C832F4
1C5C21E4180FDE5E21CFCCAAB385F35027E9F3044CD8B0B2601BEF14C9B4191E
97160B441CE68DA94A34B11825621B5705E957F931995C83EAB1684CA637424D
C59853EDF43C8225B51D49C48DAB045F59616134880BD8BFD50CF44FCB6BA898
8B30444C01F6B9196CE303564392765BED60EF9F93B65E328BC84527AC936AB5
6072F0A343B7937E3971D22426F200FB8824E27D3B1F736466EF878BC60D3E3C
0AB0A894F08D7774102350E15460EB209E5D31C08A273642095B1E04CC60718A
2DC2BCD99B342028768B4EC17246D24B219615F18E949566B2BD1AE555B21345
5389704F30E19C52DCA1388C7F6E8A1BCD23DE641D62164F98AD750DD893E306
CE5698A8FAD2D9BA1B57077BAA282DD75BBCA2375339927906533FC039FEB875
D1FE306EA3D76220182D57FB18DEAE2349F27FD72C7EC4DE9B14DA56A83FC9AF
59940CAB5680A26E061D2F609898B8F0E126F26BB682FE26B34CE15E0AD3762D
59AFB08F998260B6AA71DE7A693D37CC55B7C5453227D0FC87CB2DEE4B3CEC9D
872E3D11E1EDEC05A8C7D87D28E2817C4EE770072ED026236425D096E84DD009
F55A48C44561D2C8F70AA55662D112772F72C3690F0D2E596A55CB7D5A7492B3
39AF758E0458C527D07286045CE90BA96353E756C1A83904F00C6F8129E347C6
489FD4FC798AD7B405F2C3122C7A472C610CFA7265C2FB75840E61D84ED7126F
5C00862A548DE99D8304BBE985CB6DC92F9902EEB306497B40B6CE001EB5EE7A
9F636F046CC24897A60795E9EE1DDC98E280A2C3B8DF12C1E9C72B6B090AE610
E05D64C777FBCB70707F4F0F088114534F6D36E4DC699DCF2556E28A2DEFB637
1422CDD07263005CD57093D4FA9323A756E7A67C5DA7C09EC09D104723BB0226
46129CB93971B47DF439558CB53CC12F56D3285CECAB7092062D14EF1B8897DF
2D441935A0C19E7D67C5807A4AAB6604B0285C7AC913CEC83CF9F300831FD25A
9A7CC28BF9A831ECA28E1110862C783931111D2A9DAC0C40A40E59586DC34AE1
D06D51FB674BF0AB80AF539AA945A04F7063DF2BD3F3C6CBB52E5D75AB74E830
939CEF9EF2F1D05E4004694D39E05F5E2AEE30F76D51A3CF5FD03B53455555C0
0DF6D98F56CB1C96D8F1543B39C5A97D20627AFB7530BBAB79E87BC312E08308
AF5D68719BFBF807AA616965C72E9490C31153EF20AB5D766B378FE86691BB12
83618D234ECFE8B485C43A6B35C9FD1FA0EE61B939ED08F884480A3E19DD1347
AEAE82C2BF34FB77D107652BD59E002C56B3DD423BE0E12DA3CCC0066047253D
42A7FCB3C1780A0C4E8BD60CBD056AC50CDCC67FDA475E13240445D46726A6D4
5185C673D2A71C5E47E6EE3B813136F26CF1BECF1D09D628A35A51C8EFC7CEA6
075FE46A0725A98DAF86117A33970726EFADE71958B056020FAA6FFBE7DDD4DB
C0EAF83EC493F772992C5637092710177BA2E331993DF752B5F5875615A910D7
9DC805755E7349D3325CD8FEC4EF92AF6B856AF233C3C2792A42338D892C8E1C
2DAB56438F1177668EF11064986DDA53A77FBE2EDD38E22689D398B0152786EA
3FD2E3D8B66473C74888BB0C5CE966D6420D4CD90A6CB9C78D821B3F22045E7C
DE9AB12D3014B6990EB66FB8B5C997DF742A415DAA0CE1B8745736395AE5FA46
D325073CFAC939FDF750317DE1FBEC467D089732237DA7267C0C4BBA87AA3EC7
166170B80B7355E802527EF62459F2E6B90131359A396EF818B1F1A690DFC24A
14981F3DB5413AF1E242AB56A36266E2E755FF986BC9874FCAED1DC2C4FA947F
9D7FA8CFD3A13D2D1BA728ED38E8177A82B3267FD63506A288569C57B510FA6A
B554C8E091BED2FF361ECADB0F68B3324E63C2C65B63380CC21389E8B80209D1
347529714C5C6182FC4CD1BAB403A0D2F45696C589BC74CA556158DA32EAD646
29BDED74F3A68634E1DC26FF4CFFB4C7071B1161732006CF1844791A57ECC890
FF55B9A29F62DF8CAEE9EBAE83C8BCC428200B885502DA3DEC224FE358188D5A
7D07E0B03C0E10F9402A1B07895F5BFD7E7FE6143ED1E67AC5818BCBA7DE5211
6A288973A1169C2D640C41E27F418043DDFEC9A90685C7C24E70ACB8F6F32B18
3E1C3B309CA785A931634317FF65A55CA2CE35711BAB294408370B4E09A6FA42
7779CABC515EBC1F7AB30CE153914AF9CBDB4E5CC3B9F24F57B2372958835E14
B89CBC472FB1568EED4311DA10286E803C16F470C1809510DD48A2D0835701AC
E7A883554494BADAEA91C847A7E641CF0ECA67DE7AE30BE86371142AD689799D
8EA9F68ECC58042E9F83D75D31B5155F832B8E45C03DC09966F495E935D4661B
01010AF3B1182B3020CF5FBC04F10216851E4746DDA77298AFFF6B3CE97236BD
5A5D3C4084F4D059D85D2F2AE37966D8C40BE57B43B332643DDF8BBA70F3F8B2
E74996F47934472E726D99C005BFB75BA140E021AD5FB7DF3F8E587B9AAFA383
B650A2DBAC101E1A48DF4F90A217AF8CF485A5ABB5580DFE060DC6D71CBD26B2
42A934C2694C1F1F1DF76A77E8CA157F238A8C6D8F7A15DD1839A36837135957
DBBADE062C3CC58863428B0FA03C14712117650C8F7ED57604871BA30D38BCC5
AF496DBECF0EDBF54123615C614A139EDB9C7C151161A28A5FAC30FF2ADA0826
E26888169B190CC8B688A66AB27938C195BFBEAFBBB45CFA0EDACDB7E509246B
AB0354808BB653D7729CD7659281EE5850BAB94B4FCC6357762A7E2A4F447C69
A09FA25E667EBFEDE944F6
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMMathItalic8-Regular
%!PS-AdobeFont-1.0: LMMathItalic8-Regular 1.200
%%CreationDate: 16th September 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 556 156 0
%%EndComments
FontDirectory/LMMathItalic8-Regular known{/LMMathItalic8-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.003)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMathItalic8-Regular)readonly def
/FamilyName(LMMathItalic8)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle -14.0362 def
/UnderlinePosition -117 def
/UnderlineThickness 36 def
end readonly def
/FontName /LMMathItalic8-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-24 -250 1110 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E7AC5E68123F9DFAD1150819714667093ABC1E
AE2ADB86A92EDB8860BA65C926367BF8FAB5CDD2870C4AAE2B39538243DD06AB
AC3F1DAB2BBCCD33BAA90FC33130E1723595D32CCD11943BC3E719FF32DB8933
A43C6E33162B65403A3F10A1CFBB9C6EFED4FECDA364F17597D60F298578A3F4
1C207D322FF2A75B07E2715DF2E396BE7AD112356772A65C14D49D03C7D456E5
1A27C2ED815B30E268B02FB1D2E769067ADAF25F28640307E3A89F0B04F44A1E
1392A44B8AAD82CED1539B6A9CEBF441EB81775C7EE4CC12313F31FE710DD429
4B1955DF2BF7A88E1EC21DA22A63BF63E89C913EC01EE10A0601D6FB239DF59D
2CEE7667F4CC4BAF660B24F635F981638F40E8CCF07F21F5B5FE3B5C115D1000
0E4B2ADAF7B1C53935EB7414421DB49A59F82D98D08351CB0BF0C06DE836CFD5
42D68D51AAD4069871F257AB7733F8EABD731FF9B0E3AD64000BCDBBEBE26F88
C96730B45C14458F42927E24318A97B48235E5FE200DB40706E9B41AF7CA33C5
67BF7766BD396006C5364D1E736B256538E5D163CDA75C4F419620D5BE5DDEB1
F7D7A55B5ACEA2B2EB4B78997398C7D38B3D7B5774D980C087236ACC7346F518
7607A19E85C83E2C6ED4F3FA8C15B65FC3D117BC5E3FFE33A5B7A69F7F7159CA
667D96B5D03E4C5E55FCB1F4E2148B4B8DA87567988F07CA181FA6A3C3C30A33
80AC6F4E92903C47BF489A2376AC02B00B8CD01DE080C96A452D52B4B56F9520
B85062F15C4828813D3694BB4BD3512541C82005C9AA5C065476148A4E47DBD4
580CB1ADD206D19E7D653E2690FD48B252BFECDB2C64C96F7477B2E5EA0593A9
84841E96F931F01B2B61C26E8450D5F2B37B51EC364BC2A1233FD108DFFE0F00
AE57465ADB0191B38D14E89413FCCB77A9FCAE09F59A3F5C352570F7390BE91D
178255E10C02CFB7B679DAF86EB351BDEBB8A7D4DBB9C65715A1355FC8D2C355
BB452D44AFDF7E25676F3ACE7772980137BBF6A5C4C136C45CE680D23B992D7F
7544FC9F70CEB83E2B66980ADA7E13488B61554D8CB264FA76074355F7FF6C55
FBF130009A03EEABEEFB1ABC2BF844196D67F7A6D7B5F71162E03FFD780CDCE6
720DA5752962EF6FFEDFCD9C2CEA3A186DFAC113892B6E7F1EC8B28E99D09742
86959C4335F1C11135880D99DE3167583CDEC6AAE7ECBAC9EA9257EFEE0606F9
647192682B5927B29C697C5D32A76F09EEE6DF6C47E27EAE240D40BA1DECB635
8D99C89F6D58DA18EBDD98112680C1DCC824DB5B9DC91E6DB672E35421EA70EE
D9F44FD6CBF46AF8B6896762DEEF917F9514CC45D53201F6803F12569A19AB40
AABCBCD2CEBFBC017C157B8A1A0C0C18B28C35616913CFA42C296BD9D9626779
8D48C5626304D7C258E50A0CCD8FEE7E93171EFB47D339D60B83B146A2EA08AB
3334B1C71ADC8BFE8A474AB0645C851B970E12BA04D7AAD47D97444D1BDB0540
89BDF98F38F6AEF440A1493A4B469822A9B5DC606DCCB10B156106950D05F8E4
E84324F3F4614FF0D09AFBE2C753A26E3E75C35CF485DBFB60AA78437EFF501E
E89F7FD73EF3F3767EB9450FD76DB4DDC0E786AD0DEF60DC85C85135D5E7A2FE
27EF8AE77972C9278437CDBB7E0659483165AC57E30B9BB79EA6D4886C79435B
E04C7C50E4FDA0C146A7BF9D155B1CE45DA28B7A4C58D2E429A2943C5F7D2D78
EE49B4CBA125A682FD9AEC96E70B0B275AD7CAF01861C9D46107CFC8BF3B078D
61933FBA2905184BE4ECB29482F68E3993AD0B930CA6EB2D3326501D67FDDC2A
1AC30300DEAC8D44E3AA0D9F4E3FBF7AD9EF2830018664E01B8C6B755A090012
78E195B7E4BDB977D67DA43440BB1AEC475D217043F30362442456690A9B60E3
52C03CDBD2A2BB086898277C15B8B64F6434C943E2A5E200FF64C8BE1A11298B
3B6CD602D217399E2658F9F6DD380F4649FC1B2A11921E7E2C989F2276618259
665A16CD0F2D576F8B2AF2814401D74A46389F9FDAE5BC711151C6B5180C28A2
0ADAEA87760A5BC63CF5CB993B286CEC59960FBE1B432DFF0FAC8E7E4BAAB9DE
55C8962948A998415CB0BE5C196AAC8AD75F1A15346FCC5664384531451CC7B1
81898BE176F4DE2BD0EE9CA0031E04705DA86FE610D3264DD069D7EF34A67E5E
6E336968152C554D3C9107BC061206B5A602070E0DA967879DC7156E251894A2
A31A3153399FCD7A23F49F6022F59A5E33B24BA11BF6591897E04F2F2FEC1021
F71B0220B9CB5E3315B95F4B25A8A8D0459A9D9E1FDF99874B655707887B2946
85C0A81AF955EF74D6A55001D61A53C72045892F30B52D7F0D7344157635A738
4DDC4C54C70F72C5BD122BB256C3CB95F38ACC77BF1881CFFA819C1EB4938EBE
FEE02C48EBCA2083FBDBCEDFC15ECD8ABD7346B45B6CB72517B9D9A4E47CD7DB
9476A742C178B2C83B2FDE708B33359D0354044BC52FB26D3CE6EA9C072F61B3
2FB6BD131E604312F19D7CD33E133D63B6508B0FDDDA944378FB3575C2
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMMathItalic12-Regular
%!PS-AdobeFont-1.0: LMMathItalic12-Regular 1.200
%%CreationDate: 16th September 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 833 233 0
%%EndComments
FontDirectory/LMMathItalic12-Regular known{/LMMathItalic12-Regular findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.003)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMMathItalic12-Regular)readonly def
/FamilyName(LMMathItalic12)readonly def
/Weight(Normal)readonly def
/isFixedPitch false def
/ItalicAngle -14.0362 def
/UnderlinePosition -175 def
/UnderlineThickness 44 def
end readonly def
/FontName /LMMathItalic12-Regular def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-31 -250 1026 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF13E7AC5E68123F9DFAD1150819714667093ABC1E
AE2ADB86A92EDB8860BA65C926367BF8FAB5CDD2870C4AAE2B39538243DD06AB
AC3F1DAB2BBCCD33BAA90FC33130E1723595D32CCD11943BC3E719FF32DB8933
A43C6E33162B65403A3F10A1CFBB9C6EFED4FECDA364F17597D60F298578A3F4
1C207D322FF2A75B07E2715DF2E396BE7AD11234369CB38BBC21C40020C4E57C
950DC4A5CD271B5530E91DBA55EA1A3BF584D9405556EF9C802B109FF1EB2B0F
C350D7F091E7B613B08574EDA3BF27099BC2EF0E503A4C4724614A73AA054756
A503BEB31E3FCD96F733D0C5815847DFBB66DE4968A9B389FC00C2146C4FF68E
076BA8B3847A3D8237D36A6BBDF0096290F1BCD02CC66B12E0070215D5D8306F
406DF7590940DE35CA0854D3609249AEA4EE9D3D377A7996C1CC2E940132A90C
F633C774985DCAE8E9353607B9059DD211265A0A346B1A062D80C64B5802A750
D9FEFA3C9920A3DE942C65BD08060AF33C91CFF62930F65F9A42F70B83B0E077
E169BF7F5D84F15D59F8A74BC2EE4A7F3ADE36F38C3A661F4CC9826BF73D7F02
D3CCC267927CAE22B5ED695D212FC3B669F9BE369B7A8D325C3FB9D552F175EC
29972562517E91E7B8D570612CC50B1A5CB6B94D030B0C60465EA21631F7A30B
44A47143D0C2F942B5D76384B8C3F2F197BB3646CBED3DEECB6513D3AD460F49
4BB874969A3663617EB537E75C1C1BF92749F9D147080EFF78ED285C315BAFA7
D78B7B4B8B7CFD1639EA303ACE986EDEEBA9350F92529C47EA7689779BD50CDB
D1B3A68B383B54B51F4FD77D6458F15AFDAB471DEA9909CAB29840091391F2EB
148588D02607411F2E802B9CDDFFEF1C1FFCC9EED0405371651ACF30808E8C57
682B734916EE806703B2ABA2F6910E0C75BCE10A94FDD1ED3E4FDA7857341427
CA0A4F7D30151BEB8E3D351E1E100A8A75959D11122C83A5C0C4C87214413B25
A6BFE44A42D446E9C4ADBFECA756A185E977BFF8C37BE1840CF90BED14A3164D
A8B20DFD9728E6BAC7EF9A114A217DEE75884EF4B9C60C040E8FEFB94BDCA9B0
43F8F6EFC1F52768B6086C41EBDACF46445AEEC02EFF10D4FE13601C3FB16EBB
96A0A60B69DE009F15549E0A5D45A0357FA8A5AC12E289CF2D907A6EC2FF53F9
8821703295813331DA7761B1A0D1337F0779776AFE85BE8A59526694A0F4EB05
67316863FA73E29895CBABEF51AFE1EB024F24F6FB79332C017A9411BF924DE0
E40A24B0E1B797094DD456CE9AD3AB8669A69121B16C33CD949DC6E4C61EB734
7FF6E9BE216CB5DE5D367EE01C808604D05C01882B8F9E809F175E7E2CACEFCE
F9F8A8DCD5A8D78D4FAE8C86058D76D7D87C9706B58EDBC0FF8688D409030699
A9400BD959FA926E4D0AAA99AD3494C08DB4EC5579BC2EA34038A1A6D39809B4
FAD09D001F9D8E8C75650D5793750F8D2CBD7B462C08C8815468D5117ECC226E
9E28399F34D0F20F1B971A2B82F65E941C3331A1DE6F4ED0721BABB58360F29F
D0697B94F10443D0E959BE2F3750C1BA04490CD0F63FB2948D5732643CA9FCB7
35BE5857F22DD9BE6CD22747FD308450AE7338B33D7969A92EB33FF60BC273C6
0CD13D202DA61705B849E7CB351ECBF0A3AEE210DE5DE94DEBD07C12F50A5E7B
73647BFF7062E4427FDAED535A8E130B46D342AA73EFB662ED29D40D75D22C71
691BDDF8EF4748B927497103338275E1C170CF62168E843639DE244B8C12D89B
A23ADFDDC02A7C1F9BD0A11514B0D721108B5F2D3488996A754F3E4D6F831509
ADE62B6D8D354D135A8BC20698919645EC4C582D508B7AF384185CBC91E02954
564D93FF56CF26A875655680A26E061D2F60913486B0D5E737B0583EF1AD01F3
6A83F91198CAD8962901C0507A0CEB3CE682022359D3BCB9528B47A12803382B
EE920FDC0108F6FB56D6579770346CF92C32E029B387278769BB6E25E808668D
F5ABB0728C7DDE3A5E9F665AF8A5A7A94D2DB98A466FE912EE340840EBF25001
9F736B0BE7AE8FCC9EEEE72D2CD5E415EAC7A05481127D2EEE8F2575B9B86097
4A2444D3E5239A1AEAD1488E1F1D40D6BA92C3A32A2508C09D0C42A4BE97ADDB
DCBDDDA4E87A9D140CA8215BE167083176AABDDD13A6A87466BB5C0B2ABDAD98
8E5147C913B2E2A96821ABD9CC0AEA383AF667FB2E492AFCBEF4C8E9DF3FA696
7F6F5C9216D2A004C465F93E9719ECCC2067B9FFD03692B957A6C403C72CEBC4
588AA1B9BECEB135F2B7512F975B795C768C7E373B1752E5CC154B487758C76D
D6279C65B3C2BA347B54992FB73B389ABFF71013A6D1CD4EBD8A01D2706C0FEE
78D7BE40523293462F1D0ACB91E96140E29F81CA0282DDF2498B581DC2C86EEA
03115CBA55BEEEBCF12307F7666F1933D5FEFC17D1C206B95BF923A2C8FF82B7
CE2B2A340CF97E04922916E4B0340B931A7021899ACAB442A19D5A3FA1ED02A1
095795A532B41A962FEC47850F9D059F96B22E0104D449E3DA6A90130D0F4332
CCD17B5145AFA1143702E12588A08B875FC6106FC70AF4C64E342C168A811EDB
8BFD135B1DB0BF4C3C7F941FEDA136AFC5322F9286B2B842FE2D1D320EDF21B3
BABF051E74618E0EE5C871012347291733657C3F4A005DF317DDF592B4B16FC9
5306460D7F1783EAAB8031DE87E768FB47D15B31BD0EDC50FFB6CDCFF04EA308
6B1222C404906140559FD50974EEE38EDB0EE51FD4DBA20774C7A8903496E3DE
96542600BAC7D5F0228C3D1D246A50918A5A80D25A8543CF2B521335ED679F1D
72B36D31F1282AE3DBB8318D208E0B7CA284D2D531A33F9284D12E22767FD6F6
BC5DC527797A006E37F1918410B13E681C971AB052A0F1A8621921A2AAF6274D
426A4E44702F8AD44AADD56F9F2ED3E871EEF31CBC64424EA1791C48C0C55116
61193900FE524BC93D2F55AA2CD8906BA1EDCFD0BA5E06178AD412224D38B1BF
C8E017EB454B808A3385E9B0288058967F4A2C82767767341537FE95A70B3D63
0F4224B0758F82DF273409621E590D8C862F467AEDCEBFA5FBD317EAE0446D51
75239A5B350C57AE24EEABFF659D82AE32A89BDAAB7083B34388394FC2AAF242
059AA51DD7CD685E313DF10F430CE9AA6085272CFC0F621E7C1B309B9F81313E
625A41875CD583B214D4BB5D215353EB77AF6D7D27F8FC7641CB5FB2EDFF205B
25DAE90057474073ED4A4760747BBFBED5EF136637CDBBAB4667AD197A362563
AFAFB1FEE7B6B9C3C3FBA8BAF4F55D0BAA6A13C77C9336837D837881A3044828
27D6333842920447A6DA484F083D2B7FF71D302642CE2CAE16457991E64AA2B4
91F607CFAAC1E697737DAC53E8C75D67BEE7952F76AA40476E52989871CCE600
42E3596D4A83B1F67DD4F0ECC8557083A4640C3B4888E662B2ACB4A9CEBCF01A
82A6B3955E9558FC537ACFA2710A5E9D1F4586647262E9A4F5947F4963B2E921
151EF8FC4627D8686396E8C6AEF9CCDB0AE03CD93199DC0662B8699A58BF4332
1D8588A77682966238A1D13591094CA565B6CA98367EF43DBF07ED1791895147
39523752C2CEAAB3C330F66F7FE78A29256897972DE5736423DEC5932529025F
7379134D73A144BB8FB422B7514355B359902B19D37546F25E3F878B0205428A
6DC040F9D8A37D8C9CBBA2FE2D9ACB28E0471E200972D07E43B344D932B21798
BCC7CECA9F5CB2C644DAB026162AFAC558EC025F01006E74A98F1BA3CC109FE1
AA2DECA7BFDF7B30378ABE1353E89A71EFAFE8CC1860D79CC1EDE27AE083F53A
C35EB13A5E23C7A3C67E498151018110C7072F5105270642FA7B82440467C81B
28BAC1759357BBAD9D0A7BF339CDA648F2E8C922F9921C25AC4C35CD9A2D751D
3DBF87DC5CF9629EFB9E78D1FAE8BD8386EDC716F00B0EAC936A42FEB6FA4349
A180D0015D3330230EAEE0C3CC8A1419FDFD84AFCED69E4B247843FD390CEEF4
D743EB35D440FAEE832E050F551937D7B1FE1F6BCAB38912E8A1623C4BFDBF6E
24D693DEA5D4B2A9B900709FD2ED541DAA786886ECF4894C4782F32187C593A3
20546092E4D2C15494816E9C0D73F929BA32C32C94E69276500B512CB21B5DE6
4F8FE4B4E35443E6D449116A508DE7527920F306AB395F8EF690071D931FCE83
CFC6FA4F4B32F71005311C6C01F47804C9F76CCB16E5B1D62D59B7C81F809D50
A18E4CAC6FED9AFA650918BE04B41C1894E754C2A31DDBE50DBFB649CF29727E
326136C2F273F2826280A5CCA55086F8055D52717AB8DF9932FFEE95E3A6BB76
B6FD60C581E630CE7C6FED68EB60ADE798EF7781ACA354364AE54FA60C6B631D
936F12CF272AEF09EACD7105B5D38E228C02203BD76F2E0B1BB1A59233B73200
5FE3852EAA87A5A70E56982793DC50134CE807BA5AC444FDD78BDE610F7B3C07
F837A3A520EEFF70732D20A5113D3894DDAC1E5B0FC3288B8E055470A1D95AA7
434164622593C506597581840457887F3881C8F1E9A6397468E697910D7BDAFD
2DFB3D399CDC443252483F0875C7104A7AA08E9B909E73FBA3D9D30DBB576FBF
70DF917127C9FCDE0F126DB0AF08B2DA22F8DFE3D4D01BAFB95E2774D97ABD38
6DD9868F65BA8FE662713FDE99CC12A8F4BCE109F3CD2CFCF40904F4E7D5E753
D4DF8005524DC09852F5B47B4F1326C28294F9D8ACBEC3FA19BE91449DC5395E
EF6B0FAC4D7290E3E5658A0ACC6C5332A3AAEB8CAB7FE7F3E37C2F6B0D352E3E
F659385C041A1B86FB7EC6A030B8B562BEE573E0F7B1E6E2F9007A22AE9C9B78
2F069235CE44105FB993D9BA2D543021F2D6CE60F5B84CEF84612A1714134014
CE9B5BC9BA9D49FA040D5FE7304A5B978D4A5080707913A7D6C56B62AFB70D35
76051B76EF1785BF53073617B6D2CAC139CBDD09EDDB9389956E2A63B390962F
AA2345BF1CF04A3AC91C7D72468C9DD465C3D28ECE4DB75D60785074641C75C1
98D8F0AC25A7FBF5A2D2F49B9B77C1C6F24CEDE9DD5242A46B085F49C543CD7F
C8ADFB1153444CEEFEABE6C7F19E451A386097D2AB492C427A400197AB0D4C0B
85AD19E3F1CE236E2EBFEE47D520B55D47ED81874A757C4F633D5DAA21AFAF0C
C3A1CB4DBB6ACE
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: LMRoman12-Bold
%!PS-AdobeFont-1.0: LMRoman12-Bold 2.004
%%CreationDate: 7th October 2009
% Generated by MetaType1 (a MetaPost-based engine)
% Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).
% Supported by CSTUG, DANTE eV, GUST, GUTenberg, NTG, and TUG.
% METATYPE1/Type 1 version by B. Jackowski & J. M. Nowacki
% from GUST (http://www.gust.org.pl).
% This work is released under the GUST Font License.
% For the most recent version of this license see
% This work has the LPPL maintenance status `maintained'.
% The Current Maintainer of this work is Bogus\l{}aw Jackowski and Janusz M. Nowacki.
% This work consists of the files listed in the MANIFEST-Latin-Modern.txt file.
% ADL: 806 194 0
%%EndComments
FontDirectory/LMRoman12-Bold known{/LMRoman12-Bold findfont dup/UniqueID known{dup
/UniqueID get 0 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
17 dict begin
/FontInfo 9 dict dup begin
/version(2.004)readonly def
/Notice(Copyright 2003--2009 by B. Jackowski and J.M. Nowacki (on behalf of TeX USERS GROUPS).)readonly def
/FullName(LMRoman12-Bold)readonly def
/FamilyName(LMRoman12)readonly def
/Weight(Bold)readonly def
/isFixedPitch false def
/ItalicAngle 0 def
/UnderlinePosition -175 def
/UnderlineThickness 66 def
end readonly def
/FontName /LMRoman12-Bold def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
%/UniqueID 0 def
/FontBBox{-476 -289 1577 1137}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0525392EECAC163E584A9104D99AD0BC
1B1844A0E222653FA481B8809B26A46F4C483A5D7E95816EA6582584156CFEDE
B994ADCFF4645140E3617E4D7E1B0E4541CB9F562E55829B4DD880AABE2229E9
4A9FA259A734D29BBA91BA1E2055CBEA4339BCBFF98D32CEFF11F296225CAABA
DCA10577A5D431B714726C1278D8101ABD1BD8D0BD0174FFF9148F8C61C241D9
2AD360A28616CB4A0670C1BF10591DF32391231FD9ADF097C47DF0B87CBECE1B
8126447EAE1564C1C1A82FEFB61C5F15ADB2502457074DCEE095549FD9D8BC58
757F3BFADBB5865A9F4C6B4E37AE0A3790E79B4A3CC477140D5BFF652B59E400
223C83D4E08A2406824F883A52C6DA76EFD957D5DAB0EB5CB1111B83A6ED56D8
E02845701BFCB7E954FF5CD309C679025FF0FE24F12514DF0FEF86EC20AF9326
7CF08461753843F4E3AC3C486D6AE78F03909D8DFE1BCD5645596A486C156CF9
D549995066A7AE7B22C519ECE348BF3529C95E2D1ECB832C24FCF54C84718CED
6164AD8035CD1E938B7726CB36CBBF34DEC977D42954E88925EC9033EE14BAC6
F9D6B54E85C0EA39EF3A661EE4B82D6F8D529D44C855B642DEE4AD670824A86F
06287DE387927F86F092989624FF57E382429F14903B387E9AB9787CDAA4EB3B
06F3473A63B31C176C03F8C931A5B7B5C47CDFE2068072EF520D355530600D28
04594D8EA0FF6D130231BB08227B4CAD7657791F89549F92C7C0D07E12044BF3
D9EB41E97D064DC781C5E5D76F5F54BEAEB123C53D41663B0C2594354F39D3D5
A3E1397FD2E40D5E6153592AA3F4EDA899BCA86F2935FBC0EB8D826714DB45A3
932C9138908E429806A32A74C464169625F10438F7087BF286C089EA3C6866AD
F44B147B76D3F2968E9704C8AF9F8223DC14873AD224CE1F669D6DDFABD6A26B
DAE2B315DEA91E452DDAD3066F81EA46582C324C6513964A084802A25E211009
E84E722FFF61C769C50BD329B88A5B58FB2C3972A239A35712A06FF1A5F6C86B
E871E32383E6D196683F2CE295C80E3F95459833AA2D4CA6065C2B584B4CCE8F
DC43D607288635D51D2F3F4DDD3C0ED736EDB545E529CA119E937A4E4F77B509
388EA3FD9FA10797B5A2DDFB174B1E1FDD705AF02638B0318BEA32B0D416B27B
9504C889C1FC30A36AF2B2771B685B4D7EFD996442CF47558EF0E566DA0DEE12
7C9E98DCE9C83BE46CF6D4B1DAA2AEE52EEB4F07F80386C872B556B363517608
42271DC8BCC8A7AED0FFA3EC0839B104B3D3399D3C2172D3C2F4A2A6DD033D6A
0D6B362EF493A53C3C1B37349F51BB5EB83237C7A488381A17E3ADE2F3BBAE34
04AF40A5B687B14670190FBB954E10D29A3F0A68C1C2482A0BCDFFD9613AC0C4
6F3D057FB5F47E2DDDF9B56C3617FEA2E7FD05520E996C0B3F3FEEAE3DC36406
0DB581E752429B985F23EBA0C9875AD055D8B1F640D10DB8F40BBF062F476691
EDAA1D05C5591EEDC1B75251BFF8576F1C9CC5C0E521392A2F0D5F869F8AA462
B3883A673A976328E1F0DAA22B80CB7737DE2537E7B54F5E1643E30046E87CF3
8D9A45A973757BC16CC50504033125D2A68A1C97CA095C56B3D62783960780B3
1693596869FAF5692AA8FA6643FCD7F55E72948D2DC55AFC5016FB2C48AF9D85
192393C682B739EB43CAD8C3FD4053B2D53CF911352E2BA87A65F8949B0B7918
EA727DE4A08DE07B71365B8F31103159F65D30A7A318C1056BF638CD20BB56D8
6F22ED3EACC46F750F405FAF96268E80A409CD8AE0F36B68AA8C5FD2E0E871DB
D2628AEC086AAFC9F04CC93440E1A8B0ACC1DCADB778837360339A25C08E3B0C
E768240F0E8CE9FF939E4B1A6365664AAB69761B7A9C7B95BD29B09B930B0D82
F2C39F9BC0B94E56C48DCB22D8F0CA6C633BE68E5977EB3D88103E4230C6A08B
B4FB0CDEA7D44636102D47AB90B92FA42243943EB3E77E6CC38DEDBB2DB8BE77
78936B70FAE12EB1E2913B766CA2BAC3FA555CBADAF2CBF6B7A216FC93470554
2C841542BC1FDB26DBE389CED193E28A19CE9CBA64FCEB47C4D9C7891741E0A1
23FBBE971ED93F797C02EA830678317452481FB78DFEFDB25A3645AD3979D2F4
AA17C624CAB35B85963C6DED262AED5DE92278F31B2E573FD86696D98800443F
32CF695BC103A3ACA687FBB3F42AF9C89123C719005844588667C3DA28AFA523
BAEADF7BED1F3B5D595DF571540D0855FA377DFA6880F525878D6A3D1980C7D1
05554ACC5D07ACEA1E0D27664F6DFB6EFF878D0A68604565D0BF75FD8BE023FA
36D164B7BE25F9F811A466CE04C2CE5A774EE3288A245769B7ED30FCFA10230A
D6C9E809341BF5E55E58F3288F7298D62092922F07027352BC7C9612CFCB7018
B3394AF7EE7076395E67C3CF9B71BE069AE6C6C412F86A496E7C77173A0CDA0B
CC46683C239700CF259CF668B9F5C990DE3196B84BE792F51E17583FD4A83178
989638A37897AA769D74E0B3A299DD94B314F9BAFA7217AC70D8D9D02544A545
F6880EED34399A835514CCB97938F3E012AF4D68C140C6CE231015D93CEFC522
CF56EDA6F3147B3861904FBF8BEE6DB3D2E71479CD3A02BE03C555B0808D40B9
53D2EC56876076A116EE7E81836676237F88C519F8DBF39EC35FE41D78CF1665
E3FFD09C78FFF428AC27BCF0318D0849935822699E31F5115E7854A22F46951A
51F24526F7190B18B313DC58AA2EAF631A48ABE394668C6F1CE9AEADFB56116F
FB38C388F96143BA870537CC8B3E5F2DC39F9B930ECC63475BBB8C5F9A45218D
E05C4E6F250F6E544D6011F65EF4808D3D0158097CDB6E280AA402229A6B78E6
AC615258668BFD3469CD663592BF1214E5EF1C116C4DB47B805E2F60771168CF
79CF10DC2DA8F2BE94869AA570DF2AA5852113C51CFC85C1E41516CE412CB410
BD026231E22A9CD0F664D76D385CC1170476B17BCDA45C640C583F16DA207028
0C58570A966383AA9F7CE59375525369CA6A559BEF0E05F11CA9C72A278C045B
1D2572EC08DE1424D2420D550177794FB3DEBEBE9E4105AAD34FF119AB2483CC
A034A95AF0B24B801710B398D9E9A95138859A819011423AB5921DE8EAC56ADB
58FB18C27A41CE503CAF2E7EA6F673ED5F34F1C1D20B609A152EDECFA26872BC
3C8C802A1517D9C6FDA3474591F19D573EB051F551990D0331B2DEBFA31B5010
3F6332290E522C15C69352124E1051A715399BBD1A6D3704BCBBE1FFF89E56CF
9C3EF605898309C7C3D20DFBFD10DF5FA30F409A76AE8021045DC09C95C9AE4B
4EF735A5414D985F6F79100E7045B930267F0EEA9BE820E13291132AE91118E4
7B8432BD1AD7A9CD912F2BFF83A2C4705A26FCBB7F8E45CB2FD9AA2EA98E381A
01BA4C4E31747123F20A0A721766F9D9A6769FF80B400B1EDBFCAC63CE15283E
72EC447BADD5BD58B053A11BD770399E31FB3B3D856FBCF6235BAD1F0D38E26C
3518FE6411F2A5FD4809C085AC2D60FA311DC99B9100C1A59CEF4C877053161B
59682BF5F2D85F2DA7EA0FE603D477F6E80DEAE0F250811BCC646D8CE2956C78
B897A5000D73AD32BD99B92E6E63BF8D79777859EC0F7FAE47F5A0CA878106F5
5462D3027DEA15E36AACC0E7349C8E60D6F2439E2D50DCB9D96C6C20D11266F7
913970C783EF6D587F638339D1E89A4878ED27E515FED0D26FEEE69602B2BD58
D146C077FAC71FD55A5490C89142F2844CB7E6352B01A448D4BD7A06D8EC0F00
E69984EC55E0B487FDEBB3F7FC3F4093CC6E13B87084E461E23A4D6862F0EEA2
84DAEA8343FE913EA90B9ADC7D025C2B8EA3689D75AA38B5222166C447B82E75
52DE05711B3883394BA9D683C161A48059A0463B17F3DFE8A73B46E913B99D2A
38E7FCC667A5B810B665519E7E1450E00BB9D0279537763ACA5F131550E83404
04E208B9C0B0A118F40332BDBB431AA70981E77AA5E5E76F43E730D9D3D047D0
B3EC66EF1D37916398FB8CE955E12D8A89ADEB1AE1EDCF91BD788D8F261962B4
3870D5928D160218A297BBD3BEA22E12E9C4197D0F3835C0942AD6487F5C9B20
C9A597910685A9BEE4CBA868D352ADC10A564782DF3BD57758FD145E769D4E88
BF43D19050DA58FFD64EB7B1D37BA13752B6C966C7A1397D80160687245269D0
F27E87B2186D931D624120B81967E58ABF5DD66AE39640224A518BF378B5CD26
761D1ECD916FC625A90EE8A7E00080300F0A05D265549982D56614814E10FB25
DA53070C2BBB4411D9608F4FF0B2E171820C734BD20399504F034BFE4C20E7A3
1326783358CF8D4FA48C1AB81741FA70BC0E0A4BBD104C7E5AC05CE49C6375E8
9F0EAB2B56BBB89144CE810C78D8CA02BD7CE2AEF79E27A7CC1D6B68A5B9F504
BED3487D1424CA82B8CC60A0156706987C7D0DB913F1BBF8A7B9A275E3345BBA
213B3DF67C4111E9564B59B724BD65916BFEEFE9BF03AF9D84DD2AB94847F33A
3AB3757D2C8CB688D50EEA68DEAD0613A62C3000C037092ED0A93F8486FDD7C1
CE928A3B7A62E15FF0E53E8441C88EA7EDDB16ACDD26093F27AD276C7EBE9E54
1686DA5E26A4CAEAC39715DEC0AC3226F89606D8EF5ACD55D67B059BF6E8F30E
E359EA6416D91CE21ED908D6F8E0DF883970D349DA85F749026AB7D8CBC93B9C
B12EFD2936C1B63ED2B929C033A7F9759BF94C668AD787FF73B1BC042E3BA32D
6008B89E8E030D46B0E9F0247510E37735D1055E32143E97A11060CF072D7955
9B316AD1B56F342BD5347564C463171E3B2271E4F2B25C44E345854FB204CF96
E9441266931727DBFC72CD872C534A411593D10A734F54D32BC5663D02A3008D
95BE5EC1AE472B75ABCE6A6BB030727318366835FCC219DFFAD9A7F7D2850C50
C01F95F2BC7443FFD645E8EB8863132403F6552F82A6C3CF2AE112F8EE4E7A06
63367535A261D18BB1A26E4C2157472E938C018477D107652BD59E002C56B3DD
423BE925DD0B46BB86D33CD66D069CB847A315262F8F4F114D713DDE8D3C9B37
40FE2E9D8D012D2D358ED89B9258E54CADBBB3CC59D3FBE6A84F1F9521B6E05D
0A0B2E0FCA57280FBA427EBCC9F86882CD96EEB8F3DDC554ECFEC9AAC229C31F
9E8C66735C59EA38E3BCACCC6F85A6E4576CE0D0B850C5F5505B61D785C6568F
D459FA6AB02F16E58ECE66C909B7040538B5E7DE80B6DE055DC28C1B3CD4A50D
077FE7AE2463F40DA89824D1C5D17DC70E135F666D6CBDEF35A8DF7CB22CD7D3
71D2156E4C040D7FFF62F56653DD40C4DF8D976A9561F7A2A4AAA27D75E805BB
F6F2438217BA5121CC668458620DB3D381D5677019CAB09FD5A5ED804CF9A763
367BEC85D9D26CDF0AEAD7D8C7AD70B7102FEF09C25D849D09E261A80C7C0A81
E6A62C2934321262406E81E6D5284196D0A5173202970C50B6914B1A9FA36793
CDAF2C6B0B5B2BCDC3A9A24F32657FB3C5AB5CA53FF04D309BD67200DFF251DB
7C1E872D27108DA3720BA9E0423567DE1FB1A1C7C39A7E38131BBC8107ED4187
C7F90629FE6A0C3A2E91BC1D8766A4FEFD11C3D600607848EA4C75D479FB097A
B43804324D050BF5D846C198468D3B99CF91A25FF02E328B4505CE523493D18F
3F02B9016E3D49C2D5D9A5CEAA57219F11185AE73046838300FF9A722327A7A7
0829405B8057567BF58497ECE9A3914678EE3A7C7BE83587861938BE31028361
9DCD7B2DFDC9DCC814084EDBCA084A7F5BC024835129BC973464E42088642FAC
FD91D0DC3D0BDE2E6DD79A6CBE75AC692FA0725A24BCA26C14569B48443FEDE9
66E1CD647E1807EFDBFA1B2EADB5EC0435EEDAD922BEAE31D1239719766CD650
AF2D9B1753B7F087F228DDAA17B41F60997B611C4676FE94913335C35BA539F1
DFE9775FBAA1495A572719400771332BF013ECA0872AF2B85E7C1C3E750A52C0
70289822BB030286ECF062921A8D17FA331966743BB807BC62ECCE310D8E8082
9BB14C7D4FD2C4E6057BE5F5C51A242002726254FAC61AC139CA000B293D12E5
797D09B504F072B85E8E4F20FBE600F1D9DD0E0ACD84D43E356F2F4279001DF1
05945CE0ED14AFAE4C5E3ECD955E06BB19AB872D8EBACFD538640C60E8146EB4
0F9A01EBFED0DD4DCF5CEA0E750A2A8A15EC363DAEC92DC7E8BCFC67C2C33B0C
612EF2220F55F8342930A75193E883C04AC3D262EFF196C1056F26BDBA4BF29F
957B8682D21CF1CCFCBAC8BEA132D42722ECAEBA773E594003499F0F90FD53C3
0FDFAE6A7ECEE0AAB8449EFD258C8DAA3A6A5732A7CB0A03B0B3B96EF464630E
2E55C20F500DCDE8D0D4050278151B43557DB81EC1A200EC7DE4135733C7EBA8
36A58B084F2D12E5ACBA4C014A2D47DAF56605F718B787A38CD24923F8309743
01B03EADCF209219746A94A779EE401A821E659E84979B100B84152CF6E0E17E
BA2352DE294B834558F1A9B88ED06339E508D2D101C6865EC1B7DEF88C2D8795
F4FB986CFBBDFDDF58734B9E8FA16F33A2455597B54F64CA976AC858EA44141E
00FD01A504D905D1F89C5B497B4533121AC08963B5FA2A312CB07CE13E38C054
00B8F085FC7A58576F23CD19CEF83ED66EABA8CF152F0CD5EDBBA164DC9E9B34
14D00E9F5B712394804BD3881228AEAA7F8175295BE364F4FF90ADDC9DB515FB
D7721D83A1A4DEE85A5AD027261EAF5273A61604934BB5E8037C572BA8BE7D61
36C56B289D8E66A4AD0D7458B8430994CE4CD9AD3349225E6B8E37C4EDAB684F
1C65D2FD7B850EDDD9A2F0E12A7B679CB444F95AEEEE4199F65D8CEBFBC0C2EE
D9573ECCCBB08273A876F7081AF9F3507EB647E3C639BE99D148640D9C316D13
A7204062E3B392D2CD3151B4FDB8C260D0E3D67FBFF208B4187A30472FDA891A
C27B2BC08FBC05291063120165B4379B1A4DC9D967DBF436F7C6B2F1CDBAC5CB
B4AF4E5AB320A83EF5F8EA5481D00AC8DD404ECE7B7EBABB8F8300601476CD50
E2FF84D9B8BEE40DA110ADA3FF7F79157204E37A4CBBCB1EC27C3C1DC46D7041
C10BB06215A25BD1913C7954B5C609CA9D3854C9EA86DA22AB40A3B3886A6C05
42C01CAC627631109089E1016DF8FA12A8A16143D6FA33885C9B9FA07B565BA5
117DB4AAF5E956EC5D20F1C64FE1D7838ED6928D8A747395BE885E484B64A8BB
08918B940AAA49CEE6AA0893F99D4B3778E5027476035F832800BA44DD093338
38E535115F2C43537EDC6CF4402ED75EF443553BAECD57F4EBDA269B81574BEB
564CBE4600F992B6F7CF40123662D2F640D9972A9C5EB504763811FE1F00D622
1AC3D66159F256DF9FA97A20E05E027F321D21B96CB5E1B2410664A97DA38659
40CA0CBA130922CD40F23D12147C0AA2495B30F58881001BCAACD3ECDCF48922
7A85D6480DA41A9D0603EB0FEB09921F1BB83FCD280F51BC2300C56A6A6FA770
0D6F6C131841B0AF2B8AD1960A12E9EC3C63D5CFFD2BC79127EB92A645A8B338
AC05B84458A1D041678A1BC1282DC784E4B5441570FC085F54CD9DD02FBBCB47
FE1A015EFC812D65DFB3B335EFA7F4B85C04D8BBB173F3A1285DEE9D690E225F
7BC25B4B830993FB73790CF101C3BB9BFDF16CE4981DBC209CF5B2584CCCF341
8C6E9D8A2D1481910C957105287BF6333A5C0F5514AEA4CC65C257EC4A6C0F34
41C94A4F5914BD17456E8AEED7CF4C31FDA73EF6DC3734B626ACFAE9FD184FDA
EE2BB532708738312865C1F737A2BB00C4E5E9DC24349F29614784C3339DBF4C
4D4D95274BCFE03B1AAC8C7642DA07EF2F28988112405F80F2BBD632CA84397F
0CABC125351097FD8497D3BB8E9F0454F02BBF294FE3CE1EF37AA659B04631F2
482F244C74A692B4DA4C5DDC0D361A5F467481B87ED7CAB30EC2B8DF68AB4D67
659C31F4F6F7DECB5E57E0C7B6EB1C817BBC4034D54FA6EE1941A393CA17E459
E336B3BB30E515CA2D20AB8ACC2E93B1551E750DB24390D7F0804F28A5DD4DEA
1C4D4A1F2D1CB9276400AFF35CE170D31F2B166B4C527C15455276ED0FCD4F40
7B558A3481CF70EB9B481358180E21C8C2269AAA8389158A7675E0459FCAFC4B
99B7F0B15679BFA992CA2D8945B38A4BF8B7E599354C63813824795F928AF04C
833497F7C4B1B692D0495AB07AD8410396D179DA4C1E7F5C7BE4EFF59D55B381
ED8044E622D09785408DF04F04C9218D31ED24A5AF0600034B63C96B6B8CB995
B03EE89D82E8827E0BF53D4221CD9521C8843743A3DC5962563551E7EEA199D3
9C2CDB47047AEF41364CF8BC46839A433F25A80BF8A5BFDB70F041005A314344
E385D993F4834D1BBB4D7213FED3D871DA6939897330245583FF89394E4B3588
4FF9A965BCFD48D454188A8725EAB31FAE4CBDF387FB03FAA5AD122CB4A90F47
9AEB32B0CB5FD4048C6E2D1B0AC6224CFC85FA9DC019E9DD68465CC87E00F952
DBBB63C0DA21C717E348E0BE63120324C8FC4A1263F02140AEA93FCF1A94F1D9
A4D1598596C6DC9E16E93350914839FE96DE745DFA79F106BB7E6030394F2642
313A0F3177B83C5CC1D9C87E1F988701ADD7ABED9E697E93BC968A3F78C8604F
B03A0AF394E19A0E56F4E6C13999210CD4D7694F73F26D672A7BE20500304E69
9087189DB76123040AAC7E20D1151E8693DA446E9BF045BBB54DC81750CACB6E
1B551D61357F8DDAFA288C26D2E81986BAF8AFAA241DBD42E7FC2458BE65CA61
02F5F59F7E0D39884C8625CB19AC00356E030FFD1FEABAB9B66A86E0A700BDE9
F57448C205D6CB67FC2F45D360475ABB400940D12507B823BA98875C002332D5
924297233DCCA367659FD7F848C2A7E02F779C9DB6F0134337330DE3CC9E7ADB
6A6C58B008B0C8A6C144DBAC1FC39DB9BAE78383486A34CEE51F103B18182CA8
76162E87AE32D5F435F3FF0B01F65FA7AD1F6C849635FF109BB34E10042752C0
B839FF9E5DE532DE3E0CC49BE3BA370215A15953B841058296B4C6A757BD6E6C
845E2379D4B42D8D19FA6D540368BA9F7A8DA65F4DA7743A09AFECA6DC807448
B48C85E46121054E68AA2577DBBD57648E398F5A052751A5B22688404A561A26
512BA8E943EFC02ED8BD1AF09AC4E8A0BD65C5D552CEE894D80941B53079AFE3
CFDEADCA35197032D53166FC93BBB1BB4A3200B92F0FFEF45ECE0C0BDF313668
A14A66E5F8C165CD0D254DFB8F56C192F0F96AB7919D91251302BCDA11FC4491
EA792C554CDB77B0F15E96C8C057F1122024F2008D619DB72FFDE8104349C2D9
C4447CC9E8769208566E81A614B95868CFECB4F7007FA4217D853967AF5E3659
D9628533AE56E6573C08AE2EA28F6657C76F77B64D605695615950B45A6156FC
62C25CC8EB574B11C5F168849F68876CE406261DB7414D0A2A7969C4C1E24E27
2A91C5C70D329E38BB40C114683876EE0F8E07FB898E46B33A5B0338A896F9B5
A6ADE308B66E6CAD41B62A0229227ACF03E9891D2F507BE16622B238525FEF89
E5722C9A99BC88EC903E355F8C0AD0F5ED99788FBCF32D200E0FAF7E28B98102
177208E3B37B9CE3F1A4893130EC199D2720CD9BBBE8610DB32C86FF6F9DBA1B
8B8EA6BE780723DCB5F2547C3A7B9402BC07CB5E502F0A7CF4CDB1811C0C2154
306220A1212B1FF522DA543436ECC699EB8815ABFD76B252DA958829F3C7D61F
368FA53833A612643316CB420AF3DB29F008BA36A2EF01853880A6619960C0A6
19B8A60AEE8382D921A46D8187AA3C99463EC5DA4EABBFEBE23FAAC12BA68C26
22BA31B9CFE80D5FF538EB10A6199B33F3C1173535E17C888449EEE141307E76
C13ED37655816E5DA7AFF8145444A7DB296F3ED3A26B7E8BAA8EDB383DDC0BC6
740305C40B00AE70CABD8E491D8F710C5F31260C5AD761E6DF3CFCFD20F9AF8B
DE1A4B71AE3761D67B064583FC15D8903FFEE2F8F0327884D3C7467A1598A876
ED18B65ED8CF20632E08B6D4D644BF03C6D46D5553A1BD1AFD2474342E906818
D058D7B7A624A24E9ADD421346F6422F76D7CED5CD242A65EC78BC20D377D68B
ED977CDF4E50C834637F77ACD9152362D162698BC6F7535E14CF202C75FD9F84
9B0FF3AE191ADFF9F5DB0FF74793F3C5263756C50DD80A5952ABD5D2C8BA51EC
4C21A55CCB922488522C9B63CF0033144207DC526F24B186BF758FFAA8B678DF
1769AFEE6D7A1161558E0103D69F95627A6E456099191DA59C8C31131184682A
1D548076F2FBD627B6907A18FBD52F0D6EEEB97C9509C9294C6FDD6D4FDB75FB
0AE3EA1627050258CB8B3F35F8ECC07BBB7E68F4BCB0B429D73C0286A751E25B
22ED67B8950124818EB258558D55DF668CC0DFC9D932F270788C2E659E837AF9
2F4E8524E3494D844D1A9F70EE29B069A97BDE7AF2209A9F760CD496A764298E
5767D6881C64BE717E10AA577ED3D559010D071E2BA4404CBAFAF99040CF04CE
4DB5A8C71723B2E423F4F33AF3E02DFAAFF16DBFCC1F93AFBEA0E6F251CB77D3
9ABBC2B58D97BFFDD887380109216561C53A75A752B42918493BCFAD6209703B
8856CFDF826C8E2875EF62AB27098253481667735D8E666815E1BBBF530B3679
33FDFB4E9E1B6D1C3DD6CA4651B839EAACF61A48ED07D54A9C208D9FDCCB4395
5AD0B93F9203C8DD69B878FE83C75246F58A9FF85F3ABBCA8FA9001B58C174C6
FCB236E69C3851B68CC160A319BF4831B93A677A0ADE9BF8F8AC548AFDFF1297
1C763213CD7819E3B1CE70F9F9E81159520DC45679D35E06C8A1C712F1825916
8311A786495AAAC92B40E6D67A3B2B8707B2C3CE27B18100BEE64228990E597E
21FC63BBE8685F31194AB4D2C887A3C469F9DC2A96B15D33FE7C565961C2A6C2
438038EBD09ABCAE0CEDC2F11536B2C6F39B0DA7E4CB5B8EFE43E5DC858AAB70
CC2F2DB52466AF31CDD0B4B8B77126BC9E7E152BDA1C4DF31F6BD83A33C27165
35BB7084825C7F2C49C6B55ECDFCAB2B87D00D84B6D0D4DC297284C99F5B28FF
8772D7252FAFA673968722570592FA551AC4820762C25577BE27D8FDBE6424EE
94CA99A79794FCFACFE9D03B9851FC8FEEBF287171660B9692C79CDC2480BC82
23B359DA5AD05039EDC7280BD9F1660877BCE8CEEAFB3D82AA6E3702FC7D5A8B
CDA1771DC22F909A8E0E80F2197A5002738F1989071790BDEE7297B5020D6471
E5408C44554E71A057E70867A9C17AB3E3DCACFF68183009E938354A0FFE5678
8245B1B6AFD86D04C4F84FB9CB9BAF821700E779C0B47A34669D01AB55C1F205
BF58BB378428AF52D0745C2912285816C4E27B8AC0688AEA75B9D44A6FB075DB
34208142C0B9108FB8E9B7A6268AC96F7091245F034BD65542DF47BC7BBAD5B1
760F67F783F02E71203124A14BFC52E9210C8A69273A9FDAEDB801F01459540E
1BBAE5011591875477759756E88C20F3F505874C644677E0BA0A6A4B288F4E35
7066A453D014F5F5EB1E3CBCAD06E8CB0A595875789BC830CBCD960C9757BA85
2F889293D91A1CAD3A4AE79D3244DC36AF482F2E48AA56435A4BFC57904CDBA6
BB2FB53645129D2B44DD121BBDDC1877EEE37B5263811E5D0362F86EBCBA9042
FA4AD9530EE7A9A7E11D9BD9AE3FB21633DAAB8957305817109C44A9F79C2751
E13EF7681C10C5BCF7322BAE688DFD73F7115169B32AB8B6C05B25550315BDE6
D5431809F175C7567728FBC797A6FE0A062552BCA07575CE998B37E6594CC0A4
06B20C54AE6DF9AFE38C52BB7B201D053025A68118D8FAC8B22B497F5083F0E5
1D8D14CFF9D60B39A6E2E1AC5F4EEEF91E7F41368120CD1D15987A7716BBFC20
EB3DB805CAC99BDB82B800344E9B963D846A3BEB6C1CBA7BBAD21342AAC9D0F6
4ED103175D288DA1003B76C9A185EE6A8152A3119D192BC08E3B0CE768240F0E
8CE9FF939E4B1A63656648C40A646F79745A41552F95F74536C803FD0E67B1A0
02FE846AF4B3203DFD65D580C860D5E426D107C511E4D8E93B2A5B2537EB96BE
26E0342E4165D30208448C93164B21303EA66FAC82D253D82593E361BD7765AF
40D48DE85FFF7AFE7DC3807891D039AECEAC3F500A09579E610775B782F24BF7
ED544AE148467180DC2293FA812D8712436FB4024114DBC1D9BFAD07695C8F35
E5896047EFB771AA83D699485A7E03E71DA50FB2096EE5DAC923CA2F3294D838
9C25CAC32F16DD308D6D5AD32E6D8DE72E1A81A569A8DB4D0F274488C1CEE80D
E89093792E9218B2B36B2BC184BAD23950B28C80497E259F4634C7DF6E6726A5
18272C9F9FB2DF0780C957CF1B9734E9F49C0C8FCC3C023951C59F3E09157F87
CA9762F00A7EE360511C17792333087E98A8C64083C6E51F0E0BF508297838F9
02A33474DEAC4ADB7FF6B751D3816531ECDD6CF5BFF25018B92C2A5B63978E50
C74C43E30C3627ABE7BBB46681E9BCE3612AC5B63E40D01916ACDA40E27990D9
B37192BFAA2284F02BD11FDE0E5BA107C68B49F80BC01E3705E4EF2FB3398468
408AE8A9D786D4459F1AFCF2841F14008C71804A8D2F25B580BFAB9F2D969CEC
E3555800F5862DF5DD9E900D3D5BDE642412D953F70268296E31E81A7741ABCB
2AE2039CE16E1FE730C26702E68F79037A4ECFAE0BC6723E560B0FDAFB34E8AD
48A2E4BA5E63EA1ADA05D335E2D21DDD09E0454A11CDF50722BE8D222641ADDB
B9DDEFD18F912AD1238B5353DBAAFC709043EF0DAB99A669F70EBC4901DF9C54
69C868EFD49274C54810280177392F60E826BC6C58F3065D9E77A3EBF02EC190
E226CCB41B71BF28FE6AA68AEFC449D6F2C581CA109B35B4AEB6B72F30468065
D1A2ABF1AD34324CF7A8A0827C831C4D5256069855635B43A7FCBFCD73E96221
1985FE9635A0F5DC4890183DD07B316260DAE1B6879252F32B95405D856397C8
43B2B7FA307EB591FC6D3141F0E0CA3B9A1D56DABD05371F9479BFA4CAEC5CBA
AE919A96CA4FABA813FDA935FA86C092E2DF9B35F469AA173A877B819434E200
FFF0DD0E0604021508FD5108026F32992316A2DEC84AAFBD92F033B33EF2BB8A
4796B06628CE4104BCD93691942E935C838E2CD3A397BE2BFB00FA1300BEEB57
CFF22C7CBA28D69C7E54DAB585AC15A6226F39A572823382D6DBF390F03121A9
32BFA4FA7A27594243F63B1C1767A866F1F9B4B27B64CB3D441086661C6910F3
50B8EF85203E4DAB28B15D18FE1EA4974E0456421C2B6EE7B37D178BD49174E5
E639B50D8F4EEE871F76F19BC2ECC2D462741B0BA00C6561DF4B4C68577BD9B3
E3EF62F7F7E3780CF0258A92F433D8A3E7CDB2231B52C9221A8534A1618604CD
2A317F0B1BB0722BB927BC8D50429B985F23EBA0C907B6CCB4A57AC0CEA9F5A8
4F8A5E38A4D87BD8AEE6DF7CBE80059C2A83B08C6965A839169101F88B511FF8
38CAD0FD11B8AF2A2A4F5EC3278AA98A3DF4D154176673A003851DE425A8AF6B
A29E7F2AE36932B1C53EA335483605847F13D5093441987F3E7CCADBEE9CAC7E
77D79BA760EF4C53A3C983853DE670289510D008B8DF64C3DA9E1191B06F159B
BBE9A134C4E997DA7C363799EB647602502B8190281BA5F0A910B24E8199ACE6
9C5425B0C3490B489EAE7998EAB74FCB7A42F775680FF6AA0A18E74DC148E581
16C90C7B21C4B7BC7CD495156D56EC5DA36213685C51D23EE8A56B93EE9F94B5
A63D96B1F47E96AE5F10E07D9A75E9F4AB10B7E46728AD90E833F397246EA4C4
4A12EF33A54D213792EE370423883BA857C54F7B3EBC20098C6212DFAA3FC588
543E6F5CCBC5780936829A15DE3B4654B265AA138ECB8438407EBEA5A06488A7
CB7074776AC36B43FF510D096D3B6F5E02523C7F049D006AE59A0E81FF681A51
9EBAF2FABE7C94EDB0AA8E432CC2BDE47A570DB69A34C2BF825F9C769CD611F3
43C793DEDEFB0A2B19553ABC505DB05D6BC44417E8CB8E2472EF2624C23DF65B
80C37859F507F74E231EFCBDD4AFB595E8C3F0E8CAE46CDB1370E08C365BCAA5
89B9FB46E97AB020DD38D71B7B8E5D2DD56FAD7828E5E203F328AD955AB43398
7B229799A32B89E3A4939C152ACE83E912CB7AD280F09997BB393D7C8537A5FC
D09950C59D0B79467CED736D9EE1FC6C3E293409C469920A5E60BE73C3661170
5DF0DE7678022AA09EF714E4BFE0D7A1352D7D4274677B103477A4358A1E737A
BB84A750A16A4999D5A59AEB5FAE6FA51EA84B59E4E75BA397998E519B70C367
0D8B0B89C65A9A6D43D8D3E30A63243E9F7DBE231C3DE32B82A38A9BADE0C537
6A9F2841845CB62FDF58F84CEF83450F3CF96A0D4DF87B91E7273975069C9071
99D36165A282C7C6E855002F63492E44D2391EBD6625AEEDB22442CCEB84038E
9AFF58CA2C6701C4D3E39979022FEFF095DA482A4F411FA0372E799AF99DEB62
F1FB386855F555961A4762CA20F5E88C40FD32DCD9EEEE0F6BD53770FBEAED00
D16CC461AE68D568CDA22B8B3BD3FFD900F59825D71AECD7C1A376D9BD123420
5A958E9E890BAE1B6B240F0D1924A965039011AD4C5F22986EA0FC188FA30CB0
8809DD2962E4BA66F7844A77BAEC87EF5053D888D6C101B6CA5C72A2775BC54B
78E23B62E3A2AE32BC724EC6D503D71AD216D45E95601049B03FFAD238726AEA
FA203ACF95F2332E12BBEEF13F0EA2444B154323E8F7B43A98AE3455D635B444
547DF7D9B7F9EA1DD690571689F7233406B83B0EFEAA6C8CE3B066A7C6A26266
35CD202D4990759495D7EEBD7A02113AC7415799BB341C0177F10D97338072AA
5346D7DD91901DB0114BC982205B9F1A4F8D649C4C11BCB49DE285E7CCA8EA2B
BD321844409FC95378BCE06C3130FC48E2B2AE43AA5CD63FAF844F5300D7F8C2
B18978C77A5680FD5D8DE8B605ED3013A69E65112D9622D15D0FFA4E22B5A0CB
4FC82C4BB848D07EDE0C17E872BCEA52B0C480AA4A7B456EED703C27AECEDCFF
88EE5634B80411532BF22520355476023178043584B70A2E09AB101F8D4793C4
204D7D421367224D757CECF551A4B4AB740391B20163EEB3225514A76AC74C34
163D2ACEF07D9A4A08F4BA36665A80C7DA15AA557C55E72734A14DD9CAFA0CAE
AF0A927D5C7DDCE03DCCB229C446797A10740BA3FFE21D9099979EBD752E36A8
EA33F54122C0CCB305D9C4587AC495570DF9C4F05525921AFF53DD00ACCAA577
FDD4A0C3CB556245C965074A8DD4E351567A7F3CCFE73E0B0F42BEB8396D03C6
ABD18F70784AFB3DFE4D510A8181C171816540E61E5A2E2947957AA9A455CB56
3256509346128EBAAF7D11ABA3DC2932E9D0E618DC6AE09073B38E8EC302C923
C417F577823C0210444A3BF399C2264540350C9C4105F867E2AA3F10C3D701CE
ACAF315B8E1DEF18FEA368F63489F8963D45A7BAED4705357152E49CFEA53498
B4A8F79C7AA87B0624F57F342FDBF35F8E1228EC06BE52C6F7398CB420DEC645
0507C708FB774FBD896843C02A163DEAC4B6BA52A7CDDAF33464AE6602C376F6
D2C9A086DBADB887242739F5D9AFAC745E74FB9CA02ADED464E0654164876E63
E8E3BB26C15E177259F34C2EADE01F1DC12B1E324F1710B201EF41370FED9E0F
297D698CCA8215BA271A098F840FEB47AB01C8274C24B6B3A684DDB55A94C6BE
29E490A13030BB1629720E21956A2E0336865660580AD6FAA5A61B3F913009C2
A49FCA5BB62E5E51E56CA70B16425B3026D0124EC73730744A2343B9BEB38B8A
2106AA74CAC58AF617D2BCF947E22EA79D2C8F57868E2AAB61A3C1D0EF8A29D1
201C63D91450E7B5F44AEF32087A030D933A92BCF3A0D6EE20AEBA224E4A6BA0
FE95811EF858DC7CB8C5D6B8CA4A70F9961A02B350A76F697E285BFA29449741
6BB6C02A43B80A127E623F3ECC64BCBB149C68A54B6478F80B793FA88EE3DB77
88FBB28D6A6235824DDCA7B64001AF33637D19547C8D92E24C1190A50E8DCED4
C0D5D628B75223D15695B6ED06E7FB334F4F2A5BEB4C0C0ACBFD7888703C8C50
3CAC8E41F41ECEAC32BD3F62499AEC10A41FFF797EE8CB26F5F87D22BC1766A6
4775822EA092DCF193A0DC0E0A7B0B3A647E93E5B3AFBDD4A92580D70DB13A90
B8B3A886423D10A76D674334C47FB98B2E35B9789FA83E1FDAFA7FF188F74F08
626093D94BFE63C234573DAA11A489B87A3C6A208E9CB0B30F7AC129D6B56890
F59FF4143ED2E3259641AF153D7D485F93428B420854DE15AF291ED675A634C1
51193D29AA6E0146CF1E546E58DACBBBB7F2564453044BC2FE71B260410D8C87
B237C1C5D37A94279D5EA776EE24A4CBB9A0A5E02FA37261E130910A5DE1AF58
CAC3F06DD1F83FA50A267B16645FFDB0B1EEC921620E668D20A9C04B43955D38
35B3BE1A74230C180CC48C0F9D6BE0607254667BC73D825FE456A79A38623745
FC7BC778B3765D421C91580B0E13869795A7234CF01F9C6D90FAE6D5EFF289A9
B7D3C911273AEB78CCE20956F1F48D71825B795DCE254E2426E99ED07FD2550C
E2A96156EB5EE9F9A9A9955142873CB00E5697688998D4B8689B5638004350A9
746BCCB13A6836EE7A131C5F333881C1279247352449FF43736CA88FCD560B3D
F5EE5FFD826E4297FB433EF36C4D4ED56676ECAABAF1A0950A2B0B48CB4A468D
6933DDEDA10237EA2D1B94DAEE18FD20F24BBFB3A2C968EF269DA1EF5B4DD654
4595D1EA952901FDD537C1B1EF54E133B0243FA763B492483C51D41076C0FE99
D988D612DEBF78DAD539BF6423C688F32BFA5256F93585A43DFF3C144D3E8EEC
BC54F126834654AD20853F11A6AB840852C69E9E628CBB9FDE2DD6A4C64592B7
9F511EC5A8780B2773D08FB7B54F4D085798E459B5F96B09DA6000AEA0E6DA6C
F14A515995310546AFED54748BAF73E59E91D2B4E32C7A4648B35B9C84FBE4B9
4E616C0BDDB44A1151E2CE00F03D75047ECE96EB36F6CADE7470118E6D7588C7
57E97326F94B7F4A00706240637B9CC0720467E68E2CC215D87FD88107643EC1
A422244B1F2D267E4CB947879BA7C1233055BAEFD7983E8B82C7DA405015C1A4
4F3B015B1F6479DB81F669BC2ABB4462835ACEE028F14B6850CD4763C89CE51D
484F7E49765600A125D6DD423540BA1EE7744CD16AA40D8CA0ABAAF045B88358
2FD986BC20124BFC383174207C66D0B692FE7C1C1EC4C7A8668E23CD337DE6AD
F81F769DF62590AF3A1AA573E5CB767F9BB9CF747F3988AE7FBDF5697AF1EDF6
CEB2BE0CB2BA49A05F45C25CB8FCE9C071FB01A5DDE0A95D6AA897649246424E
36759903C06E9E7D2F1D0CF2B4417F2DA21E2FF7F2C5EEC115E10B2D0BA299C6
923B0B3196C7197449A4D926A485C18F00D1DAAE4DFBE7BF96297E16C928F031
CC48E51D0F93C0B24D5799CD916A72EE694AAD512EA9A8C5CDD2E2B624C8D313
270378D817BFAEA47E8C76E014026A46682D801A2EA63B18863B2014E8DAC6E5
7E77450C4ACDD3BFE69A198D5862D23EEE4316F3403A059EC2CCC149C0FB55BA
B6425B961E0A09F2623266EC9E7B712173D5B4B7006546E3939DACC1C61B4C0B
D901BEDB404B9EAD17A12173C873DD314F8661C200D18F52D152FDFB28BC2990
68862893C604276B088EEAE379426DFC2E404758184D4FF4F44DF2DED3709E9F
0A3391BD41F25139E7129373ABA9969DEA451A70A0443CCEFDF45BFF2B6BF271
B4E438DCF50AC3D54EFFD66AF55A1D22B92395E80A77ED627203FBE844434C08
05E17E05FB37A305392E8CC8BFBC95F6BC6B39384010851E1E85D865E69D0D7F
EEFA7B898D06D15B849D55EDA4DF41B352DE584B1A95CBE83B31EBBCB0599EDF
88710DEBAF94AC283B9FA8F853A3083E6C3E34F927AD0BE2C3406FA3D0A22BF6
F24FCA747E156A36554EF3CEF1FD541D5CAAD692288CE843F68B8E761ABBB18D
9F48F6AC1D13586E774E5A52DCE25C90B7784B64C524C2A313DC45225FA67F21
11F4B06818ABDFA358A0E3A081E19D26E3B95C7F6B6C063DC2624759BEF464CC
E8B1B45B6E66B1438B82AACD872A7C363A92B7AC5D96374814457102C6C49878
BB66DA3E65A49D7ED50702447FD8BFFAB9FFA17D13C3DDFF2C04B4668F918E38
8266DE0B6C57DAA8A33761C8DE86B317C84E3908A7C765C890B67B5E39B7400C
4A1B2A5467F5B09F6FE3D052A339228D5D33F46F1FA2CB6674C215EBF1ACEDE6
97F96C55F736DB5F92AEAD8FEE0CBA9B3A1540F7913BAA24DE7583D769F85CBD
87F4C7F3D7E4BD97877E983E0DD05E92CDE29F43AB9DC6481B3096ABE283A4F4
079F49371320DFE3BBCBD1DDBBF412C9F5F3A94DBDF64D756C7E52287B5FC15D
C8D588E5BEE78F252C74D628AFC99FC335CE4A82A9A2F7FE048EBCF2F3E80D35
51071977365DEEA201D45EA24F70EF6017AA9430B4BA5296DCB613175436A28D
37309EFA191FD3C1F604F158E23208BCC016D807AD6AA4173664E48B8CA1F9A3
A176AD518CDE53ED5F67AB8911B4CF40847953614354E1D423DA2171A8B32139
10003F7FDF6FA87C28FF9C136C2864AC49D7492FD0256B9491DB389FFA1A7471
951311F400DA2F207BCD4C9F556F166036B9E2668657BC9A5E1EB5545CBB9053
B0809A537CF99EC7F1A0E901EAA37983DD4D2BE3E1D0695DD97FBBEA0D07D6E7
7B12ECBAD149527F2D5F0B3ACE13BD58CB0201B4E456C986914BC897DF43997B
350947D1288E36765D958080457D93D71863ED16E25924D9C965B5EDE7B9FD6A
AD2E17ED328C2497D927FC9E3C6CE6752B50C4B9E6859069DD41EF64112401A7
F5D4BF3DDC47954F4201108BEE238A38C73BD6689A0657DE72A45A7435A10F4D
CAC96C9561A92FC09DBD65783665A1C1D072E20D0E000DBE4A0656BE7F021DB8
63F63DE076757163A723A9E71F504DA5D447AFE8CFDBD88089FFBBDB7BBF0B89
FA1344A2C5487F804F2400B37ABBFE5584D81FC908853D0FB3530BAFF6E60372
4055D8C1D3782EF5F889FFD1A44E9EF7C5E89D03613EA19F406CA3A530736B91
CB60123F844CCDF2D24A6432AB671FE9FF12DD5AF214C5F910B6D35E300642F5
7DF00D8FFD0704D79CB723B37BF721C617F37C522D29D0245EB52EA2FA0196CA
C80051FA3FCBFEA0DC0EAAC1AD08B589CEEE8C55F7B848BA7F2E7BCA16641841
46B4C9CC8717699C46844A3EB55D0B7329F03BA682C59F1FBF779F37E4661852
A802BDFE8BE6437E638FA419101212731194F7C92D83695EDEB559F0D4A8F736
C91556B24B443B7420A3146C19FA9B1B6BA6F18690B6A1A118BC70CE90DDDCE7
C03CD02371191B32E366A3F998A90AE3A92C71EF1E9451837714F25E27E0AE41
061C0F4E8A593B7F4D562A9AD55EF79783D9369C091378A05DC3CE54731591AE
8215A47A33CC48267EDCDCC87FA6E170A5A3BC502A6B7F4B6AB0A67AF307507C
1E961F5117F5238F06AC53F71BC812FBFA7343990A15C150C89BAA0BF6D7BD13
5D366B6614890230859436B2A0E95EF2DF3D694936420763EC4A607794C02F70
EBD3932A1B6A4C67772E6951CF6A1610351863EEBFF41D28C3A38D77BBA249F8
4B11047B15F963CD765E69080449D262FF06964A745AFDB21556136A164CBD22
3685A54EF573BE722ACDD0F0E408E50ED48D415D837B3FFAEC1BBAC9FF94E837
29F822EF398789837FE83E5C9AD8D2B070116A145DD1B4CF38B4F4FC0803BF61
76B216B0548AF5225498557E03108414CB221F8802343692C68AB1C2BFD00F84
423EBC35395BD8CB1E8273A55216313CB926B3E294194A87E394EF0228DDCEBC
94807EB8FF73D19CB5159AADFC935416413275DCB8D93BA1B8B2850D438C7E26
2C0789E526588B790A82E5F04348AE7381E9DF94E06379B6853165E5D5D76961
C9E352BE36F808BC50AC48A9BD9D5C4C47B3610862FF11B7041203373710895C
56D8EAA5874F8999D0DBDA780B463327765A7588D6E2C88552FB3F34BC7EA19C
E0A2D42A02C96EE972B3457A4E6039FC4BF5B5DA17397B9529EF8743BE8F018D
B625B52C19124D3640CA3A1C365D4914C565BE342F1D2BB0489397F0B5023DD2
E56FE9B3B25E9A225EF88ADADCC237D0A5102A495B8D985B597E861C5A921569
C5D3A700E5853F244A557A499E9535FC70AE764D27B0C2E033AC77CEEA72E46C
C9D50FACECC9AE2F0F5043D59D2B5A7B7DAE1E902DB0A13E4CA8868240FCE673
3B371BF36032584C460A89B31933D20964588C89EC9E89534F6EAD90FDFB10A1
29D41264A039D4B882FFE5D7E305A01C62007706120C3B6B1BE15CB055823E59
A706B3E0260FFE74D8FB6FC2920AC2A49FCA5BB62E5E25A8C74678710C9034B5
A298C67F0F412A2D986E1014C4B5D48DBF039D1AD31DB048896909297A732110
C7101CE9469E3D6EC9ECF1FA7D1C785E67EEA887FFBBCF34EFAD7D24D0C2E12C
DBD22B4C2537FA99952F9B57D5246FB448B8C0FF52300FFC102FB9CF4FEA20E0
AA511A876BC34B2FB4C6F4F0B91231525A40AEED58B4BEA500787DFFFE63AE4F
3B521A0A829942EBDE23AD1FE41E7EF8E4DE7DBA4E0823565DD3251C43B948E3
2AE92527420F56A44CB2F2A844BD9E19A6ACA8DC227D01B188C850F201365D3D
90DE7011CAE69D1C8E2CE1F252CF962C18AFD70D490F20A4305479A29C6F7C69
451725A07F3D207117736D2F9504083385E4FEDC55460790C80DF396362C9FA5
E3D73F78E9ACED166652530A0B8303BF58C93413A88BED0CB5CF6CE6319C4E93
A6D78EB7D2604CCCF4E52172234EEA535A7E1F77827F7145090B58DECF424D77
ED972E913AA07AA401F1E4ACC1C0C16568ED5F87DAFDC0D4C8BA2B47D60B215A
112CFFE91E71DB34565BE5E24B9FCA5B558C2CC28DC21DA8EEE86348577FEED9
DEB03DCB5F606B1361D432433B3AD1349EC934434F84F655EDD13BE64F993CCB
50C8A1AE5BFEE9EDE53606CCD315663FF58508CACAEB3C2A0B8F93BD0A028252
7C417B1D790754C0295F6D9BBD04024769D7DC04C11F3B65216734BFCF8C86E0
991A029ABEF2251C2F02C5AF7A51C12BA4B34F308918398B620F2FAC9ECABF49
D334383FC1D90488DDFC9B2C020DB7A5384BF7E0E3A0E93D890B79F84D82DE0A
6836F54284D6DB463A0799D6B868928BCD7AFD9778D1D59ADFEC38A10A553D46
7DDED7634CBF06087B231D3A77099EE44BE0FE0F0C47C1598D0343196DF16BCE
619DFF4BCBE19C51DCE946A2C2E0C259D97E8A4A91B3D3F65C8632C9AE671871
8F585CF98BBB5CF5B6650366EAC5A8326C5EE8E3238959CC05AEBEED0525C116
ACE245596D4CC442AB836DAC48035591CB9256C0CD4CCE3F8060B700822EB157
C4BE8DE7BF9D445FC32005C6BE4758530F02C10DAA800CFA6819FCBFB27AA64D
8F11D9AEF8DBAB349AAD8C2504FE43C723EA41480CC42BBFE782077BB7DC6C48
883591E0BD23FF9EE85D7FBC6686954A2A193CEDCBD700A95844D87DB8F05F18
4A1213E6D171F03C58376DC7B7F920EFA9B18EACFDC05B8BD456AE6C34B6BE2D
5AE78C7F4E027362F8D83F4EAE2B37E6649F6CC017372E7B90CDE1352C08F155
93E9F2340B3399C4FFC028601595A97E6C5D1463E950859F033DC11F3404DFB9
1962B1700293D02C1C02CEE8F51DAB8C0587778833F7805F8E186D2F59D1ED60
FD794D19C6F35729FC33B7E3BD0EB10374E76E3826DB5728AF8F051BF08664DC
EB1CC4064E51A846089D5335A01E6868B133F54B6D63168339260F5D4B765217
94610519FBB2AAF6B9ECF6C6D3D5FF86E722BD2EB9F46D8896404B889BF0390A
543BDF32AFF067019F89DD6685D45CA0A617D2F569070C62EB0365F65070582B
0B1A7C67C3FEA45AF21441160D4CCFC3B6C5BB59F0CAB390053BDCC8A7C1E644
DC1AA2A947DE2FA98F90A8FCD801B7CB3370FC65791FFBC6C4CF3FC3CED050B6
C3FF817CFB05BFFD6CD16216A9D9D5BF5293FE347213289F5F52F3FB3DCFD6A0
2F9F3F7E242A6112F22A804488FB8BB048408033A3A8E08ECA4E47631D053E5F
B21CB5B34EB3E13B7927E672E35112E7BADE4F07F826DB26F736772974FDE0F0
389CB5AA31AF46279B24D58775EC3D74B5826903A8F7ED93432DF352C2F2B7CF
C65BEEB1C0E09EAA39BB4AF3D98038F17A7F89C6AF9781B4B0289AC61D20A493
EB77A775D5B6C70768A8A30E70BB5FEC96CFA30F4C81BC0152DA6A43C4E20D87
97011F507F2797E2FC08C2FEBA3E1372D09295900E3CF1710B6D68E4930A2A19
5EAEEEDA16C981D08BE6D0DACBECAFBFEF8E1885081943A757218D16DD1B21B5
8A6BDC7D7E585A9C849CE54A33D63B69215170514D3BC6EF64287F63007EC006
9515C10E979589DE9B49A1016455E172DE0C8F251558E0D294D3852D68726A4E
58364134F2FE0A6A33736CA5A054973A00E83B0512CE57800433E383731D56BF
BD7A298BBBE72D5668597E49D3438D701188AAE73F054E3B4949E83282580F3F
063F486963CF20FE96D7E99BF4BB505CF35C92006B6C46D00459F2D74C03EA59
52266A96C17DB91AD5B480F54E7FE205039862A59EE2ED4D4455C8C203E19D98
748D545B809E8261520397A1AC78A54A649CD11EA0372E799AF99DEB62F1FB38
6855F555961A4764A233A07FD42A52909D4EDE350108CF664AE4955F761180D3
0A63C5012428ECD18DDA85973394E646F1ED827F780B5C0FB1C5F69A8F049C48
C6BDE22BC03C93B648FF491E140B1FD99027A724AFE8E11C61763E3735E44856
CC47E4168E9DEC8B2BC71A671A758717F5CB95A48D69756EDF9C53D8D747603F
36F68AEFEF88DDC0D9F2E95DFDB1DAE428DEA1143295B18EFD0A4F2893CE824F
D41C738DF99235FC8AF7B0A7FC07C2E6FB4A905538F9DBA3B60F32108AE4AF64
42C6388024212A31754A7A83793008788DF39F63343A5ED460BDBE3D0689FED9
945C5B17AE332FF50CDAED756943A9357BF2760938E1DCA4944F1566440A6DA3
98BB7F588CBEAA6740054F6FCDAB5D853EC4BDA132F06D17EBB45E69B8639BA8
4EFD386C6B61A5E595B9064B6CD45D0FA0FCCCC6146EF5F43273B2F69E123655
905F4DBD478410873D3AEDDBDF6592C78D21261184FD53383443F93B8280E76A
A67F0DAEF50933285BCD4DF89B91B33FAFC4A4B3A3B0BA1E535AF0790A69C77B
E2D24015CAB7CE0F3730398EDDA9F77E827645BEFC17343CA0E13BA34A695A6C
5FFC999E736C2CC2B6A928553E7F0FD02B9073CBF0FD4C582927E6F48151E720
E33CA846C5D2069FD283743043202CF30FD1073D069395EEECD068898A38F1D9
5736333E51C2F4F2A7B838F8E6BBE0A808C655514232B360A460B072CDF8EC89
D9AF6EC46B4F9F10C7560540E1B3F707D2288E920B632D3E3FF9B9765C90A208
40F17A511F9E579537FFCCE3CA66606EB99C7E2692B59158E5DA957ECFB290B6
AC144B55EBBF49D79872FCEA1546BA7FE32409956835EBFD39C99EF6053BCD23
44E01BB53426EA57E33C2B82DB84B3F5F85CD268E133CE46108AE849BA825C64
44D57700ED6E0553119D3F059DBC19673E83BCEEA13C13077B2496645DC8BBBB
636F81C0DD27368991A87F80684643FF46597288116C86E03E8D25D53698C4FC
AF9942D34D39D44589372B5BC1396B66693591F60DE80B4C5D7ACCF2A3C8F620
404CAF4264845ED9EC42BC96CD67D8F5E70C9AC8D5188004FC8728CED50C278B
2CC5CDDD7AA8CD7D456AA2CA6B0D92CDE50AF4B961955CCC5625E659CF654E12
605C6431401150A631FA571EC27C9B487184992F35C66B5145C856B6211FC09A
FE0810B34E4A77D0D36887964AC6E0D5B2387345C9FC4CF18C319EBDF8BE6C97
FB75F4A3B4CA5E0CD4D52FDD6272E51CE3F04B4843B376BE3B9E23506B6C219D
E08CC297C736649284864609EDA6D6789E9D2E01985157812A8E5FF9EA17D907
0B1C7BCAAFF0873ECE46FB36D3D7A1E1ADBDF7A39ABC7660B16FDE1F90B351E5
09AABEC1345B4F3E192DE777968DEB89B92CFFC5E1C3078DE843C8C20FA44024
4753FBDD95032B9985F716E224A3C44B3E22288F48A88A99AABDAA73D5468981
2279C95FB7A4F7E840DD53DB50B2AF7F6F4E6B9F785A52A753A5B16547FF31DB
B8C74DA9C7DED6B5F375F6E1027AC6FDB54155A792A47D798ABF1A7DB33E3AC6
D59A5BCDEB066AD6F2D19FE75261A38F01462007615A45D3184BBAA0A23028C4
9CC69B62263F44A5568F48D5B2BF17B3D4267E29E4E83860839E9A4976651E94
145BFB0A5AD9E212FB24187CAEB09CFE7E9E41BE47EC3367E8743EC5C53FAB24
6E4BE2349868E7722DAF5AC823DF21A5EEBA2F555FC6F26FB7433B1B871A62E6
F358A76F1CF722C4E190D5DC20553D2D9F641E31BF0C86D82C29668337785AC5
5F63C514BB72725FAF8BE1D33873387274F3834A75D49B12CC3DAB6D463D7F8A
4B879DC4EEDD22E8E8144629AA8E5986E335755BFDFB63DE800C385269992E3D
6D0583B8C4D355712CE0CFEBA61250DECD311869A0226728FB583382DC2F947F
FD87403C9F874F8C8EC7D9490FB45106797FE7481905ECCE07B20CB88CDCA089
24F52ACBA645BDF2BD0ACE10B99E18F2F8898C0405B118619CB1786D4976E95D
7F665952C936507C1BE400F31623385E9F8DD3E90C6CEE1E2ABF700B4AB80C11
C0B4D03D40CFE0F8B75FF0ECB69B683BE4F244C20D90D2D69E1A6B186368BA24
83ACD153B00298765BCAFD77809AAF7D200354C768333AA6A5A233D203D67AB8
3EB787BF5DFB8EB15FF53FFB00BC4BA7BB30949F3DA0CDA15C7BE95535B486F8
486934F1D7CCF52D1F809A1185BE92D62556AFC695AD542EAFBA980C72435417
12338AC77476BA1008481BF141692199EFEC72AE94655C284861E483FAEDBFC6
6E0FB007D57FEFC2BC9F256AAFAFC844610F085652BA05991047227DDDA855D7
DA7A7E4B1700E6DECC761FC957CCFEFA9DE0EEFE7170C44079F0C765704D5B19
F74EB98606D1E47D09EAA3139EBDB56E3BD9EF521CC9DDCC9AE3C1BC8E20988F
BC4168C8AE6C99D80E14D8E02C1D3C4CD54DCCA57CA4B536D10BBB22DD1B68A0
A278E02684B907CEF368DD836DE11A60EC8F98054A56D866FFD1544755CD8F00
D979C56B308A5986B263A42172A9FFEF6926D270D8F094780BFE32E72DFC91AF
FAC82B3B281B291B4C1756D834F7A4CD1BAC5620D8B62B8B3DD13088FFB68679
C38C7E7C399B81B7CFB91566E6F0AB4A3166F740E4F6BBBC6A589B6B7DFE90F0
88B022855F79ACFB071C0A8DF01CC857B85AEBFB982FA5DDFA22F76459E57E4C
8FA06070A5DDF420C22C05678064EC0CA2879D3449221B1AB847E7A81AB2EC63
D0A46F5B7A826EE5AF747CD4F81C7BBFCE22B2F8E53D2CCCD2F2CA98F7735877
2E82FEE206948CB79F29EB54490428B5A48080A0E95A00D0F166D1AA1C5B8BA0
0116FAFDD66C3DBFE6419612225D642CEBA1AF034C4AA91EBD84A394F47883D0
4366386D92945935DE421048785BA79FCB77621175289491E7A1654F2D89ACD7
3ABFF5AC459EA5D3F07D909C9A1FE25B022D9E5BE4F0818CCECD3FB68C193605
9511BEFBA39719429CC941C7C228B6B6DF011946046218BDC81643B983DEC9F8
26EFCEBC849C7392A07B395DE496EF8A8E5DEE006EDDEDF4AAA253B5030CFC5C
434AF30771762480FDDCBDAB0BE07643086A1C212093C6B8500BB1E1CCB703A5
15E4B1D7BF74D767C599B81A74E19A09B1EC95FA761422D7F27B38F140B23EA3
E996BFBD4BD9D6D0CA2C3EC91D9889CB86354F0B67CE7E9CF9EC0EB466F1D41F
C1C015A8646D7222CA41E05AE3EFD088C3775F7943C8D78871C886254DB67E3C
FBC1F6F985791B7878BCC474E8BBDE6E9262F214712F0012C39A5DDD23229FE3
15D58092F7B8657B8861665A1DE92BE602F4AE93E14778F485AB655A8CFDE3E2
FE96CB4228E6AB3E6B8156D9AE138150F42147CC0C3BDD8FB23BE9A026EA2F2A
0FD85B41CDB248247EDF7F1ADBF464A5D5E11D87BC666543030B96026F0F48C9
4991EDC4BECBED7BE1BF9E9308107E3B11C398E88A7A33FC9FFE0ADABDB61315
E9068C032EA11E70A0B1EFDF40752BF94A98902E608264DED8C3241F0B4E0150
E1C40EDD6DBD115CB6E00E3866E88FC69A1215805801DE02B1C3A9A93CF96139
9ECE1A897788B2B23C11E880B78186D7F391CD91B6222E88C0BCFF6620881498
2B5BB316E904B71922BC9474D03BC93FED60C902156CB77548193347AB77051B
3CE85340294535D4C10F41A7F695AEE3DFC6405AD73520B4A78AEEB96AB6B0BC
336B7924A0067A893DFFFD64DB0BCC9760C91E86284AA24BF1A532F194C52445
8044D3C80CB40D65BF919B7FAFB6BE66C38DD1D43E8C7B81DE412C9499615E30
78045831989D3EE03908AF2CFD2E4908981F51AC4E66A3F826145368F234FF6C
2A313F2C5326CF9DCB210F48CDD477CF72F5DA72A975945FBB6481FBC4F25889
CCCD84E3374F7142F60131BC8969A7E52BFC97C3C1CC59ED40A9769F3B8B9F9A
3F4B89932B9982C8D4F0302A61C41E33E511C8C51E46955F30A76C6B243487AE
5A649D850B6E245E2B4564FE7FCDB9B6D54476489D474AF99490B2A943B1E016
B0422DFC5718733EEEF10A2E54A8082A9925BA38AEE46F12CC16254F52A26FE4
7FE41504D3E851A0615999DF8403DC91461325F612CF1421F3099CCD799C2044
CD468DCD65C961DFA7A9D7580AC15BC89D1266566B89AA07C78FEF6DEECA5A1D
957F459CFD15BB117B5C9314DEC6DE448491EE057D1A0892D6FC840E3AC7988F
24B1C7D0C795540D7022178AE1D40B49F6F126894B7059C576B4D2C0840D58C5
87F10C7A1DA59BF2D1E3D7BF48D39B8125835643035D4DD01E1BD4BE556A7FA1
CCCECBADA373290CA7F6892C26CB81E231E7BDC1888E0034288E97C143576D2A
D37F46E21F017D2EE3C0C98228BF9EAF57081F57DBF9D74E7C30176418639455
472ADF6C0B8DC625164B44742676C8A12E7009F4D6AB55DE1AFAF270C91679C5
16D2AFE192B8FA27841B4B29EB51AC45E203BFAC49B7ADDE319646273817DD84
F72EF2E65AC04E2727A88AB6AB5AF0AC42F2C9EA92E8E0FC50C754DD9BC3A4E8
F71927FD64EF3E677FBCE45110E40E9EC21815BE97204C80E94B9F75FA7DF12A
3C458904B575A8A00D58BF56E488F058D0697D176582CF8A442E66EB2494F8A6
0C57B01F6B3D5230BA27A8DDD53FBEE00FDD80D52109B4D0000BA0CB79A6FBAD
1E171AE3D8D4277E0496F0FF797C877726BE31F7E98BA78C2B52607F5AD63067
BF47432AF8A0DE382A70848E0AB53C41A3615C381C5147EA040B7F092DD5E551
4CA68BB67B6D0DAD8CC299A8CB22ACF60EE6F17E493ADA2B581BA1AA2AD552E3
E8BC9BFC6F9E9159E2E1416C13EA9F5DBFFBD764CC41299A28BD01BC70824204
40288B6FAD2EF9A68D9E873A785972478770CFBE5548EC4D13831EDE8F5F1DDD
A31D19D06C997A5ABA2257E904FB002E85A4E0740F8195C8B648E7A1CBAC44E9
B037B6EA815C3D70DAC34AC084B1A7BBC56ADC1A80619F155C66DC637B24236D
AFE0AF9029DBF4545EBC55591235C56A4CA40CB555A4BA1A2E7FED04B18C51E2
302E8F26BAFA9C2221DA78445A1CF8393F555C93638C0E082B50445A0C53B371
A14F6A48EFD9E5FB9959D6262C8417F7F59C0D18E5DAC7364CFD4E004BBABA5E
29865440F47F72DD6B6E9FCD7713EFBAFA5B21C994D8AA12E1FDF5D6FF6726DD
3D075DCD056F07F7256886E27FC021114A82B2810D3098D7FE2935E62A928F67
117694133A3248571E032FA87046115B7083025B0B818AD62A83D27A94524FB7
12BDC72F8DEFD25B8C21F0BF66F347EE1D6DB95461595C9938581921663D3F26
344D471A4D7A6449D75188F3F600D5FE70576EA42445236B618126D10754D562
A97C214E88DCF08F2838AB50B73BAB6709E9D28B9FC63F29F5ADE779AF01E782
48705CA6F4C48FC30D76A376494DAD0AA788521B3EA652062E65643D67891129
061203FBCDCDD71DA8673DE30B8C965940AB8DB67D03377EFD78B3A2F97270CF
2AA8ECAFC79BBBDB66CE1C1A46F34C03E5A41ADC0636AFFA3A9031A7D52AD383
ADEFE95750DAF4058753FD98816588DE6C28E369C338B89812335FA4C6AC4220
9CA64E764D3D71B7F300E399686FC4420B53110A5894DA4D65D3E6DCBA5BBF1E
7A2AEBA130BDDEF0D2002008116120BE3E47C31D0B5A0CB37EAA52C5AA0E2153
57F7DC728D263C9A3578EF055D45BE4763FE8FD1640C2660176DFA9253689BB1
D919F4B7E14FA1566B96E221864A45A24ADAEC63F61C9FD184263B38E6FCD313
91045048E7307578E0CF768A37F877976AE0B5008F455D72387C1C42775FF674
A31B8E86E3BCC20A63458C17EE6E339E5C32F94818087B099E32EDACBFF1CD52
09602C5B55A9C3C58F0CA12749AA590BE1A7D7CA30F0890DDD9B785A908E1E9E
3FF3FA024A626E56A0DD200D31F6BA872A3B7637A174FCAD9B6D4A7C2CD6DC37
4A48A6BF603B155F077601E14752542843D172D4B7E89F05609CA1031E102654
9AD33A81C771C8CB4C1E7696D16531F373E6B612C1D1B576609374EB67EDF4BE
D9D400B726B6C1CA2B5F5FA59C750062F35610FAB00F96E954D6F065320609E9
0FC4368928E9D1307E6C83430C94AA70DE113AFBF1EC125FC8E457BDA443CC0A
5675418F3EF2EE092B3043182EA2E951687B8E23723BB19C1FD74FD12D112FC2
BB60E3AB70FBF06E7D8378CBB6585126F5302B9FBDE0AC56D4BF37E98D71885A
CE5CD5CACBC8BF7AE4101C662EFE3F1817ED7110D43A94CDF85428A03C3C2D81
42CD352ECDE566F91395115B935A92441133D972E4F74A642552D6C6E6570668
6A49D427CCD0DA4A2672D801559E5D0558E8C4192AD8849C0A2084B3E142F388
5534813A515F1019B48F1F0D7967A8872D93C208D39E0A45A5F22CD1230DF661
82266DDFC2769F3012B797542CDDFAA14A8E5F1B317E75E5E54D0FEB31A7A07A
A201C7E71AB251A92E6EEA7D38726F2A1891340BF1DA9F49EDA513D505182A15
725F6C5B800AF66B44344F1DF681219626CC36AC51389ADC418F07FC089E8E4F
3C0AF189B9B778BCA731E5A7F4679D980EAAC61319BC954E1F85DC868A9B0118
1FD4EAD044416C29DCEF74F342DAD4ABEAB65D777DE200E5A439E880B3DF3F21
EACDAEA25114CE2484465A56A684012053B3D078104E86BBBBC9CFDB6C84A328
07C04E35739DA44B77BBDC61EFFC003F6D955AEA97A6FD08479EF9D325412387
AA488C8DB19E7C71DD362280EF53759C247901EBA8C09E0EB48E2446E4AF11C7
3D52910F14BEF067F255C44755C3A1889B7D6498A0F0C355F94E92659245514F
B481358AB0431632AD04A6AFCE6D4D96E57440D0CC6DB88B04BE224E8FC35C43
DE0D5A4F0514FF307F5ED154EE1D75FFB9F742BC4FA62D0F0B04F5A4F9EBBFAA
FFB7CC416D4C9D99F833D72AE088F54DC0BDD441EA5EB5A1FB82338120CD1D15
987A7716BBFC20EB3DB805CAC99BDB87A5D203A9F5E0CE1DD74F1C6081D61317
763D0C226C1F585CF8769D6EC9D065C88DBA642AD28D87F188EAD260C3952A7E
D8D31983B6A9DB00711B0A471A98DEEB675A8948D1D2B4A1367A5A069751D45F
B473FD3CF2999566C2B35DD43175A76C52EC37CB7F88B3D6EF4340199EAABD47
098BDAE1E3F35BACEACFAC4ABE1B743B59F80B5C78D282C98740F365E9F18AA6
15FA42F2F264CE7F1EE1A451CC545A839091A8E8E4982AEF3F6B56C775BBB3E2
F2DDBEDD44D9B5DAD8B2927FFAFA6E43AB2421CAA2FEAD8654376A9E10D0CFB2
943476BD54A39D11DD61A7C7020B76E286E9FA8BD8E4A98BBB5AFE57BB08BD74
69435D6D2F7B5D495498094818B587B4233E69308E70FA7996DB1B6A97E165EA
DC6CE23BD6CB9700745AF6C02D74A4D2FBF20E45EBA5D846EF69573C5C757A1F
13A7AA1BAB43F14CED19142764D33FD6BD4601F84AACA681150804D743E63573
3BE09CDBFDFC9B81ADB62601A04C690B74207F0434C9599D055D786DC25523AF
3CDCD9DD3813967BF5F25AAB7D4579104C9BBD893181C9571FDB535294653BBB
698E327CC26A6166E0400A542DCCEBB7EDD5A65E348278C3708042ABAE0FE273
BD9A31FC8DA5F4A317E7644446B44BB8012BCCAF8C5F9F39FBDBF92515FD7870
D55FCD937B60978AE0D5CB246B2C8F72A35B8E19688E347FCF71AC2C8CC30073
292419D853B7560C85F16F9F78C9C68D6ABEDB557C194008BB462DC518CC5BB9
03B51C3AFB389AB1DC905D2BEB7D8A7A881777FD41A10B04A6B12B84F00296D4
C27E65BCC2894545931058978D43A23EA657021D723C670A20AE8BE3174147A4
AF8F821BFBA31BFF602A21B3974899A4C8F8101C81CD6FDD7E2DB7385ACDE271
D9F3A9068D32ACDB476F04E5FFEACBC97E5827BBE22DADA452F82097ED5DD8B0
0DFB6C20433C4F265AC9CE5BDE7A2C9A124900DD8F1732791A32ED4820FB93C7
F670A309901C67ABBC61FDF2ADD52E1773E48CCEA5DE4AFED924430C88DA60D5
4DAB1FF0F28B7075378D6C2D78641424814F2BCF083E0B5BCC7BFF6D08F61C98
FDACE77E40339955325265C0D59431B590ABCBE2A26B320F240183CC5E524AC3
CA9B8A42C182D621271D7CD96933CE0D60F86764C354BB00E966EEB4D3F920E5
5F0E6BD41BAC278FE141F4DDA5061DF0417F99C38DC963AEC0363B88C91C8612
48E5A3B96076F337DA8B99390216C43F71762B08E8B12D4879A1B960072441F8
ED89478441C0E3EADAC3F014B1291E6C52B091AD4296CEC91F7C20E9CF94103A
C36D2E1E53C13785F134CDC2B76DF6A3E9FACDF70F4ECA4EC27770554DB296C7
9D6604875D7CFF30948A4CAA3DB59ABC1BF5F7269FE8A9F7205585633B4C3119
4410F23087FC234A6A50D409FE2155AE4BA43F86F5ED70C6C6E224A1D1810B75
7632A03BF11022DF23B383E39712D0259C5A0BA9A34C78E06C7E4C305D6A22C4
BBCAE2F14C07485A37B977E3C58B941166C1EF276997F43FFD6487CDCAC9BBC9
451EDA76E0F06E75724F3301194447ED73A884A5F19F3FEDB608C178B9CF687F
6870B3A796EDAB7119A4386C1FBC1311951F039F1D9A37844C7C6D9D85694CB1
EF8CA99B057CAEF9BC50F0EE6AF1B93250698AA15F39D439E5109C4256E14813
707C96C369F883A6E09C61A07064A6F44AB8719B95C8C26C9CA26BA670D4EE32
8E34E8B1362BA3A2DDF29C622FA55D54800823824AF2DAE2376EE46E7E218A38
68A1F35192B6A29EBC2AAB1C8360CBA4F5559692B7327B6720BE086562C6CBB4
895CDA54E3B470A5800B4FEDC4A99823CAFF87E567B965718083F83FDA1E8ACC
3588B776A0F38DA32B37B3D6B8750DFB0E869A35A58844DCDBF7DCE03D6DF9C0
2645D738E5824CBAF11E2FE0CB1B0FA2E6ECB9EF217B8FADECBD1348751416C9
EB562F65C3DB7A4AB69D26B5BF8D90B2E51E2702954300CF179607A73E1F34D1
0D682816651ABF47E2F8912C0AFA2D95FEC8E672698600111A092D1DDF35FB19
0DFDBF3732B48869A480A92AD41E3E1C55BBA48E5A270A6A58CF170CCDFB350B
A1C7F36DBF029AF9114D475BF30A5D651F8B1732A1A8679B99921E6EB29842A5
B04E360D363438EDB94D25B85B2FFA06BEE4B4866CCD615A2229984E45911A2F
A16D8104CAFD1564D3B589B580D016257B334B648E11C3659B24D8FA804D5216
4DEA4E54AA3EAEB35FA5C74AAE3A3CF4BF3E3E7E1F8D696AD103370B4D2F92C0
1428AC9051C9F5AA344BCA6CEC10B2332E12D719D38E452C6038C70A372CA658
D6D67AED8C156843093EF00BE48C470B0D86674D497A7D0C4FFAD8BC8863427E
906F6BE20D0A99299319E6B3BEB9FD8F96E8AEE39D162B8CFA8CE4D1FFA3B942
DE041262F04E6FBFCB61D5C84EBD82EE0FEE77A69FE220C5C7838A41D37EDCD4
D0C48A01818252AA45E015ED22945BE21A9DDA0AD4D9260EE42A680B12E95FC4
62DCC54C44587EC297569731F3DED28D1C03E88FACD342B9BDD752E5EA360238
91A0D0498FC46327C16278EBDA432267B7341E9AFD5F6E12D5ACEDD2F4D85171
905CF66C5A32F8CB4DE963A5DC52D640CE11A72FBDD01BE9CFDB611AB9DDFE6A
5A10F028A8EC5367D30A7CA2F279276A9325FB1922E8E2BC4EF9E43DC1FD4FBE
2F70FE56B13AA90E78AF892C68B624884A8C6630C0E0ADCBD3D1F3B66962A7C6
579DE0654DFBE84F9454D4E3F48E380A0C7E746DD9E1171D6D4C4E9D264F94F3
E552310DA5F1A568D92124CAE48765BC693AA01D8B1C3D38DF16898E28BDBB4E
975D99697D88EC5151E7249BECB6AFC92869148DBAC1EA48921CE9E2CD6ABA43
C992ECE0C21094A0FBFB4ADAD5356311A19FBC6D656A4ED392730C66785D661A
19C6090D596AF51562994954916523A24D9037CAD68D730C59F8916DD217E3C3
3D48197270F51B985F869B5ED92BF513ADD2A34677D5EEDE8D2CD88DAF6C983D
4950AE2043610480AD2469815377244F75310CDC69EB0AFCE824D6275ABBA8F5
B93733B9276AF81B876114048628CFB416C87CA9345C5207B4CC9BF529FC43E8
D9B9323DC3BC049097E0A9A1D2855D34C95DB377A87ADE4954D0B1E18023A187
62AF5BDFCACD3A22A78819E3F40C889D403830556B6147819B2A0321B548C04A
D9A989626BFC9C85D0FD3CAC5B575A6CBEEF06521A3E7D9F0FF17722847C88C9
C0A2FE4804ED676411B1B59DF4B2A04177FB9384FCC804315C355A4BB092D34E
BD7D3DC29AB6431E8A6A1988B04AA2DEE0F00E5A2980ED38326FFC9823AE829A
533BE7FAE9004BA387FAA8212473309A30DE5AEA07A6EC2C658547487FC2B684
4308370FD72A86B9F997DEA662B7342EFDC90B3BCAB589A886476CBCF92C27B3
6A2AB5F41BAF1D0DD6A23A4B87F89BABCE77C8F2DA233F4E91CFB582DB80668C
337FF09006AE8725C14247A1824615385C77FF85DA6B370F01017DB6D4137018
EEF6C9BF625A1596A7A3B98C0A21DBF86953D18AD1C2573398F159E9097FFDB7
EF5D34C5AC9967F4F9F287D600CF12020B5D9DF384E90315965D9823C35F4358
BCA5AE6FD2F0CFD1F8470F0DE9599E8F9F8AE666AEB9B11B3D0DFA60D4F1FDCE
6B39387CBE54C520F448C9F6BD2A06FC203245246BE57408FCC7B3586AEF5F4F
170A83DA625EF5CC0FC9F75FB7A90677C02630C6B4D5387A6070BF2E49EDA952
8B7D8F8724EADAB1EA2DE9F26054D386DC5FF5BEF273980D9307AF1C23C23EFA
C7D47C4EB1E1B9EC45589B444FC797737012AAB970DBFD0F472B798B301739E5
1DD451D8071BF1B58C840313AC928B32367ACCACF67E6300AC1D1506D1AD1625
8593B23B0B34F1FD33C37C611AFCBF59B67AD80F8F4D376E1B4263B9612D5571
5B293A3D7E8447942AF15F35458825C77ACFB79C07F758E687BC747F74EF4F0C
52197BEB399437F35D266523104BF1F2120197E9029CCEC265896D7407CDFC07
B9558B366A02AD194E29C31962FFED37AA64ABBF57BA12069C0B0ABC6B5C2A2B
08E8F5AE4C1E037041529ED46ADFDD49FDAE75FCDEFF3F08E2A73F0204CBD6CA
0B2D651059C696CBDC4AA4D640AB7E1E74DDA3963D32C9F3FEF0DBF6C62D8314
9B03B5B9161C5B5E1FE556DB1626C8F8FF663005AB32CB4B565D620C2A709C44
F011D085D00483F7A3D5741EB51E3EBC641AE20B324996DD0F1F509CEC7CF2B7
AD52EE40319BF9FE809C13BE788C42E1A23617A13D098832C58EBB4F54F943DA
2FF24F2284897FB8FA742EB1CA422822BB85689EA733B47EC4BEE8E15140A13A
C25D5FB37CD18C66727A37A358B1683FBB94B1DF7E060E2FEF569F0772BEEB88
D1BB3B2808DAD2D34E58A96A1FF484FC12EDC306C2F280653D0CE418D9573497
D3911B0FE2FAC8591D434F1B0B6E1EE05D2296D9280D260928909446C50386B3
F948D6DD04BE95BF3724E4764BAFCBC86FE11E54EFFEAF8F40BA7AD459591914
CDC21723F445D7C7ADCE64594ABFAF9BE666202717BA26FFB09FD38C6355EEF3
D959682ACA36360AC99B61380C49A983C7D4A4D308262D9602F4ECBB45555A21
F370432226919E9782026DC6A0B2FFB926EF5B2BFEDF4CEFCB3FAB423EE2021A
2D8761A940E3BABC44E63A7FDD2738EC2C72BA2D09F7C60572E6C997F77D1332
AF890CD48D6E4B5EFB9187BF9D6A2AF289BF72ECAD6962C317C1306D4ADE0B26
B643227743448BF8BB7F8E45CB2FD9AA2EA98E381A01BA4C4E317470738A472D
48F732ACEF5D27A32EB653BD28B7D731523369D18ABC9F8E875DB7725A36C427
C50C33943B6F21D63AB217BC64202084603747B3DF1561E779955D2C14E3F287
F137F5D721EBE79A621FF37033CA412EE05A459BC9C3D8881540047B466EDDA8
610C578650E9B6EA14B843D2BF3CA3B929414B1B29EDB53F00CFCEF86DB4F0C5
AD881C25AE365EA7A44553C0A02F477E6169355E7DB7ABD4A4663A76F0F44232
B4628BBCBE1DABC0F88441D44DBE4736F2B650DABB0E06F4650378F0FB1E70FA
EC4F0CE31ECB58DF2E318B41923E8A047553D96C8FA33E8E0B3B670C05C8A82F
2CA3502F6BD5B5E99175BBC27E44F721DA99CF8FEA15D0A83A220141E8AB80E9
DCB2D121D2B29929705967C8B5E223DBB5447A91BFAE343170BD833BFD6F1A44
EF78C167190F3326BA35B2A0F95CD0310FBCFDE2994602CFA5EAE2D31192AD8C
6B07B35EB86914B7EB54BEB7FE4C0D915117723A85F0DFC1C267798CC03D4263
C1B0BABCD19ECC31616A409855639AB72C01625D3C830ACB43B26371195013F7
4FC07E862198AB570123C1102395BF4918D09A32C2F2ED1D80E2B3180AE676CB
CB2898E1E44C258D2B274A9CD17D384B8E746F84EBF53D777C2234DFE67384E6
E57AC8203F42125A2653CD4763C89CE51D484F7E49765600A125D6DD423540B9
6042FA1D97110E3AD5BA3103CBF311C1BE34D08A8AA469CDBE7CD30CB62763F5
4165434312AA5498019581C1BC3DDE3CD408714E8E7C016ED719D6A4D045FA24
AD8478F6164D9AF89DBBE3B49616C51E8265379ED8DE9A5CB14381181FA13E70
7E88CBC5B2A293496645BCBF1FEEB4238B70E3186F21BDA34BE9089DE440F4BB
B16C769B322A63A26DDB821EFFF0BF941A8E5B2610B4E15384FD809B87616EB6
6EB32E4C35D915B39A1A51EDB4EA6C457EF7808966D47877D7DE7C09AC7D66BE
8EAAB3E33AFAD299FDA74E5D24D0BEB247DA5241A1EE79AA0B88FF4B13AE2D25
A61778FD4AE99F5A8595EA82C3CC61A971E5038E74DD52223222E027E4FD61A7
96209D3FDC1297DC54C790239EC91690811B809E89010888BA2A9B4DE487EACE
76E945DE688827ABE72A6E4485095F808BFBAB8BC1649B6BEF663E87ACB1281F
DAF2ED1FCD70B4A6855EA1981C0ED808DA4049A6700FAA8DE751FEF2DACB35DD
22D384F1136820BACB653C3FA4D666E8B147016B1A332B35DE6926053D8C849A
3EB6D69FD10FEB4A7FF85D42CB66C7F1788201952C90E02265A9A7D6312011F1
9F94F8BDDA3F5EA22A50A6C28D8FE3A4FD8484506F7C22CE7CBB6F7A12FAF693
18771326C11848C9B5B979232FC56226944D020FD81ED6A5CEA103917DC51FDF
47381F2C858E1782F6B3944A3E0D021A9F4DC32CAEA346D9BA1E87592A3AD349
E05F5C58D578FE138338F5B16EE9B68DB98A3A9830ECD85E926A10BD75FC2043
0385A847FFD27C4F8F929BA6999DE4811C5D5F0BC58BC526716602A4B14A5722
899C534A53360EDA7D76291515826E985D529337EF7A03BE1CFB226F21F9B37E
C62F3A7DF003E5911370B9CE7E88DDDAFAD5BEC082B92B98004A03D7F6CA0276
1BFA33398EEE0DDBA7BCCF877BE2F1D1D6244B6B96EA9E36FFFA2C825B569D8B
573A033EA893D9CF7EE0F5AD9EAB61D9205C5E63F946ECB74BED5C234B1464E2
EAA7C8A7825C303DA91124307C482045FF43AB07DE4906337E6B7B0427712059
6227F5A83D76EDF6D0CA24D36DE6AE139AA835D75E20A4439354C8150527DAFB
8C8EC1202C05C19AEEABF21E824B0EC3822C390F6F5AB177190AFC7ED79AEBA6
C5EAA31156F1D68C1890896F0307D9727340DC7DA36302E3AB66F8F166DBEF7A
D60FAF64E8FB1FD3B313B09391689AB5A0541A9CEE4100CAA83C333EB9217F04
C9B373C41EFA804EE4A500C7DBF813A96D33CE84DDD135F6DCC8CCF28D24419C
4133E3426FD6079450B9650CFF75BDFD5B8B63C7AB1280D06B06FF4A6A7F5917
90FAC8D9703F88B0E6BCEBC9D3DDBED5A6AA5B2DD175F1E70AD573228C595AA3
B5402D32890405C4E0E27CE01E2B2F51A86EAACCCE24A5D24E8E02A5A3F54F85
B0F1DB97411E573B4E9913C527E9A8EA6EC377131F2F7ED1D2F20BDD706DE592
83C78A346C5FF668C0A54DB924E1D6DFEB4F4452E5A85AD2296BA9ED80CE6B1D
0C39EAD652AD838904D8310F9295743FEAA481F3A52479CEC7AB83231A84D8BF
9F43464CBD2B7354995DAB17E6DF523AAABDB46EB3F1566C5C248F66CE2E620E
133AC0D9B512779611CE9D9AD30416953EED50C727DE460A9A87BA1D836C38CE
353F6FA963020545CD0CBC1FBFE5B9F797391CAD29A3330D03AC8DCA5CD34780
72A619BC063986E9EA20014AC23137779B99EEF13CA306FE695AA7E21755564B
6F2525AEEA40FCF0A5EEB16389365546663DF25509971523A1202E04F77F3A0B
54F4BF863B4927C06205294A722F64AC571FD61FA536B91324450C8C780CAD3A
D0194206D06C9A9404110DE7E43AA7FF6CC707899BCDF787B2B8C9DE91336C94
FF7D18D3A845DDC7CF7E387414E4A0173B6B8B7D6EEF4AA0D9AA20B8E576AB00
C5311E1B5370C855A272ABDBCC6820D11266F7913970660552D2ADA2744DF1E4
579B84AC62AEF3EF25456D01DF3A3395E0C8951FBAA54E6C4D803F985AAA8CBD
EC598F17DA398A4118E455D44060CE23497CB139BAF8FB87CE524159B4902DAD
C17A5EC31B549C73CA73071D5D3636319E5FFC3D4D086897F464C5806D183FF5
82478FFA92037B11127511BE95DBEAB27C055AF54836A428A27FA7BE19EFEB0B
16C2B242D341A4DFC76ACD3CCCB5FA67D065DB2C7ECC1F0438842223DE824D12
1EDE1025B2741FA55BE9795AE2FCE2D512647277B9CE35A54F8FD498DCFDED50
43A6191F0460057685DA97F19A7127DFFA9ABFF8C8FDA35C658D65C71B268095
8E51C4CF9E62D66E58F42AD7827E16B759BB084633DA2FCE3A6A748F4B30672C
E859D0D2DDA9CFEC067FAEA930D81E28142759E4EC87A2D730BFFF21272F8F3E
22AEEA074766577A548E9E517968598288F1605CEB7402F22B48A18542D80F41
7EBB2BF391E1874AE8FE577E89B34845269C5224AD15BE33B08F645AB3D600AC
51DD30CB4BDC6F18CAC119EEA3754F2351E01C263140B0062DC07B17608BD212
0DB06182F5B7AC0FA18FA63273A2CF4210A14DE29AADF0AC9FF5A1A43346F06F
D1CD9F12A824316D73CBB1446B83909D79B4888253DDB6A00C75D1E9ACA15F77
B64C51E1ED3E98B9855203C3CC8C239563B283E129997FD36BB2C7362251B862
7B3E7BB7D48174701C705FC79AF82472890577CE670CAC28723484FF9AAB6423
C7612E46A37F9AE73180AACE29D079358FA22A5E97207FC54AB3BF711C0021E5
BD03AE61262471FF3A0AA3F5304CCCC4DCD51FA1EAA14AEAAA1094566BD5542F
C24D457B1F0A4E71E704C8F7037F43F892711BC26E893AA9EB633AE336E4763E
E47ACB74566B753586C697B414EF7562340AD52AA41F7AE6611A9AD2B9851F74
8ACCEA8D48D04F98492972697193416298039DD358E8C163504D6BE4F2797162
C0255FDCCE0B208F13784B80614046D13A056390D0B10E60AA7206277CFF0504
D2E0771877F605F7D86B59107E0A6965E694161992E876AEBB4B51349C4C6901
91BD94622CC28242C0E3F50DF49EB91E9D3802D50EB6D398FE4CD4DECC6600E9
387368EED243E23E2F1F724271903ECD60AFAC1FF4D93F4E629693E3B7C7A3BE
9AB3CB9E22C10C7D107F094388D1B9A019EAD1E4F15057580B0D72D6828BBADA
A19684DB541D8D299C5CFA46D3068D20292447211E296A38907D3833359F4FEB
A516C8D307753FF1D567A96A5E1AB2F9C2FBE9FC27B5021FEC750DE067B24AE9
AB71E7A53F47864D16247470EE400DCCB8DA177C3A2027A9F2EBE6FB9F74F946
F8474E88799B8FAEBFCEDB510A80A1BBCCA05E2F0F397B603BFCA748B7A64FB6
48DAE3094FF645B799A92B5873FC9B88576A96EA9A57D90A8B1E5984B5B1B5C2
3FB029B21699E668F0C613E8CF24EC08A8FA2348102B9DB7ABEC11927F572259
A904FDCE134CF0C8D8166CBD3920D9B3C79B8A7C665E867C2A8CED157C99450A
E17159365377311526C60312539F85497C8323BBEF46C2F51F7140B1F2E4B570
E9C78BB1665801DCC489BCA1DBEA9410F639127F838312BB5C618C90A7490FB8
805E0AAD27F39776013881424905B109989ABF512EC0DB71BA545B478B4782D2
1BBE9A111AF8B34E1259A39DD9A549ACBF1B3D209F6772D0589077B0BFEFF924
046C60A238B7A021C2C8576A20EC19734425954BF90A7DBB00977AA971A8DDB3
B9050D2F3A3DB09C27D46D2A6F15E7909A2B5127180BC5214B9DCE57EEA4FA8B
0D525E849EE76ED698552725DCF253D735DA953E85E1E8DADB97142792F55902
26402CB0E98A804602712ABD503704F382099C4AAD383FC6D66A566C0C1D45D1
83EAF6A93973C81F5B32D86B3542C21CE4EFE2F7238262BC0D86852DFD7038CA
C7706DD3A7E5731C1E3A2F7B2E61AA374C7E182BD4C48CB11BE50C07B152FBA9
7B615E7D50104C08511BE0984297096588DA4FE3727BDE311A702F7BA1CC6B38
51FF83CB84E7C3A963AF3E57DC2BC836066E8C6FDF3A9C1A993D05AE0FD67F3A
69AD4C5550D71C668AD5CF5AC90ED05D853E8F97AE8DC81463B67D7CC22CC651
92ECE26D777A20DEC1ECA1B32B3272369D88FEFCDAAC94C72BD9A7FD23A04555
2D79DA314437E706A2A427322BB70D375DF943C5ED0F1AB78B1E59AE681F6175
EA83F8DDB08AD112D2AF0648BBFC2B97E8CBC81543DB4C11F709E63A976A2757
BC75AE9969EA9967890CFB233F8ADA7B503343F8242D6040DFD9E3C2A3D5858A
E50342664017CE79AD866DE8BE7DD864149689621C56071957624315D81A8FAC
C16B7AC59047562A2DE70CAB2ABD3C25D5C9A250E4D2FD2A9AB2444BD0DE9E05
BDB850897BD1040A169396532635B98C501863B5B5E415B6114BE3A7F211267C
EF94AE96C1A4CDFA72880772963D97701D32D380D3E9212C86A50E81735CF177
DEF88D5D594CFB9A2F848D1E968A1E1A06128EFE5AC6C5EBA54F871AE48C13EE
18717A2FCC8B0BEF5352CB995B47A4719830181BA52CF8DC8175485AC318CC7E
3A0DE532FCA442F710F5A9E1A25708C3A357A2C9B2333A061A52D354DEA855A5
5931B770775A8D701250B992ECACAB1589E00DA961D0C513A880480D5D30D63E
DA3BA08650619F7267D729ED6279DEAAD60BD66BE6DC6491DFAC734B4F31A8B8
2A34612413047E98FD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 39158274 55380987 1000 8000 8000
(C:/Users/Chris Notebook/Dropbox/Aufgabensammlung (offiziell)/Typ 1 Aufgaben/_Matura/AN - Analysis/A)
@start /Fa 242[1594 13[{ enclmmathsy ReEncodeFont }1
1594.02 /LMMathSymbols10-Regular rf /Fb 173[959 82[{}1
1328.35 /MSBM10 rf /Fc 149[369 51[0 3[886 48[369 1033{
 enclmmathsy ReEncodeFont }5 1328.35 /LMMathSymbols10-Regular
rf /Fd 203[993 1[993 50[{}2 1328.35 /wasy10 rf /Fe 162[361
1[361 29[1012 1[361 5[650 650 650 650 650 650 4[1012
1[506 506 40[{ enclmrm ReEncodeFont }13 1328.35 /LMRoman12-Regular
rf /Ff 203[674 52[{}1 885.568 /wasy8 rf /Fg 207[243 47[640{
 enclmmathsy ReEncodeFont }2 664.176 /LMMathSymbols6-Regular
rf /Fh 201[406 406 406 406 406 406 49[{ enclmrm ReEncodeFont }6
664.176 /LMRoman6-Regular rf /Fi 133[418 1[497 2[523
366 371 367 1[523 470 523 1[261 497 1[261 523 470 288
418 523 418 523 470 9[966 11[731 3[738 614 4[705 1[444
21[366 366 6[261 5[549 27[{ enclmec ReEncodeFont }30
885.568 /LMRoman8-Regular rf /Fj 207[255 46[261 732{
 enclmmathsy ReEncodeFont }3 885.568 /LMMathSymbols8-Regular
rf /Fk 200[470 470 470 470 470 470 470 5[732 43[{ enclmrm ReEncodeFont }
8 885.568 /LMRoman8-Regular rf /Fl 177[830 12[830 13[553
553 3[307 46[{ enclmec ReEncodeFont }5 1106.96 /LMRoman10-Regular
rf /Fm 160[909 45[606 1[606 47[{ enclmec ReEncodeFont }3
1212.12 /LMRoman10-Regular rf /Fn 135[530 16[448 452
80[549 21[{ enclmmathit ReEncodeFont }4 885.568 /LMMathItalic8-Regular
rf /Fo 135[739 15[749 623 641 603 3[683 16[838 9[842
7[1012 650 1[361 37[759 21[{ enclmmathit ReEncodeFont }12
1328.35 /LMMathItalic12-Regular rf /Fp 3[723 5[650 17[650
105[578 686 686 939 686 723 506 513 506 1[723 650 723
1084 361 686 397 361 723 650 397 578 723 578 723 650
6[795 2[1336 975 1[939 723 957 1[885 1012 975 1192 813
1011 668 469 1[1021 849 885 993 939 921 975 1[614 4[361
650 650 650 650 650 650 650 650 650 650 1[361 434 361
2[506 506 361 5[361 4[723 759 27[{ enclmec ReEncodeFont }70
1328.35 /LMRoman12-Regular rf /Fq 133[956 1136 1136 1554
1136 1196 837 849 879 1[1196 1076 1196 1793 598 1136
1[598 1196 1076 658 982 1196 956 1196 1046 6[1315 5[1497
1196 2[1470 1616 1682 2041 1293 1685 1[801 1682 1691
1353 1412 1649 1554 1530 1625 7[1076 1076 1076 1076 1076
1076 1076 1076 1076 1076 1076 598 717 16[1196 1255 27[{
 enclmec ReEncodeFont }57 1912.83 /LMRoman12-Bold rf
end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 8000dpi
TeXDict begin
%%BeginPaperSize: a4
a4
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black 0 TeXcolorgray
-2331 165 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -2331 165 a -2331 165 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -2331 165 a -2331
165 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -2331 165 a -2331 165 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -2331 165 a 1328 x Fq(AN)718
b(3.2)f(-)h(1)f(F)-179 b(unktion)714 b(und)i(Stammfunktion)f(-)j(O)-60
b(A)717 b(-)h(BIFIE)p 0 TeXcolorgray -741 4800 a Fp(1.)p
0 TeXcolorgray 651 w(Die)434 b(Abbildung)f(zeigt)h(den)f(Graphen)f
(einer)h(P)-36 b(olynomfunktion)435 b Fo(f)142 b Fp(.)921
7346 y(Zeic)-36 b(hne)430 b(den)g(Graphen)f(einer)i(Stammfunktion)f
Fo(F)611 b Fp(der)431 b(F)-108 b(unktion)429 b Fo(f)573
b Fp(in)431 b(die)f(Abbildung)921 9338 y(ein!)921 43450
y
 currentpoint currentpoint translate 1.3364 1.3364 scale neg exch neg
exch translate
 921 43450 a 1355 43450 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 239.33064 a add def
/d 0.0 a add neg def /h 212.63753 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 1355 43450 a 7343 41097 a
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 0.0 T 8 { gsave
 /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L
stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1. 
1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 185.23111 0.0 -54.09953 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -28.45274 0.0 T 9 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 191.38481 0.0 -21.25272   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 185.23111  0 -54.09953  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -54.09953
 185.23111  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-21.25272  def /maxTickline 191.38481  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 191.38481
0.0 -21.25272   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 185.23111
0.0 -54.09953 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 191.38481  0 -21.25272  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -21.25272
 191.38481  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-54.09953  def /maxTickline 185.23111  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 191.38481
0.0 -21.25272   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 185.23111
0.0 -54.09953 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 7343 41097 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 7343 41097 a 7343
41097 a
tx@Dict begin  { 185.23111 191.38481 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 7343 41097 a 7343 41097 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 7343 41097 a 7000 41383
a Fp(x)7343 41097 y
tx@Dict begin  PutEnd  end
 7343 41097 a 7343 41097 a
tx@Dict begin  PutEnd  end
 7343 41097
a 7343 41097 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 7343 41097 a 7343 41097 a
tx@Dict begin  { 0.0 0.0 pop 185.23111 191.38481 exch pop } PutCoor
PutBegin  end
 7343 41097 a
7343 41097 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 7343 41097 a 6295 41430 a Fp(f\(x\))7343
41097 y
tx@Dict begin  PutEnd  end
 7343 41097 a 7343 41097 a
tx@Dict begin  PutEnd  end
 7343 41097 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -1.9013777032950112 def /x1 6.510129729096258
def /dx x1 x sub 199 div def /F@pstplot (1.5*x^(2.0)-6.0*x+6.0)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial 1 0 0 TeXcolorrgb @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0.8 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def    /x -1.9013777032950112
def /x1 6.510129729096258 def /dx x1 x sub 199 div def /F@pstplot (0.01878816167489931*x^(4.0)+0.36901366118202444*x^(3.0)-2.678740507834282*x^(2.0)+5.731121077541272*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0.8 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 0 0 0 TeXcolorrgb 7343 41097
a
tx@Dict begin  { 9.69206 149.3096 } PutCoor PutBegin  end
 7343 41097 a -172 x Fn(f)7343 41097 y
tx@Dict begin  PutEnd  end
 7343 41097 a
1 0 0 TeXcolorrgb 0 TeXcolorgray 27847 43450 a
currentpoint initclip moveto
 27847
43450 a 921 43450 a
 currentpoint currentpoint translate 1 1.3364 div 1 1.3364 div scale
neg exch neg exch translate
 921 43450 a 1 0 0 TeXcolorrgb 2545
x Fp(Die)364 b(A)-36 b(ufgab)36 b(e)364 b(gilt)g(als)f(ric)-36
b(h)g(tig)364 b(gel\366st,)g(w)-36 b(enn)363 b(der)g(Graph)f(der)g(F)
-108 b(unktion)363 b Fo(F)544 b Fp(im)363 b(gesam)-36
b(ten)921 47987 y(dargestellten)305 b(Bereic)-36 b(h)304
b(mon)-36 b(ton)304 b(w)-36 b(ac)g(hsend)304 b(dargestellt)h(wird)g
(und)e(an)i(der)f(Stelle)h(2)g(einen)921 49979 y(deutlic)-36
b(h)433 b(erk)-36 b(enn)g(baren)432 b(Sattelpunkt)h(aufw)-36
b(eist.)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
47992 4800 a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 6792
a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray -2331 53713 54804 45 v 0 TeXcolorgray
24746 81281 a Fp(1)p 0 TeXcolorgray eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)946 b(3.2)f(-)h(2)f(Graph)g(der)g
(ersten)f(Ableitungsfunktion)c(-)946 b(MC)g(-)-2331 4515
y(BIFIE)p 0 TeXcolorgray -741 7823 a Fp(2.)p 0 TeXcolorgray
651 w(Gegeb)36 b(en)433 b(ist)h(der)f(Graph)f(der)h(F)-108
b(unktion)433 b Fo(f)142 b Fp(.)p 0 TeXcolorgray 0 TeXcolorgray
17787 24855 a
 currentpoint currentpoint translate 0.67351 0.67351 scale neg exch
neg exch translate
 17787 24855 a 17787 24855 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 150.81612 a add def
/d 0.0 a add neg def /h 201.23447 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 17787 24855
a 28512 13576 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 53.92632 0.0 -96.8898 0.0   /Lineto /lineto load def 0 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 99.34538 0.0 -101.88908   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 53.92632  0 -96.8898  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -96.8898
 53.92632  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-101.88908  def /maxTickline 99.34538  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 99.34538
0.0 -101.88908   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 53.92632
0.0 -96.8898 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 99.34538  0 -101.88908  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -101.88908
 99.34538  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-96.8898  def /maxTickline 53.92632  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 99.34538
0.0 -101.88908   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 53.92632
0.0 -96.8898 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 27267 10712 a
Fk(1)27267 7562 y(2)27267 4413 y(3)26535 16965 y Fj(\000)p
Fk(1)26535 20115 y Fj(\000)p Fk(2)26535 23264 y Fj(\000)p
Fk(3)31426 14922 y(1)-7135 b Fj(\000)p Fk(1)-4351 b Fj(\000)p
Fk(2)f Fj(\000)p Fk(3)28512 13576 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 28512 13576 a 28512
13576 a
tx@Dict begin  { 53.92632 99.34538 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 28512 13576 a 28512 13576 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 28512 13576 a 28169
13862 a Fp(x)28512 13576 y
tx@Dict begin  PutEnd  end
 28512 13576 a 28512 13576
a
tx@Dict begin  PutEnd  end
 28512 13576 a 28512 13576 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 28512 13576 a 28512 13576
a
tx@Dict begin  { 0.0 0.0 pop 53.92632 99.34538 exch pop } PutCoor PutBegin
 end
 28512 13576 a 28512 13576 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 28512 13576 a 27464 13908
a Fp(f\(x\))28512 13576 y
tx@Dict begin  PutEnd  end
 28512 13576 a 28512 13576 a
tx@Dict begin  PutEnd  end

28512 13576 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.4052929250927324 def /x1 1.8952898818965822
def /dx x1 x sub 199 div def /F@pstplot (-0.75*x^(3.0)-2.25*x^(2.0)+4.0E-50*x+2.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
34481 24855 a
currentpoint initclip moveto
 34481 24855 a 17787 24855 a
 currentpoint currentpoint translate 1 0.67351 div 1 0.67351 div scale
neg exch neg exch translate
 17787 24855
a 873 27821 a Fi(W)-78 b(elc)-26 b(he)338 b(der)f(nac)-26
b(hstehenden)337 b(Abbildungen)g(b)26 b(esc)-26 b(hreibt)337
b(den)g(Graphen)g(der)g(ersten)g(Ableitungsfunktion)g(der)g(F)-78
b(unktion)921 29126 y Fn(f)98 b Fi(?)314 b(Kreuze)f(die)h
(zutre\033ende)f(Abbildung)h(an!)p 0 TeXcolorgray 0 TeXcolorgray
5693 33468 14879 45 v 5693 47389 45 13922 v 6401 46444
a
 currentpoint currentpoint translate 0.54013 0.54013 scale neg exch
neg exch translate
 6401 46444 a 6715 46444 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 188.08176 a add def
/d 0.0 a add neg def /h 201.23402 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 6715 46444 a 16227 35117
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.15219 0.0 -85.92957 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 98.90688 0.0 -102.32715   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.15219  0 -85.92957  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -85.92957
 102.15219  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.32715  def /maxTickline 98.90688  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 98.90688
0.0 -102.32715   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.15219
0.0 -85.92957 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 98.90688  0 -102.32715  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -102.32715
 98.90688  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-85.92957  def /maxTickline 102.15219  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 98.90688
0.0 -102.32715   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.15219
0.0 -85.92957 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 15046 32182 a Fh(1)15046 29032
y(2)15046 25882 y(3)14407 38435 y Fg(\000)p Fh(1)14407
41584 y Fg(\000)p Fh(2)14407 44734 y Fg(\000)p Fh(3)19174
36320 y(1)2743 b(2)h(3)-13324 b Fg(\000)p Fh(1)-4196
b Fg(\000)p Fh(2)h Fg(\000)p Fh(3)16227 35117 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 16227
35117 a 16227 35117 a
tx@Dict begin  { 102.15219 98.90688 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 16227 35117 a 16227 35117 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 16227
35117 a 15979 35308 a Fi(x)16227 35117 y
tx@Dict begin  PutEnd  end
 16227 35117
a 16227 35117 a
tx@Dict begin  PutEnd  end
 16227 35117 a 16227 35117 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 16227 35117
a 16227 35117 a
tx@Dict begin  { 0.0 0.0 pop 102.15219 98.90688 exch pop } PutCoor
PutBegin  end
 16227 35117 a 16227 35117 a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 16227 35117
a 15469 35339 a Fi(f\(x\))16227 35117 y
tx@Dict begin  PutEnd  end
 16227 35117 a
16227 35117 a
tx@Dict begin  PutEnd  end
 16227 35117 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0.2 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def    /x -3.020076151328974
def /x1 3.5902436864571214 def /dx x1 x sub 199 div def /F@pstplot
(-2.2130955546979934*x^(2.0)+4.426191109395987*x)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0.2 0
0  setrgbcolor  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial 27535 46444 a
currentpoint initclip moveto
 27535 46444 a 6401 46444 a
 currentpoint currentpoint translate 1 0.54013 div 1 0.54013 div scale
neg exch neg exch translate

6401 46444 a 18480 47389 45 13922 v 20527 47389 V 5693
47434 14879 45 v 5693 61536 45 14103 v 6401 60591 a
 currentpoint currentpoint translate 0.55519 0.55519 scale neg exch
neg exch translate
 6401
60591 a 6401 60591 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 185.73473 a add def
/d 0.0 a add neg def /h 198.72331 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 6401 60591 a 17831 49075 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 82.48543 0.0 -103.2493 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 94.68646 0.0 -104.03685   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 82.48543  0 -103.2493  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -103.2493
 82.48543  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-104.03685  def /maxTickline 94.68646  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 94.68646  0 -104.03685  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -104.03685
 94.68646  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-103.2493  def /maxTickline 82.48543  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
16650 46139 a Fh(1)16650 42990 y(2)16650 39840 y(3)16010
52393 y Fg(\000)p Fh(1)16010 55542 y Fg(\000)p Fh(2)16010
58692 y Fg(\000)p Fh(3)20777 50278 y(1)2744 b(2)-10175
b Fg(\000)p Fh(1)-4195 b Fg(\000)p Fh(2)f Fg(\000)p Fh(3)17831
49075 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 17831 49075 a 17831 49075 a
tx@Dict begin  { 82.48543 94.68646 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 17831 49075 a 17831
49075 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 17831 49075 a 17583 49266 a Fi(x)17831 49075
y
tx@Dict begin  PutEnd  end
 17831 49075 a 17831 49075 a
tx@Dict begin  PutEnd  end
 17831 49075 a 17831 49075
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 17831 49075 a 17831 49075 a
tx@Dict begin  { 0.0 0.0 pop 82.48543 94.68646 exch pop } PutCoor PutBegin
 end
 17831 49075 a 17831 49075
a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 17831 49075 a 17073 49296 a Fi(f\(x\))17831 49075 y
tx@Dict begin  PutEnd  end

17831 49075 a 17831 49075 a
tx@Dict begin  PutEnd  end
 17831 49075 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.6287932658462516 def /x1 2.8990384294437543
def /dx x1 x sub 199 div def /F@pstplot (-1.0000884807074706*x^(4.0)-6.036615308075288*x^(3.0)-12.1813954069345*x^(2.0)-8.217037427227613*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 26962 60591 a
currentpoint initclip moveto
 26962 60591 a
6401 60591 a
 currentpoint currentpoint translate 1 0.55519 div 1 0.55519 div scale
neg exch neg exch translate
 6401 60591 a 18480 61536 45 14103 v 20527
61536 V 5693 61581 14879 45 v 5693 75683 45 14103 v 6401
74738 a
 currentpoint currentpoint translate 0.55519 0.55519 scale neg exch
neg exch translate
 6401 74738 a 6401 74738 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 185.73473 a add def
/d 0.0 a add neg def /h 198.72331 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 6401 74738 a 17831
63222 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 82.48543 0.0 -103.2493 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 94.68646 0.0 -104.03685   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 82.48543  0 -103.2493  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -103.2493
 82.48543  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-104.03685  def /maxTickline 94.68646  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 94.68646  0 -104.03685  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -104.03685
 94.68646  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-103.2493  def /maxTickline 82.48543  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 16650 60286 a Fh(1)16650 57137
y(2)16650 53987 y(3)16010 66540 y Fg(\000)p Fh(1)16010
69689 y Fg(\000)p Fh(2)16010 72839 y Fg(\000)p Fh(3)20777
64425 y(1)2744 b(2)-10175 b Fg(\000)p Fh(1)-4195 b Fg(\000)p
Fh(2)f Fg(\000)p Fh(3)17831 63222 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 17831 63222 a 17831
63222 a
tx@Dict begin  { 82.48543 94.68646 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 17831 63222 a 17831 63222 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 17831 63222 a 17583
63413 a Fi(x)17831 63222 y
tx@Dict begin  PutEnd  end
 17831 63222 a 17831 63222
a
tx@Dict begin  PutEnd  end
 17831 63222 a 17831 63222 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 17831 63222 a 17831 63222
a
tx@Dict begin  { 0.0 0.0 pop 82.48543 94.68646 exch pop } PutCoor PutBegin
 end
 17831 63222 a 17831 63222 a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 17831 63222 a 17073 63443
a Fi(f\(x\))17831 63222 y
tx@Dict begin  PutEnd  end
 17831 63222 a 17831 63222 a
tx@Dict begin  PutEnd  end

17831 63222 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.6287932658462516 def /x1 2.8990384294437543
def /dx x1 x sub 199 div def /F@pstplot (-2.201863609943576*x^(2.0)-4.403727219887152*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
26962 74738 a
currentpoint initclip moveto
 26962 74738 a 6401 74738 a
 currentpoint currentpoint translate 1 0.55519 div 1 0.55519 div scale
neg exch neg exch translate
 6401 74738 a
18480 75683 45 14103 v 1 0 0 TeXcolorrgb 19189 68853
a Ff(4)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
20527 75683 V 5693 75728 14879 45 v 24758 33468 14205
45 v 24758 47570 45 14103 v 25466 46626 a
 currentpoint currentpoint translate 0.55519 0.55519 scale neg exch
neg exch translate
 25466 46626
a 25466 46626 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 185.73473 a add def
/d 0.0 a add neg def /h 198.72331 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466 46626 a 36896 35109 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 82.48543 0.0 -103.2493 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 94.68646 0.0 -104.03685   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 82.48543  0 -103.2493  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -103.2493
 82.48543  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-104.03685  def /maxTickline 94.68646  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 94.68646  0 -104.03685  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -104.03685
 94.68646  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-103.2493  def /maxTickline 82.48543  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
35715 32173 a Fh(1)35715 29024 y(2)35715 25874 y(3)35075
38427 y Fg(\000)p Fh(1)35075 41576 y Fg(\000)p Fh(2)35075
44726 y Fg(\000)p Fh(3)39842 36312 y(1)2744 b(2)-10175
b Fg(\000)p Fh(1)-4195 b Fg(\000)p Fh(2)f Fg(\000)p Fh(3)36896
35109 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 36896 35109 a 36896 35109 a
tx@Dict begin  { 82.48543 94.68646 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 36896 35109 a 36896
35109 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 36896 35109 a 36648 35300 a Fi(x)36896 35109
y
tx@Dict begin  PutEnd  end
 36896 35109 a 36896 35109 a
tx@Dict begin  PutEnd  end
 36896 35109 a 36896 35109
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36896 35109 a 36896 35109 a
tx@Dict begin  { 0.0 0.0 pop 82.48543 94.68646 exch pop } PutCoor PutBegin
 end
 36896 35109 a 36896 35109
a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36896 35109 a 36138 35330 a Fi(f\(x\))36896 35109 y
tx@Dict begin  PutEnd  end

36896 35109 a 36896 35109 a
tx@Dict begin  PutEnd  end
 36896 35109 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.6287932658462516 def /x1 2.8990384294437543
def /dx x1 x sub 49 div def /F@pstplot ((-3.0021712888572467-3.0021712888572467*x)/0.6883799499421429)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  49 1 sub { /x x dx
add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 46026 46626 a
currentpoint initclip moveto
 46026 46626 a
25466 46626 a
 currentpoint currentpoint translate 1 0.55519 div 1 0.55519 div scale
neg exch neg exch translate
 25466 46626 a 37545 47570 45 14103 v 38918
47570 V 24758 47615 14205 45 v 24758 61717 45 14103 v
25466 60773 a
 currentpoint currentpoint translate 0.55519 0.55519 scale neg exch
neg exch translate
 25466 60773 a 25466 60773 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 185.73473 a add def
/d 0.0 a add neg def /h 198.72331 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466 60773
a 36896 49256 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 82.48543 0.0 -103.2493 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 94.68646 0.0 -104.03685   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 82.48543  0 -103.2493  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -103.2493
 82.48543  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-104.03685  def /maxTickline 94.68646  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 94.68646  0 -104.03685  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -104.03685
 94.68646  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-103.2493  def /maxTickline 82.48543  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 35715 46321 a
Fh(1)35715 43171 y(2)35715 40021 y(3)35075 52574 y Fg(\000)p
Fh(1)35075 55723 y Fg(\000)p Fh(2)35075 58873 y Fg(\000)p
Fh(3)39842 50459 y(1)2744 b(2)-10175 b Fg(\000)p Fh(1)-4195
b Fg(\000)p Fh(2)f Fg(\000)p Fh(3)36896 49256 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 36896
49256 a 36896 49256 a
tx@Dict begin  { 82.48543 94.68646 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 36896 49256 a 36896 49256 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 36896
49256 a 36648 49447 a Fi(x)36896 49256 y
tx@Dict begin  PutEnd  end
 36896 49256
a 36896 49256 a
tx@Dict begin  PutEnd  end
 36896 49256 a 36896 49256 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36896 49256
a 36896 49256 a
tx@Dict begin  { 0.0 0.0 pop 82.48543 94.68646 exch pop } PutCoor PutBegin
 end
 36896 49256 a 36896 49256 a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36896 49256
a 36138 49478 a Fi(f\(x\))36896 49256 y
tx@Dict begin  PutEnd  end
 36896 49256 a
36896 49256 a
tx@Dict begin  PutEnd  end
 36896 49256 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.6287932658462516 def /x1 2.8990384294437543
def /dx x1 x sub 199 div def /F@pstplot ((x+0.9)^(2.0)-2.97)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end


@endspecial 46026 60773 a
currentpoint initclip moveto
 46026 60773 a 25466 60773
a
 currentpoint currentpoint translate 1 0.55519 div 1 0.55519 div scale
neg exch neg exch translate
 25466 60773 a 37545 61717 45 14103 v 38918 61717 V
24758 61762 14205 45 v 24758 75865 45 14103 v 25466 74920
a
 currentpoint currentpoint translate 0.55519 0.55519 scale neg exch
neg exch translate
 25466 74920 a 25466 74920 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 185.73473 a add def
/d 0.0 a add neg def /h 198.72331 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466 74920 a 36896 63403
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 82.48543 0.0 -103.2493 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 94.68646 0.0 -104.03685   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 82.48543  0 -103.2493  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -103.2493
 82.48543  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-104.03685  def /maxTickline 94.68646  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 94.68646  0 -104.03685  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -104.03685
 94.68646  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-103.2493  def /maxTickline 82.48543  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 94.68646
0.0 -104.03685   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 82.48543
0.0 -103.2493 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 35715 60468 a Fh(1)35715 57318
y(2)35715 54168 y(3)35075 66721 y Fg(\000)p Fh(1)35075
69870 y Fg(\000)p Fh(2)35075 73020 y Fg(\000)p Fh(3)39842
64606 y(1)2744 b(2)-10175 b Fg(\000)p Fh(1)-4195 b Fg(\000)p
Fh(2)f Fg(\000)p Fh(3)36896 63403 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 36896 63403 a 36896
63403 a
tx@Dict begin  { 82.48543 94.68646 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 36896 63403 a 36896 63403 a
tx@Dict begin  { 5.0 4.486 3.4445 0.0 140.  Uput UUput } PutCoor PutBegin
 end
 36896 63403 a 36648
63594 a Fi(x)36896 63403 y
tx@Dict begin  PutEnd  end
 36896 63403 a 36896 63403
a
tx@Dict begin  PutEnd  end
 36896 63403 a 36896 63403 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36896 63403 a 36896 63403
a
tx@Dict begin  { 0.0 0.0 pop 82.48543 94.68646 exch pop } PutCoor PutBegin
 end
 36896 63403 a 36896 63403 a
tx@Dict begin  { 5.0 13.69456 6.0 2.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36896 63403 a 36138 63625
a Fi(f\(x\))36896 63403 y
tx@Dict begin  PutEnd  end
 36896 63403 a 36896 63403 a
tx@Dict begin  PutEnd  end

36896 63403 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.6287932658462516 def /x1 2.8990384294437543
def /dx x1 x sub 199 div def /F@pstplot (2.180778313501426*x^(2.0)+4.361556627002852*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
46026 74920 a
currentpoint initclip moveto
 46026 74920 a 25466 74920 a
 currentpoint currentpoint translate 1 0.55519 div 1 0.55519 div scale
neg exch neg exch translate
 25466 74920
a 37545 75865 45 14103 v 38918 75865 V 24758 75909 14205
45 v 47992 7823 a Fm(___/1)p 1 0 0 TeXcolorrgb 47998
9815 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray 0 TeXcolorgray 24746 81281 a Fp(2)p 0
TeXcolorgray eop end
%%Page: 3 3
TeXDict begin 3 2 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 54804 45 v -2331 6795 a Fq(AN)718
b(3.2)f(-)h(3)f(F)-179 b(unktion)714 b(-)k(Ableitungsfunktion)712
b(-)718 b(MC)g(-)f(BIFIE)p 0 TeXcolorgray -741 10102
a Fp(3.)p 0 TeXcolorgray 651 w(In)384 b(der)g(un)-36
b(tenstehenden)382 b(Abbildung)i(ist)g(der)g(Graph)g(der)g
(Ableitungsfunktion)g Fo(f)42480 9620 y Fj(0)43175 10102
y Fp(einer)921 12094 y(F)-108 b(unktion)433 b Fo(f)575
b Fp(dargestellt.)p 0 TeXcolorgray 0 TeXcolorgray 12165
40878 a
 currentpoint currentpoint translate 0.57887 0.57887 scale neg exch
neg exch translate
 12165 40878 a 12165 40878 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 350.93872 a add def
/d 0.0 a add neg def /h 381.25702 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 12165 40878 a 29194
35074 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 197.09828  0 -153.84044  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -153.84044
 197.09828  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-52.42978  def /maxTickline 328.82724  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 328.82724
0.0 -52.42978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 197.09828
0.0 -153.84044 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 328.82724  0 -52.42978  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -52.42978
 328.82724  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-153.84044  def /maxTickline 197.09828  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 328.82724
0.0 -52.42978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 197.09828
0.0 -153.84044 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
29194 35074 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 29194 35074 a 29194 35074 a
tx@Dict begin  { 197.09828 328.82724 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 29194 35074
a 29194 35074 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 29194 35074 a 28851 35360 a Fp(x)29194
35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074 a
tx@Dict begin  PutEnd  end
 29194 35074 a 29194
35074 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 29194 35074 a 29194 35074 a
tx@Dict begin  { 0.0 0.0 pop 197.09828 328.82724 exch pop } PutCoor
PutBegin  end
 29194 35074 a 29194
35074 a
tx@Dict begin  { 5.0 22.5208 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 29194 35074 a 27948 35406 a Fp(f)36 b('\(x\))29194
35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074 a
tx@Dict begin  PutEnd  end
 29194 35074 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -5.406875760298069 def /x1 6.927208122057785
def /dx x1 x sub 199 div def /F@pstplot (0.0011904761904761906*x^(4.0)-0.13452380952380952*x^(3.0)+0.39166666666666666*x^(2.0)+1.1345238095238095*x+0.6071428571428571)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ -113.81097 0.0 -113.0043 313.07352
  /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not
{ n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup
1.4  mul exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1
Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n
1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt {
/Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5
 abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos
ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop
} repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2
x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinecap
[  3.0  3.0 ] 0 0 add  DashLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ -56.90549 0.0 -56.90549 28.45274  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup
1.4  mul exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED
/x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1
Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n
1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt {
/Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5
 abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos
ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop
} repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div
}{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2
x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinecap
[  3.0  3.0 ] 0 0 add  DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 28.45274 56.90549 28.45274 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul
exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.6 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  3.0  3.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.6 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 85.35823 113.81097 85.35823 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul
exch 0.25 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.6 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  3.0  3.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial
29194 35074 a
tx@Dict begin  { -116.70027 -5.43561 } PutCoor PutBegin  end
 29194 35074 a 572 x Fo(x)29933 35845 y
Fk(1)29194 35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074 a
tx@Dict begin  { -62.88466 -5.43561 } PutCoor PutBegin  end
 29194
35074 a 572 x Fo(x)29933 35845 y Fk(2)29194 35074 y
tx@Dict begin  PutEnd  end
 29194
35074 a 29194 35074 a
tx@Dict begin  { -32.56592 -5.43561 } PutCoor PutBegin  end
 29194 35074 a 572 x Fo(x)29933
35845 y Fk(3)29194 35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074
a
tx@Dict begin  { 24.28181 -3.91997 } PutCoor PutBegin  end
 29194 35074 a 572 x Fo(x)29933 35845 y Fk(4)29194 35074
y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074 a
tx@Dict begin  { 80.3711 -3.91997 } PutCoor PutBegin  end
 29194 35074 a 572 x Fo(x)29933
35845 y Fk(5)29194 35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 29194 35074
a
tx@Dict begin  { -101.5409 284.1076 } PutCoor PutBegin  end
 29194 35074 a -172 x Fn(f)29744 34589 y Fg(0)29194
35074 y
tx@Dict begin  PutEnd  end
 29194 35074 a 51012 40878 a
currentpoint initclip moveto
 51012 40878 a 12165
40878 a
 currentpoint currentpoint translate 1 0.57887 div 1 0.57887 div scale
neg exch neg exch translate
 12165 40878 a 921 44862 a Fp(Kreuze)433 b(die)h(b)36
b(eiden)433 b(zutre\033enden)e(A)-36 b(ussagen)434 b(an!)p
1062 45829 44260 45 v 1062 50943 45 5114 v 1770 47748
a(Jede)386 b(F)-108 b(unktion)386 b Fo(f)528 b Fp(mit)386
b(der)f(Ableitungsfunktion)h Fo(f)27951 47266 y Fj(0)28648
47748 y Fp(hat)f(an)h(der)g(Stelle)g Fo(x)39096 47947
y Fk(5)40008 47748 y Fp(eine)1770 49740 y(horizon)-36
b(tale)434 b(T)-108 b(angen)-36 b(te.)p 42912 50943 V
45277 50943 V 1062 50987 44260 45 v 1062 56175 45 5188
v 1770 52906 a(Es)434 b(gibt)g(eine)f(F)-108 b(unktion)433
b Fo(f)576 b Fp(mit)433 b(der)g(Ableitungsfunktion)h
Fo(f)32435 52424 y Fj(0)32745 52906 y Fp(,)g(deren)f(Graph)1770
54898 y(durc)-36 b(h)433 b(den)f(Punkt)i Fo(P)550 b Fe(=)368
b(\(0)p Fo(=)p Fe(0\))434 b Fp(v)-36 b(erl\344uft.)p
42912 56175 V 1 0 0 TeXcolorrgb 43621 53913 a Fd(4)p
0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 45277
56175 V 1062 56219 44260 45 v 1062 61356 45 5137 v 1770
58160 a Fp(Jede)434 b(F)-108 b(unktion)433 b Fo(f)575
b Fp(mit)434 b(der)f(Ableitungsfunktion)g Fo(f)28236
57678 y Fj(0)28980 58160 y Fp(ist)h(im)g(In)-36 b(terv)-72
b(all)434 b Fe([)8 b Fo(x)38947 58359 y Fk(1)39473 58160
y Fe(;)221 b Fo(x)40794 58359 y Fk(2)41321 58160 y Fe(])1770
60152 y Fp(streng)434 b(monoton)f(fallend.)p 42912 61356
V 45277 61356 V 1062 61400 44260 45 v 1062 66536 45 5137
v 1770 63341 a(Jede)h(F)-108 b(unktion)433 b Fo(f)575
b Fp(mit)434 b(der)f(Ableitungsfunktion)g Fo(f)28236
62859 y Fj(0)28980 63341 y Fp(ist)h(im)g(In)-36 b(terv)-72
b(all)434 b Fe([)8 b Fo(x)38947 63540 y Fk(3)39473 63341
y Fe(;)221 b Fo(x)40794 63540 y Fk(4)41321 63341 y Fe(])1770
65333 y Fp(streng)434 b(monoton)f(steigend.)p 42912 66536
V 1 0 0 TeXcolorrgb 43621 64300 a Fd(4)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 45277 66536 V 1062 66580
44260 45 v 1062 71790 45 5211 v 1770 68521 a Fp(Die)i(F)-108
b(unktionsw)-36 b(erte)433 b Fo(f)142 b Fe(\()p Fo(x)p
Fe(\))433 b Fp(jeder)g(F)-108 b(unktion)433 b Fo(f)576
b Fp(mit)433 b(der)g(Ableitungsfunktion)1770 70513 y
Fo(f)2553 70031 y Fj(0)3298 70513 y Fp(sind)g(f\374r)g
Fo(x)369 b Fc(2)g Fe([)8 b Fo(x)11581 70712 y Fk(3)12107
70513 y Fe(;)221 b Fo(x)13428 70712 y Fk(5)13954 70513
y Fe(])434 b Fp(stets)f(p)36 b(ositiv.)p 42912 71790
V 45277 71790 V 1062 71835 44260 45 v 47992 10102 a Fm(___/1)p
1 0 0 TeXcolorrgb 47998 12094 a Fl(AN)369 b(3.2)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 75863
54804 45 v 0 TeXcolorgray 24746 81281 a Fp(3)p 0 TeXcolorgray
eop end
%%Page: 4 4
TeXDict begin 4 3 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)718 b(3.2)f(-)h(4)f(Gleic)-60
b(he)717 b(Ableitungsfunktion)712 b(-)718 b(O)-60 b(A)718
b(-)f(BIFIE)p 0 TeXcolorgray -741 4800 a Fp(4.)p 0 TeXcolorgray
651 w(In)433 b(der)g(un)-36 b(ten)433 b(stehenden)f(Abbildung)g(ist)i
(der)f(Graph)f(der)h(F)-108 b(unktion)433 b Fo(g)481
b Fp(dargestellt.)921 7346 y(Zeic)-36 b(hen)834 b(im)h(v)-36
b(orgegeb)36 b(enen)835 b(K)-36 b(o)36 b(ordinatensystem)835
b(den)f(Graphen)f(einer)h(F)-108 b(unktion)921 9338 y
Fo(f)363 b Fe(\()p Fo(f)511 b Fc(6)p Fe(=)369 b Fo(g)48
b Fe(\))432 b Fp(ein,)i(die)g(die)f(gleic)-36 b(he)435
b(Ableitungsfunktion)e(wie)h(die)g(F)-108 b(unktion)433
b(g)h(hat!)p 0 TeXcolorgray 0 TeXcolorgray 5417 52857
a
 currentpoint currentpoint translate 1.34435 1.34435 scale neg exch
neg exch translate
 5417 52857 a 5417 52857 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 241.8014 a add def
/d 0.0 a add neg def /h 262.69162 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 5417 52857 a 18785 47976
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 10
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 121.0392 0.0 -120.7622 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -113.81097 0.0 T 9
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 218.595 0.0 -44.09662   /Lineto /lineto load def 0 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 121.0392  0 -120.7622  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -120.7622
 121.0392  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-44.09662  def /maxTickline 218.595  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 218.595
0.0 -44.09662   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 121.0392
0.0 -120.7622 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 218.595  0 -44.09662  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -44.09662
 218.595  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-120.7622  def /maxTickline 121.0392  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 218.595
0.0 -44.09662   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 121.0392
0.0 -120.7622 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 17540 45112 a Fk(1)17540 41962
y(2)17540 38812 y(3)17540 35663 y(4)17540 32513 y(5)17540
29363 y(6)17540 26214 y(7)16808 51365 y Fj(\000)p Fk(1)21699
49321 y(1)2680 b(2)f(3)h(4)-16584 b Fj(\000)p Fk(1)-4351
b Fj(\000)p Fk(2)f Fj(\000)p Fk(3)g Fj(\000)p Fk(4)18785
47976 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 18785 47976 a 18785 47976 a
tx@Dict begin  { 121.0392 218.595 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 18785 47976 a 18785
47976 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 18785 47976 a 18442 48262 a Fp(x)18785 47976
y
tx@Dict begin  PutEnd  end
 18785 47976 a 18785 47976 a
tx@Dict begin  PutEnd  end
 18785 47976 a 18785 47976
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 18785 47976 a 18785 47976 a
tx@Dict begin  { 0.0 0.0 pop 121.0392 218.595 exch pop } PutCoor PutBegin
 end
 18785 47976 a 18785 47976
a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 18785 47976 a 17737 48308 a Fp(f\(x\))18785 47976 y
tx@Dict begin  PutEnd  end

18785 47976 a 18785 47976 a
tx@Dict begin  PutEnd  end
 18785 47976 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -4.2443125541125575 def /x1 4.254042424242424
def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)+2.0)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 1 0 0 TeXcolorrgb @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 1 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def    /x -4.2443125541125575
def /x1 4.254042424242424 def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)+3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 0 0 0 TeXcolorrgb 18785 47976
a
tx@Dict begin  { -66.4482 171.07028 } PutCoor PutBegin  end
 18785 47976 a -172 x Fn(f)18785 47976 y
tx@Dict begin  PutEnd  end
 18785 47976
a 1 0 0 TeXcolorrgb 0 TeXcolorgray 32183 52857 a
currentpoint initclip moveto
 32183
52857 a 5417 52857 a
 currentpoint currentpoint translate 1 1.34435 div 1 1.34435 div scale
neg exch neg exch translate
 5417 52857 a 1 0 0 TeXcolorrgb 921
58833 a Fp(Die)604 b(A)-36 b(ufgab)36 b(e)603 b(gilt)h(n)-36
b(ur)602 b(dann)h(als)h(ric)-36 b(h)g(tig)603 b(gel\366st,)h(w)-36
b(enn)603 b(der)g(Graph)f(v)-36 b(on)603 b Fo(f)745 b
Fp(erk)-36 b(enn-)921 60825 y(bar)484 b(durc)-36 b(h)483
b(eine)i(V)-108 b(ersc)-36 b(hiebung)483 b(in)i(Ric)-36
b(h)g(tung)484 b(der)g(y-A)-36 b(c)g(hse)484 b(aus)h(dem)f(Graphen)f(v)
-36 b(on)485 b Fo(g)921 62817 y Fp(en)-36 b(tsteh)g(t.)p
0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 47992
4800 a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 6792 a Fl(AN)369
b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
-2331 66293 54804 45 v 0 TeXcolorgray 24746 81281 a Fp(4)p
0 TeXcolorgray eop end
%%Page: 5 5
TeXDict begin 5 4 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)718 b(3.2)f(-)h(5)f(Stammfunktion)e
(erk)-60 b(ennen)715 b(-)j(MC)g(-)f(BIFIE)p 0 TeXcolorgray
-741 4800 a Fp(5.)p 0 TeXcolorgray 651 w(Gegeb)36 b(en)433
b(sind)g(die)h(F)-108 b(unktion)432 b Fo(f)576 b Fp(und)432
b Fo(g)481 b Fp(und)433 b(die)g(K)-36 b(onstan)g(te)433
b Fo(a)369 b Fc(2)g Fb(R)35741 4318 y Fk(+)36528 4800
y Fp(.)921 7346 y(Es)434 b(gilt)g(der)f(Zusammenhang)g
Fo(g)17305 6864 y Fj(0)17615 7346 y Fe(\()p Fo(x)p Fe(\))368
b(=)h Fo(f)21898 6864 y Fj(0)22209 7346 y Fe(\()p Fo(x)p
Fe(\))p Fp(.)921 9891 y(Kreuze)433 b(die)h(b)36 b(eiden)433
b(zutre\033enden)e(A)-36 b(ussagen)434 b(an!)p 10927
10858 24531 45 v 10927 13928 45 3071 v 11635 12725 a
Fo(f)576 b Fp(ist)433 b(eine)h(Stammfunktion)f(v)-36
b(on)434 b Fo(g)48 b Fp(.)p 33048 13928 V 35413 13928
V 10927 13973 24531 45 v 10927 17043 45 3071 v 11635
15840 a Fo(g)481 b Fp(ist)434 b(eine)g(Stammfunktion)f(v)-36
b(on)434 b Fo(f)142 b Fp(.)p 33048 17043 V 1 0 0 TeXcolorrgb
3679 w Fd(4)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
35413 17043 V 10927 17088 24531 45 v 10927 20158 45 3071
v 11635 18955 a Fo(g)343 b Fc(\000)295 b Fo(a)434 b Fp(ist)f(eine)h
(Stammfunktion)f(v)-36 b(on)434 b Fo(f)142 b Fp(.)p 33048
20158 V 1 0 0 TeXcolorrgb 1373 w Fd(4)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 35413 20158 V 10927
20202 24531 45 v 10927 23273 45 3071 v 11635 22070 a
Fo(f)437 b Fe(+)295 b Fo(a)433 b Fp(ist)h(eine)g(Stammfunktion)f(v)-36
b(on)434 b Fo(g)48 b Fp(.)p 33048 23273 V 35413 23273
V 10927 23317 24531 45 v 10927 26388 45 3071 v 11635
25184 a Fo(a)295 b Fc(\001)g Fo(g)481 b Fp(ist)434 b(eine)g
(Stammfunktion)f(v)-36 b(on)434 b Fo(f)142 b Fp(.)p 33048
26388 V 35413 26388 V 10927 26432 24531 45 v 47992 4800
a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 6792 a Fl(AN)369
b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
-2331 30460 54804 45 v -2331 35762 a Fq(AN)965 b(3.2)e(-)i(6)f(Eigensc)
-60 b(haften)962 b(der)i(Ableitungsfunktion)959 b(-)964
b(O)-60 b(A)965 b(-)-2331 38784 y(BIFIE)718 b(-)g(K)-60
b(omp)60 b(etenzc)-60 b(hec)g(k)717 b(2016)p 0 TeXcolorgray
-741 42091 a Fp(6.)p 0 TeXcolorgray 651 w(In)327 b(der)g(nac)-36
b(hstehenden)326 b(T)-108 b(ab)36 b(elle)328 b(sind)f(F)-108
b(unktionsw)-36 b(erte)327 b(einer)g(P)-36 b(olynomfunktion)329
b Fo(f)469 b Fp(drit-)921 44083 y(ten)433 b(Grades)g(so)-36
b(wie)434 b(ihrer)g(Ableitungsfunktionen)f Fo(f)27531
43601 y Fj(0)28275 44083 y Fp(und)f Fo(f)31659 43601
y Fj(00)32659 44083 y Fp(angegeb)36 b(en.)p 0 TeXcolorgray
0 TeXcolorgray 14576 46489 17667 45 v 14576 48481 45
1992 v 16464 47883 a Fo(x)p 19048 48481 V 3095 w Fp(0)p
22155 48481 V 2132 w(1)p 24611 48481 V 1806 w(2)p 27068
48481 V 1807 w(3)p 29524 48481 V 1915 w(4)p 32197 48481
V 14576 48525 17667 45 v 14576 50517 45 1992 v 15567
49919 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))p 19048 50517
V 1980 w Fp(-2)p 22155 50517 V 1915 w(2)p 24611 50517
V 1806 w(0)p 27068 50517 V 1590 w(-2)p 29524 50517 V
1698 w(2)p 32197 50517 V 14576 50561 17667 45 v 14576
52553 45 1992 v 15412 51956 a Fo(f)16195 51473 y Fj(0)16505
51956 y Fe(\()p Fo(x)p Fe(\))p 19048 52553 V 2042 w Fp(9)p
22155 52553 V 2132 w(0)p 24611 52553 V 1590 w(-3)p 27068
52553 V 1589 w(0)p 29524 52553 V 1915 w(9)p 32197 52553
V 14576 52597 17667 45 v 14576 54589 45 1992 v 15284
53992 a Fo(f)16067 53510 y Fj(00)16633 53992 y Fe(\()p
Fo(x)p Fe(\))p 19048 54589 V 1372 w Fp(-12)p 22155 54589
V 1373 w(-6)p 24611 54589 V 1589 w(0)p 27068 54589 V
1807 w(6)p 29524 54589 V 1590 w(12)p 32197 54589 V 14576
54634 17667 45 v 921 57733 a(Gib)453 b(an,)h(an)g(w)-36
b(elc)g(hen)453 b(Stellen)h(des)f(In)-36 b(terv)-72 b(alls)455
b Fe(\()o(0;)221 b(4\))455 b Fp(die)f(F)-108 b(unktion)453
b Fo(f)596 b Fp(jedenfalls)454 b(lokale)921 59725 y(Extremstellen)434
b(b)36 b(esitzt.)p 1 0 0 TeXcolorrgb 921 62270 a(Die)434
b(Stellen)g Fo(x)8290 62469 y Fk(1)9184 62270 y Fe(=)369
b(1)434 b Fp(und)e Fo(x)14989 62469 y Fk(2)15884 62270
y Fe(=)369 b(3)434 b Fp(sind)f(lokale)i(Extremstellen)f(der)f(F)-108
b(unktion)433 b Fo(f)142 b Fp(.)p 0 0 0 TeXcolorrgb 1 0 0
TeXcolorrgb 0 TeXcolorgray 47992 42091 a Fm(___/1)p 1 0 0
TeXcolorrgb 47998 44083 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 66004 54804 45
v 0 TeXcolorgray 24746 81281 a Fp(5)p 0 TeXcolorgray
eop end
%%Page: 6 6
TeXDict begin 6 5 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)951 b(3.2)g(-)g(7)g(F)-179
b(unktionen)948 b(und)h(Ableitungsfunktionen)c(-)952
b(ZO)f(-)-2331 4515 y(Matura)717 b(2015/16)g(-)h(Haupttermin)p
0 TeXcolorgray -741 7823 a Fp(7.)p 0 TeXcolorgray 651
w(Links)536 b(sind)f(die)h(Graphen)e(v)-36 b(on)536 b(vier)g(P)-36
b(olynomfunktionen)537 b Fe(\()p Fo(f)33047 8022 y Fk(1)33572
7823 y Fo(;)221 b(f)34795 8022 y Fk(2)35322 7823 y Fo(;)g(f)36545
8022 y Fk(3)37072 7823 y Fo(;)g(f)38295 8022 y Fk(4)38821
7823 y Fe(\))536 b Fp(abgebildet,)921 9815 y(rec)-36
b(h)g(ts)433 b(die)g(Graphen)f(sec)-36 b(hs)434 b(w)-36
b(eiterer)433 b(F)-108 b(unktionen)433 b Fe(\()p Fo(g)28365
10014 y Fk(1)28890 9815 y Fo(;)221 b(g)30095 10014 y
Fk(2)30621 9815 y Fo(;)g(g)31826 10014 y Fk(3)32353 9815
y Fo(;)g(g)33558 10014 y Fk(4)34084 9815 y Fo(;)g(g)35289
10014 y Fk(5)35815 9815 y Fo(;)g(g)37020 10014 y Fk(6)37547
9815 y Fe(\))p Fp(.)921 12360 y(Ordnen)465 b(Sie)i(den)g(P)-36
b(olynomfunktionen)468 b Fo(f)22453 12559 y Fk(1)23445
12360 y Fp(bis)f Fo(f)26150 12559 y Fk(4)27143 12360
y Fp(ihre)g(jew)-36 b(eilige)469 b(Ableitungsfunktion)921
14352 y(aus)434 b(den)e(F)-108 b(unktionen)433 b Fo(g)13167
14551 y Fk(1)14126 14352 y Fp(bis)h Fo(g)16780 14551
y Fk(6)17739 14352 y Fp(\(aus)f(A)h(bis)f(F\))g(zu.)p
0 TeXcolorgray 0 TeXcolorgray 7122 16022 9222 45 v 16344
16022 4523 45 v 7122 28762 45 12740 v 7831 27817 a
 currentpoint currentpoint translate 0.43938 0.43938 scale neg exch
neg exch translate
 7831
27817 a 7831 27817 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 7831 27817 a 16146 23659 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
14901 20795 a Fk(1)14900 17645 y(2)14900 14496 y(3)14900
11346 y(4)14900 8197 y(5)14900 5047 y(6)14169 27048 y
Fj(\000)p Fk(1)19060 25005 y(1)2680 b(2)-10285 b Fj(\000)p
Fk(1)-4352 b Fj(\000)p Fk(2)16146 23659 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 16146 23659
a 16146 23659 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 16146 23659 a 16146 23659 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 16146 23659
a 15776 23945 a Fo(x)16146 23659 y
tx@Dict begin  PutEnd  end
 16146 23659 a 16146
23659 a
tx@Dict begin  PutEnd  end
 16146 23659 a 16146 23659 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 16146 23659 a 16146
23659 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 16146 23659 a 16146 23659 a
tx@Dict begin  { 5.0 26.35733 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 16146 23659 a 14687
23991 a Fo(f)15328 24190 y Fk(1)15854 23991 y Fe(\()p
Fo(x)p Fe(\))16146 23659 y
tx@Dict begin  PutEnd  end
 16146 23659 a 16146 23659
a
tx@Dict begin  PutEnd  end
 16146 23659 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (x^(2.0)+1.0)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
16146 23659 a
tx@Dict begin  { -52.35294 152.50671 } PutCoor PutBegin  end
 16146 23659 a -172 x Fn(f)16598 23610 y
Fh(1)16146 23659 y
tx@Dict begin  PutEnd  end
 16146 23659 a 25595 27817 a
currentpoint initclip moveto
 25595
27817 a 7831 27817 a
 currentpoint currentpoint translate 1 0.43938 div 1 0.43938 div scale
neg exch neg exch translate
 7831 27817 a 16300 28762 45 12740
v 0.9 TeXcolorgray 16344 28762 4478 12740 v 0 TeXcolorgray
1 0 0 TeXcolorrgb 18141 22850 a Fp(E)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 20822 28762 45 12740
v 7122 28806 9222 45 v 16344 28806 4523 45 v 7122 42463
45 13658 v 7831 41518 a
 currentpoint currentpoint translate 0.47655 0.47655 scale neg exch
neg exch translate
 7831 41518 a 7831 41518 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 147.95416 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 7831
41518 a 16146 37361 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 72.83894 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 72.83894  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 72.83894  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 72.83894
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 72.83894  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 72.83894
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 14901 34496 a
Fk(1)14900 31347 y(2)14900 28197 y(3)14900 25048 y(4)14900
21898 y(5)14900 18748 y(6)14169 40749 y Fj(\000)p Fk(1)19060
38706 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)16146 37361 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 16146 37361 a 16146 37361 a
tx@Dict begin  { 72.83894 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 16146
37361 a 16146 37361 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 16146 37361 a 15776 37647 a Fo(x)16146
37361 y
tx@Dict begin  PutEnd  end
 16146 37361 a 16146 37361 a
tx@Dict begin  PutEnd  end
 16146 37361 a 16146
37361 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 16146 37361 a 16146 37361 a
tx@Dict begin  { 0.0 0.0 pop 72.83894 185.51201 exch pop } PutCoor
PutBegin  end
 16146 37361 a 16146
37361 a
tx@Dict begin  { 5.0 26.35733 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 16146 37361 a 14687 37693 a Fo(f)15328 37892
y Fk(2)15854 37693 y Fe(\()p Fo(x)p Fe(\))16146 37361
y
tx@Dict begin  PutEnd  end
 16146 37361 a 16146 37361 a
tx@Dict begin  PutEnd  end
 16146 37361 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (x^(3.0)+x+3.0)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 16146 37361 a
tx@Dict begin  { 36.98865 152.50671 } PutCoor PutBegin  end
 16146 37361 a
-172 x Fn(f)16598 37312 y Fh(2)16146 37361 y
tx@Dict begin  PutEnd  end
 16146 37361
a 24209 41518 a
currentpoint initclip moveto
 24209 41518 a 7831 41518 a
 currentpoint currentpoint translate 1 0.47655 div 1 0.47655 div scale
neg exch neg exch translate
 7831 41518
a 16300 42463 45 13658 v 0.9 TeXcolorgray 16344 42463
4478 13658 v 0 TeXcolorgray 1 0 0 TeXcolorrgb 18072 36092
a Fp(A)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
20822 42463 45 13658 v 7122 42507 9222 45 v 16344 42507
4523 45 v 7122 55247 45 12740 v 7831 54302 a
 currentpoint currentpoint translate 0.43938 0.43938 scale neg exch
neg exch translate
 7831 54302
a 7831 54302 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 7831 54302 a 16146 50144 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
14901 47280 a Fk(1)14900 44130 y(2)14900 40981 y(3)14900
37831 y(4)14900 34681 y(5)14900 31532 y(6)14169 53533
y Fj(\000)p Fk(1)19060 51490 y(1)2680 b(2)-10285 b Fj(\000)p
Fk(1)-4352 b Fj(\000)p Fk(2)16146 50144 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 16146 50144
a 16146 50144 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 16146 50144 a 16146 50144 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 16146 50144
a 15776 50430 a Fo(x)16146 50144 y
tx@Dict begin  PutEnd  end
 16146 50144 a 16146
50144 a
tx@Dict begin  PutEnd  end
 16146 50144 a 16146 50144 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 16146 50144 a 16146
50144 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 16146 50144 a 16146 50144 a
tx@Dict begin  { 5.0 26.35733 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 16146 50144 a 14687
50476 a Fo(f)15328 50675 y Fk(3)15854 50476 y Fe(\()p
Fo(x)p Fe(\))16146 50144 y
tx@Dict begin  PutEnd  end
 16146 50144 a 16146 50144
a
tx@Dict begin  PutEnd  end
 16146 50144 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (x^4-2*x^2+2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
16146 50144 a
tx@Dict begin  { -48.36957 152.50671 } PutCoor PutBegin  end
 16146 50144 a -172 x Fn(f)16598 50095 y
Fh(3)16146 50144 y
tx@Dict begin  PutEnd  end
 16146 50144 a 25595 54302 a
currentpoint initclip moveto
 25595
54302 a 7831 54302 a
 currentpoint currentpoint translate 1 0.43938 div 1 0.43938 div scale
neg exch neg exch translate
 7831 54302 a 16300 55247 45 12740
v 0.9 TeXcolorgray 16344 55247 4478 12740 v 0 TeXcolorgray
1 0 0 TeXcolorrgb 18159 49334 a Fp(F)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 20822 55247 45 12740
v 7122 55291 9222 45 v 16344 55291 4523 45 v 7122 68030
45 12740 v 7831 67085 a
 currentpoint currentpoint translate 0.43938 0.43938 scale neg exch
neg exch translate
 7831 67085 a 7831 67085 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 7831
67085 a 16146 62928 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 14901 60063 a
Fk(1)14900 56914 y(2)14900 53764 y(3)14900 50615 y(4)14900
47465 y(5)14900 44315 y(6)14169 66317 y Fj(\000)p Fk(1)19060
64273 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)16146 62928 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 16146 62928 a 16146 62928 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 16146
62928 a 16146 62928 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 16146 62928 a 15776 63214 a Fo(x)16146
62928 y
tx@Dict begin  PutEnd  end
 16146 62928 a 16146 62928 a
tx@Dict begin  PutEnd  end
 16146 62928 a 16146
62928 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 16146 62928 a 16146 62928 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 16146 62928 a 16146
62928 a
tx@Dict begin  { 5.0 26.35733 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 16146 62928 a 14687 63260 a Fo(f)15328 63459
y Fk(4)15854 63260 y Fe(\()p Fo(x)p Fe(\))16146 62928
y
tx@Dict begin  PutEnd  end
 16146 62928 a 16146 62928 a
tx@Dict begin  PutEnd  end
 16146 62928 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (-x^(3.0)+3*x^2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 16146 62928 a
tx@Dict begin  { -48.36957 152.50671 } PutCoor PutBegin  end
 16146 62928 a
-172 x Fn(f)16598 62879 y Fh(4)16146 62928 y
tx@Dict begin  PutEnd  end
 16146 62928
a 25595 67085 a
currentpoint initclip moveto
 25595 67085 a 7831 67085 a
 currentpoint currentpoint translate 1 0.43938 div 1 0.43938 div scale
neg exch neg exch translate
 7831 67085
a 16300 68030 45 12740 v 0.9 TeXcolorgray 16344 68030
4478 12740 v 0 TeXcolorgray 1 0 0 TeXcolorrgb 18087 62118
a Fp(D)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
20822 68030 45 12740 v 7122 68074 9222 45 v 16344 68074
4523 45 v 0 TeXcolorgray 0 TeXcolorgray 26153 16022 4567
45 v 30720 16022 6528 45 v 26153 25077 45 9056 v 0.92
TeXcolorgray 26197 25077 4478 9056 v 0 TeXcolorgray 27925
21007 a(A)p 30675 25077 45 9056 v 31384 24133 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384
24133 a 31384 24133 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 24133 a 39699 19975 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
38454 17111 a Fk(1)38453 13961 y(2)38453 10812 y(3)38453
7662 y(4)38453 4512 y(5)38453 1363 y(6)37722 23364 y
Fj(\000)p Fk(1)42613 21321 y(1)2680 b(2)-10285 b Fj(\000)p
Fk(1)-4352 b Fj(\000)p Fk(2)39699 19975 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 19975
a 39699 19975 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699 19975 a 39699 19975 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 19975
a 39329 20261 a Fo(x)39699 19975 y
tx@Dict begin  PutEnd  end
 39699 19975 a 39699
19975 a
tx@Dict begin  PutEnd  end
 39699 19975 a 39699 19975 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 19975 a 39699
19975 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 19975 a 39699 19975 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 19975 a 38249
20307 a Fo(g)38872 20506 y Fk(1)39398 20307 y Fe(\()p
Fo(x)p Fe(\))39699 19975 y
tx@Dict begin  PutEnd  end
 39699 19975 a 39699 19975
a
tx@Dict begin  PutEnd  end
 39699 19975 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (3*x^(2.0)+1)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
39699 19975 a
tx@Dict begin  { -48.36957 152.50671 } PutCoor PutBegin  end
 39699 19975 a -172 x Fn(g)40147 19926 y
Fh(1)39699 19975 y
tx@Dict begin  PutEnd  end
 39699 19975 a 49147 24133 a
currentpoint initclip moveto
 49147
24133 a 31384 24133 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 24133 a 37203 25077 45 9056
v 26153 25122 4567 45 v 30720 25122 6528 45 v 26153 34177
45 9056 v 0.92 TeXcolorgray 26197 34177 4478 9056 v 0
TeXcolorgray 27976 30106 a Fp(B)p 30675 34177 45 9056
v 31384 33232 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384 33232 a 31384 33232 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 33232
a 39699 29074 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 38454 26210 a
Fk(1)38453 23061 y(2)38453 19911 y(3)38453 16761 y(4)38453
13612 y(5)38453 10462 y(6)37722 32463 y Fj(\000)p Fk(1)42613
30420 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)39699 29074 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 29074 a 39699 29074 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699
29074 a 39699 29074 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 29074 a 39329 29360 a Fo(x)39699
29074 y
tx@Dict begin  PutEnd  end
 39699 29074 a 39699 29074 a
tx@Dict begin  PutEnd  end
 39699 29074 a 39699
29074 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 29074 a 39699 29074 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 29074 a 39699
29074 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 29074 a 38249 29406 a Fo(g)38872 29605
y Fk(2)39398 29406 y Fe(\()p Fo(x)p Fe(\))39699 29074
y
tx@Dict begin  PutEnd  end
 39699 29074 a 39699 29074 a
tx@Dict begin  PutEnd  end
 39699 29074 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (-3*x^(2.0)+6*x+2)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial 39699 29074 a
tx@Dict begin  { 45.52455 128.03734 } PutCoor PutBegin  end
 39699 29074 a
-172 x Fn(g)40147 29025 y Fh(2)39699 29074 y
tx@Dict begin  PutEnd  end
 39699 29074
a 49147 33232 a
currentpoint initclip moveto
 49147 33232 a 31384 33232 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 33232
a 37203 34177 45 9056 v 26153 34221 4567 45 v 30720 34221
6528 45 v 26153 43715 45 9494 v 0.92 TeXcolorgray 26197
43715 4478 9494 v 0 TeXcolorgray 27967 39425 a Fp(C)p
30675 43715 45 9494 v 31384 42770 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384 42770 a 31384
42770 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 236.72702 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 42770 a 39699 37101 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -51.21501   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-51.21501  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -51.21501   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -51.21501  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -51.21501
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -51.21501   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 38454 34236 a
Fk(1)38453 31087 y(2)38453 27937 y(3)38453 24788 y(4)38453
21638 y(5)38453 18488 y(6)37722 40489 y Fj(\000)p Fk(1)42613
38446 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)39699 37101 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 37101 a 39699 37101 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699
37101 a 39699 37101 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 37101 a 39329 37387 a Fo(x)39699
37101 y
tx@Dict begin  PutEnd  end
 39699 37101 a 39699 37101 a
tx@Dict begin  PutEnd  end
 39699 37101 a 39699
37101 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 37101 a 39699 37101 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 37101 a 39699
37101 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 37101 a 38249 37433 a Fo(g)38872 37632
y Fk(3)39398 37433 y Fe(\()p Fo(x)p Fe(\))39699 37101
y
tx@Dict begin  PutEnd  end
 39699 37101 a 39699 37101 a
tx@Dict begin  PutEnd  end
 39699 37101 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (-4*x^3+4*x)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 39699 37101 a
tx@Dict begin  { -52.35294 152.50671 } PutCoor PutBegin  end
 39699 37101 a
-172 x Fn(g)40147 37052 y Fh(3)39699 37101 y
tx@Dict begin  PutEnd  end
 39699 37101
a 49147 42770 a
currentpoint initclip moveto
 49147 42770 a 31384 42770 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 42770
a 37203 43715 45 9494 v 26153 43759 4567 45 v 30720 43759
6528 45 v 26153 52814 45 9056 v 0.92 TeXcolorgray 26197
52814 4478 9056 v 0 TeXcolorgray 27940 48744 a Fp(D)p
30675 52814 45 9056 v 31384 51869 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384 51869 a 31384
51869 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 51869 a 39699 47712 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 38454 44847 a
Fk(1)38453 41698 y(2)38453 38548 y(3)38453 35399 y(4)38453
32249 y(5)38453 29099 y(6)37722 51101 y Fj(\000)p Fk(1)42613
49057 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)39699 47712 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 47712 a 39699 47712 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699
47712 a 39699 47712 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 47712 a 39329 47998 a Fo(x)39699
47712 y
tx@Dict begin  PutEnd  end
 39699 47712 a 39699 47712 a
tx@Dict begin  PutEnd  end
 39699 47712 a 39699
47712 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 47712 a 39699 47712 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 47712 a 39699
47712 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 47712 a 38249 48044 a Fo(g)38872 48243
y Fk(4)39398 48044 y Fe(\()p Fo(x)p Fe(\))39699 47712
y
tx@Dict begin  PutEnd  end
 39699 47712 a 39699 47712 a
tx@Dict begin  PutEnd  end
 39699 47712 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (-3*x^(2.0)+6*x)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 39699 47712 a
tx@Dict begin  { 42.67911 73.9773 } PutCoor PutBegin  end
 39699 47712 a
-172 x Fn(g)40147 47663 y Fh(4)39699 47712 y
tx@Dict begin  PutEnd  end
 39699 47712
a 49147 51869 a
currentpoint initclip moveto
 49147 51869 a 31384 51869 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 51869
a 37203 52814 45 9056 v 26153 52858 4567 45 v 30720 52858
6528 45 v 26153 61913 45 9056 v 0.92 TeXcolorgray 26197
61913 4478 9056 v 0 TeXcolorgray 27994 57843 a Fp(E)p
30675 61913 45 9056 v 31384 60969 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384 60969 a 31384
60969 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 223.06982 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 60969 a 39699 56811 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -37.55782   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-37.55782  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -37.55782  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -37.55782
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -37.55782   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 38454 53947 a
Fk(1)38453 50797 y(2)38453 47648 y(3)38453 44498 y(4)38453
41348 y(5)38453 38199 y(6)37722 60200 y Fj(\000)p Fk(1)42613
58157 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)39699 56811 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 56811 a 39699 56811 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699
56811 a 39699 56811 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 56811 a 39329 57097 a Fo(x)39699
56811 y
tx@Dict begin  PutEnd  end
 39699 56811 a 39699 56811 a
tx@Dict begin  PutEnd  end
 39699 56811 a 39699
56811 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 56811 a 39699 56811 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 56811 a 39699
56811 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 56811 a 38249 57143 a Fo(g)38872 57342
y Fk(5)39398 57143 y Fe(\()p Fo(x)p Fe(\))39699 56811
y
tx@Dict begin  PutEnd  end
 39699 56811 a 39699 56811 a
tx@Dict begin  PutEnd  end
 39699 56811 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (2*x)  tx@AlgToPs begin AlgToPs
end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def  /ps@Exit
false def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 28.45274
mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto } { L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt {
moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 39699 56811 a
tx@Dict begin  { 42.67911 67.14848 } PutCoor PutBegin  end
 39699 56811 a
-172 x Fn(g)40147 56762 y Fh(5)39699 56811 y
tx@Dict begin  PutEnd  end
 39699 56811
a 49147 60969 a
currentpoint initclip moveto
 49147 60969 a 31384 60969 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 60969
a 37203 61913 45 9056 v 26153 61958 4567 45 v 30720 61958
6528 45 v 26153 71452 45 9494 v 0.92 TeXcolorgray 26197
71452 4478 9494 v 0 TeXcolorgray 28012 67162 a Fp(F)p
30675 71452 45 9494 v 31384 70507 a
 currentpoint currentpoint translate 0.29018 0.29018 scale neg exch
neg exch translate
 31384 70507 a 31384
70507 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 160.47345 a add def
/d 0.0 a add neg def /h 236.72702 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 31384 70507 a 39699 64837 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 85.35823 0.0 -75.11522 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -56.90549 0.0 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 185.51201 0.0 -51.21501   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 85.35823  0 -75.11522  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -75.11522
 85.35823  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-51.21501  def /maxTickline 185.51201  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -51.21501   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 185.51201  0 -51.21501  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -51.21501
 185.51201  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-75.11522  def /maxTickline 85.35823  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 185.51201
0.0 -51.21501   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 85.35823
0.0 -75.11522 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 38454 61973 a
Fk(1)38453 58823 y(2)38453 55674 y(3)38453 52524 y(4)38453
49375 y(5)38453 46225 y(6)37722 68226 y Fj(\000)p Fk(1)42613
66183 y(1)2680 b(2)-10285 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)39699 64837 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 39699 64837 a 39699 64837 a
tx@Dict begin  { 85.35823 185.51201 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 39699
64837 a 39699 64837 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 39699 64837 a 39329 65123 a Fo(x)39699
64837 y
tx@Dict begin  PutEnd  end
 39699 64837 a 39699 64837 a
tx@Dict begin  PutEnd  end
 39699 64837 a 39699
64837 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 39699 64837 a 39699 64837 a
tx@Dict begin  { 0.0 0.0 pop 85.35823 185.51201 exch pop } PutCoor
PutBegin  end
 39699 64837 a 39699
64837 a
tx@Dict begin  { 5.0 26.19203 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 39699 64837 a 38249 65169 a Fo(g)38872 65368
y Fk(6)39398 65169 y Fe(\()p Fo(x)p Fe(\))39699 64837
y
tx@Dict begin  PutEnd  end
 39699 64837 a 39699 64837 a
tx@Dict begin  PutEnd  end
 39699 64837 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -2.640000000000001 def /x1 3 def
/dx x1 x sub 199 div def /F@pstplot (4*x^3-4*x)  tx@AlgToPs begin AlgToPs
end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def  /ps@Exit
false def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 28.45274
mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto } { L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt {
moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW 0  setgray  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 39699 64837 a
tx@Dict begin  { 42.67911 71.13185 } PutCoor PutBegin  end
 39699 64837 a
-172 x Fn(g)40147 64788 y Fh(6)39699 64837 y
tx@Dict begin  PutEnd  end
 39699 64837
a 49147 70507 a
currentpoint initclip moveto
 49147 70507 a 31384 70507 a
 currentpoint currentpoint translate 1 0.29018 div 1 0.29018 div scale
neg exch neg exch translate
 31384 70507
a 37203 71452 45 9494 v 26153 71496 4567 45 v 30720 71496
6528 45 v 47992 7823 a Fm(___/1)p 1 0 0 TeXcolorrgb 47998
9815 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray -2331 77863 54804 45 v 0 TeXcolorgray
24746 81281 a Fp(6)p 0 TeXcolorgray eop end
%%Page: 7 7
TeXDict begin 7 6 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)837 b(3.2)g(-)g(8)g(Zusammenhang)e
(zwisc)-60 b(hen)837 b(F)-179 b(unktion)834 b(und)i(Ablei-)-2331
4515 y(tungsfunktion)714 b(-)j(L)-179 b(T)717 b(-)g(Matura)h(2014/15)f
(-)g(Haupttermin)p 0 TeXcolorgray -741 7823 a Fp(8.)p
0 TeXcolorgray 651 w(In)433 b(der)g(folgenden)h(Abbildung)f(ist)h(der)f
(Graph)f(einer)i(P)-36 b(olynomfunktion)434 b Fo(f)576
b Fp(dargestellt:)p 0 TeXcolorgray 0 TeXcolorgray 11040
37833 a
 currentpoint currentpoint translate 1.09457 1.09457 scale neg exch
neg exch translate
 11040 37833 a 11474 37833 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 196.32419 a add def
/d 0.0 a add neg def /h 228.19067 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 11474 37833 a 22120
26872 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -85.35823 T 9 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 100.15378 0.0 -96.17041 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 7 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 129.17526 0.0 -99.01541   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 100.15378  0 -96.17041  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -96.17041
 100.15378  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-99.01541  def /maxTickline 129.17526  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 129.17526
0.0 -99.01541   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 100.15378
0.0 -96.17041 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 129.17526  0 -99.01541  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -99.01541
 129.17526  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-96.17041  def /maxTickline 100.15378  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 129.17526
0.0 -99.01541   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 100.15378
0.0 -96.17041 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 20875 24008 a Fk(1)20874 20858
y(2)20874 17709 y(3)20874 14559 y(4)20142 30261 y Fj(\000)p
Fk(1)20142 33411 y Fj(\000)p Fk(2)20142 36560 y Fj(\000)p
Fk(3)25034 28218 y(1)2679 b(2)h(3)-13434 b Fj(\000)p
Fk(1)-4352 b Fj(\000)p Fk(2)h Fj(\000)p Fk(3)22120 26872
y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 22120 26872 a 22120 26872 a
tx@Dict begin  { 100.15378 129.17526 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 22120 26872 a 22120 26872
a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 22120 26872 a 21750 27158 a Fo(x)22120 26872 y
tx@Dict begin  PutEnd  end
 22120
26872 a 22120 26872 a
tx@Dict begin  PutEnd  end
 22120 26872 a 22120 26872 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 22120
26872 a 22120 26872 a
tx@Dict begin  { 0.0 0.0 pop 100.15378 129.17526 exch pop } PutCoor
PutBegin  end
 22120 26872 a 22120 26872 a
tx@Dict begin  { 5.0 22.88857 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 22120
26872 a 20853 27204 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))22120
26872 y
tx@Dict begin  PutEnd  end
 22120 26872 a 22120 26872 a
tx@Dict begin  PutEnd  end
 22120 26872 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.3799999999999994 def /x1 3.519999999999997
def /dx x1 x sub 199 div def /F@pstplot (-x^(3.0)+4.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial 22120 26872 a
tx@Dict begin  { -63.7343 120.63979 } PutCoor PutBegin  end
 22120 26872 a
-172 x Fn(f)22120 26872 y
tx@Dict begin  PutEnd  end
 22120 26872 a 33206 37833 a
currentpoint initclip moveto

33206 37833 a 11040 37833 a
 currentpoint currentpoint translate 1 1.09457 div 1 1.09457 div scale
neg exch neg exch translate
 11040 37833 a 921 43809 a
Fp(Erg\344nze)358 b(die)h(T)-108 b(extl\374c)-36 b(k)g(en)358
b(im)g(folgenden)h(Satz)f(durc)-36 b(h)357 b(Ankreuzen)g(der)h(jew)-36
b(eils)360 b(ric)-36 b(h)g(tigen)921 45801 y(Satzteile)434
b(so,)g(dass)g(eine)f(mathematisc)-36 b(h)434 b(k)-36
b(orrekte)434 b(A)-36 b(ussage)434 b(en)-36 b(tsteh)g(t!)921
49291 y(Die)776 b(erste)f(Ableitung)h(der)f(F)-108 b(unktion)774
b Fo(f)918 b Fp(ist)p 25861 49291 3150 45 v 29483 49243
a(1)29011 49291 y Fa(\015)p 30605 49291 V 3925 w Fp(,)776
b(und)e(daraus)i(folgt:)p 921 51283 V 4542 51235 a(2)4071
51283 y Fa(\015)p 5665 51283 V 3583 w Fp(.)p 0 TeXcolorgray
0 TeXcolorgray 1664 52656 19496 45 v 1664 55740 45 3085
v 11087 54437 a(1)10615 54485 y Fa(\015)p 21115 55740
V 1664 55784 19496 45 v 1664 59117 45 3334 v 2372 57840
a Fp(im)434 b(In)-36 b(terv)-72 b(all)434 b Fe([)8 b
Fc(\000)p Fe(1;)221 b(1])436 b Fp(negativ)p 18750 59117
V 19459 57783 a Fd(2)p 21115 59117 V 1664 59162 19496
45 v 1664 64298 45 5137 v 2372 61103 a Fp(im)e(In)-36
b(terv)-72 b(all)434 b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])436
b Fp(gleic)-36 b(h)2372 63095 y(n)g(ull)p 18750 64298
V 19459 62062 a Fd(2)p 21115 64298 V 1664 64342 19496
45 v 1664 67675 45 3334 v 2372 66398 a Fp(im)434 b(In)-36
b(terv)-72 b(all)434 b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])436
b Fp(p)36 b(ositiv)p 18750 67675 V 1 0 0 TeXcolorrgb
19459 66341 a Fd(4)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray 21115 67675 V 1664 67719 19496 45 v 0
TeXcolorgray 0 TeXcolorgray 25658 52766 19974 45 v 25658
55851 45 3085 v 35319 54548 a Fp(2)34847 54596 y Fa(\015)p
45586 55851 V 25658 55895 19974 45 v 25658 61031 45 5137
v 26366 57836 a Fo(f)435 b Fp(hat)293 b(im)g(In)-36 b(terv)-72
b(all)293 b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])295 b Fp(eine)26366
59828 y(Nullstelle)p 43221 61031 V 43930 58795 a Fd(2)p
45586 61031 V 25658 61075 19974 45 v 25658 66212 45 5137
v 26366 63017 a Fo(f)635 b Fp(ist)494 b(im)f(In)-36 b(terv)-72
b(all)494 b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])26366 65008
y Fp(streng)433 b(monoton)h(steigend)p 43221 66212 V
1 0 0 TeXcolorrgb 43930 63976 a Fd(4)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 45586 66212 V 25658
66256 19974 45 v 25658 71392 45 5137 v 26366 68197 a
Fo(f)h Fp(hat)293 b(im)g(In)-36 b(terv)-72 b(all)293
b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])295 b Fp(eine)26366
70189 y(W)-108 b(endestelle)p 43221 71392 V 43930 69156
a Fd(2)p 45586 71392 V 25658 71436 19974 45 v 47992 7823
a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 9815 a Fl(AN)369
b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
-2331 75465 54804 45 v 0 TeXcolorgray 24746 81281 a Fp(7)p
0 TeXcolorgray eop end
%%Page: 8 8
TeXDict begin 8 7 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 a Fq(AN)590 b(3.2)g(-)g(9)g(Stammfunktion)d
(einer)i(k)-60 b(onstan)g(ten)589 b(F)-179 b(unktion)587
b(-)j(O)-60 b(A)-2617 4515 y(-)718 b(Matura)f(2014/15)g(-)g(Neb)60
b(en)-60 b(termin)716 b(1)p 0 TeXcolorgray -741 7823
a Fp(9.)p 0 TeXcolorgray 651 w(In)610 b(der)f(nac)-36
b(hstehenden)608 b(Abbildung)h(ist)i(der)e(Graph)g(einer)h(k)-36
b(onstan)g(ten)609 b(F)-108 b(unktion)609 b Fo(f)921
9815 y Fp(dargestellt.)p 0 TeXcolorgray 0 TeXcolorgray
12165 34325 a
 currentpoint currentpoint translate 0.78137 0.78137 scale neg exch
neg exch translate
 12165 34325 a 12598 34325 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 256.07468 a add def
/d 0.0 a add neg def /h 256.07468 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 12598 34325
a 26771 20152 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 10
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 128.03734 0.0 -128.03734 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -113.81097 0.0 T 10
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 128.03734 0.0 -128.03734   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 128.03734  0 -128.03734  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -128.03734
 128.03734  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-128.03734  def /maxTickline 128.03734  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 128.03734
0.0 -128.03734   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 128.03734
0.0 -128.03734 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 128.03734  0 -128.03734  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -128.03734
 128.03734  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-128.03734  def /maxTickline 128.03734  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 128.03734
0.0 -128.03734   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 128.03734
0.0 -128.03734 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 25526 17288 a
Fk(1)25526 14138 y(2)25526 10989 y(3)25526 7839 y(4)24794
23541 y Fj(\000)p Fk(1)24794 26690 y Fj(\000)p Fk(2)24794
29840 y Fj(\000)p Fk(3)24794 32990 y Fj(\000)p Fk(4)29686
21498 y(1)2679 b(2)h(3)g(4)-16584 b Fj(\000)p Fk(1)-4352
b Fj(\000)p Fk(2)h Fj(\000)p Fk(3)f Fj(\000)p Fk(4)26771
20152 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 26771 20152 a 26771 20152 a
tx@Dict begin  { 128.03734 128.03734 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 26771 20152 a 26771
20152 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 26771 20152 a 26401 20438 a Fo(x)26771 20152
y
tx@Dict begin  PutEnd  end
 26771 20152 a 26771 20152 a
tx@Dict begin  PutEnd  end
 26771 20152 a 26771 20152
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 26771 20152 a 26771 20152 a
tx@Dict begin  { 0.0 0.0 pop 128.03734 128.03734 exch pop } PutCoor
PutBegin  end
 26771 20152 a 26771 20152
a
tx@Dict begin  { 5.0 22.88857 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 26771 20152 a 25504 20484 a Fo(f)142 b Fe(\()p Fo(x)p
Fe(\))26771 20152 y
tx@Dict begin  PutEnd  end
 26771 20152 a 26771 20152 a
tx@Dict begin  PutEnd  end
 26771
20152 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -4.5 def /x1 4.5 def /dx x1 x sub
49 div def /F@pstplot ((-2.-0.*x)/1.)  tx@AlgToPs begin AlgToPs end
cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def  /ps@Exit
false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30 28.45274
mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto } { L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt {
moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 26771
20152 a
tx@Dict begin  { 86.87428 -42.67911 } PutCoor PutBegin  end
 26771 20152 a 922 x Fo(f)26771 20152 y
tx@Dict begin  PutEnd  end
 26771
20152 a 40945 34325 a
currentpoint initclip moveto
 40945 34325 a 12165 34325 a
 currentpoint currentpoint translate 1 0.78137 div 1 0.78137 div scale
neg exch neg exch translate
 12165
34325 a 921 40302 a Fp(Der)463 b(Graph)f(einer)h(Stammfunktion)g
Fo(F)644 b Fp(v)-36 b(on)463 b Fo(f)605 b Fp(v)-36 b(erl\344uft)464
b(durc)-36 b(h)461 b(den)i(Punkt)f Fo(P)600 b Fe(=)419
b(\(1)p Fc(j)p Fe(1\))p Fp(.)921 42293 y(Zeic)-36 b(hne)418
b(den)g(Graphen)f(der)h(Stammfunktion)h Fo(F)599 b Fp(im)419
b(nac)-36 b(hstehenden)416 b(K)-36 b(o)36 b(ordinatensys-)921
44285 y(tem.)p 0 TeXcolorgray 0 TeXcolorgray 12165 68538
a
 currentpoint currentpoint translate 0.78137 0.78137 scale neg exch
neg exch translate
 12165 68538 a 12598 68538 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 256.07468 a add def
/d 0.0 a add neg def /h 256.07468 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 12598 68538 a 26771 54365
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 10
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 128.03734 0.0 -128.03734 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -113.81097 0.0 T 10
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 128.03734 0.0 -128.03734   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 128.03734  0 -128.03734  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -128.03734
 128.03734  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-128.03734  def /maxTickline 128.03734  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 128.03734
0.0 -128.03734   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 128.03734
0.0 -128.03734 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 128.03734  0 -128.03734  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -128.03734
 128.03734  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-128.03734  def /maxTickline 128.03734  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 128.03734
0.0 -128.03734   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 128.03734
0.0 -128.03734 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 25526 51500 a Fk(1)25526 48351
y(2)25526 45201 y(3)25526 42051 y(4)24794 57753 y Fj(\000)p
Fk(1)24794 60903 y Fj(\000)p Fk(2)24794 64053 y Fj(\000)p
Fk(3)24794 67202 y Fj(\000)p Fk(4)29686 55710 y(1)2679
b(2)h(3)g(4)-16584 b Fj(\000)p Fk(1)-4352 b Fj(\000)p
Fk(2)h Fj(\000)p Fk(3)f Fj(\000)p Fk(4)26771 54365 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end

26771 54365 a 26771 54365 a
tx@Dict begin  { 128.03734 128.03734 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 26771 54365 a 26771 54365
a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 26771 54365 a 26401 54650 a Fo(x)26771 54365 y
tx@Dict begin  PutEnd  end
 26771
54365 a 26771 54365 a
tx@Dict begin  PutEnd  end
 26771 54365 a 26771 54365 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 26771
54365 a 26771 54365 a
tx@Dict begin  { 0.0 0.0 pop 128.03734 128.03734 exch pop } PutCoor
PutBegin  end
 26771 54365 a 26771 54365 a
tx@Dict begin  { 5.0 25.05383 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 26771
54365 a 25385 54697 a Fo(F)181 b Fe(\()p Fo(x)p Fe(\))26771
54365 y
tx@Dict begin  PutEnd  end
 26771 54365 a 26771 54365 a
tx@Dict begin  PutEnd  end
 26771 54365 a 1 0 0
TeXcolorrgb @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 1 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def    /x -4.5 def /x1 4.5 def
/dx x1 x sub 49 div def /F@pstplot (-2*x+3)  tx@AlgToPs begin AlgToPs
end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def  /ps@Exit
false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30 28.45274
mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto } { L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt {
moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 1 0 0  setrgbcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 26771
54365 a
tx@Dict begin  { 86.87428 -52.00517 } PutCoor PutBegin  end
 26771 54365 a 1 0 0 TeXcolorrgb 907 x Fo(F)p
1 0 0 TeXcolorrgb 26771 54365 a
tx@Dict begin  PutEnd  end
 26771 54365 a 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 40945 68538 a
currentpoint initclip moveto
 40945
68538 a 12165 68538 a
 currentpoint currentpoint translate 1 0.78137 div 1 0.78137 div scale
neg exch neg exch translate
 12165 68538 a 1 0 0 TeXcolorrgb
921 72522 a Fp(L\366sungssc)-36 b(hl\374ssel:)921 74514
y(Ein)482 b(Punkt)g(ist)g(genau)g(dann)f(zu)h(geb)36
b(en,)482 b(w)-36 b(enn)482 b(die)g(lineare)h(Stammfunktion)f(F)g(durc)
-36 b(h)921 76506 y(den)433 b(Punkt)g Fo(P)983 b Fe(=)803
b(\(1)p Fc(j)p Fe(1\))433 b Fp(v)-36 b(erl\344uft)435
b(und)d(die)i(Steigung)f Fc(\000)p Fe(2)h Fp(hat.)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 47992 7823
a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 9815 a Fl(AN)369
b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
0 TeXcolorgray 24746 81281 a Fp(8)p 0 TeXcolorgray eop
end
%%Page: 9 9
TeXDict begin 9 8 bop 0 TeXcolorgray 0 TeXcolorgray 0
TeXcolorgray -2331 1493 54804 45 v -2331 6795 a Fq(AN)1038
b(3.2)g(-)g(10)f(Eigensc)-60 b(haften)1037 b(der)g(Ableitungsfunktion)
1032 b(einer)-2331 9817 y(P)-60 b(olynomfunktion)920
b(3.Grades)i(-)g(O)-60 b(A)923 b(-)g(Matura)f(2014/15)g(-)h(Ne-)-2331
12839 y(b)60 b(en)-60 b(termin)716 b(2)p 0 TeXcolorgray
-1391 16146 a Fp(10.)p 0 TeXcolorgray 651 w(Die)477 b(nac)-36
b(hstehende)475 b(Abbildung)h(zeigt)h(den)f(Graphen)g(einer)g(P)-36
b(olynomfunktion)478 b Fo(f)618 b Fp(drit-)921 18138
y(ten)644 b(Grades.)i(Die)f(K)-36 b(o)36 b(ordinaten)645
b(der)f(herv)-36 b(orgehob)36 b(enen)645 b(Punkte)f(des)g(Graphen)g
(der)921 20130 y(F)-108 b(unktion)433 b(sind)g(ganzzahlig.)p
0 TeXcolorgray 0 TeXcolorgray 9915 49907 a
 currentpoint currentpoint translate 1.20683 1.20683 scale neg exch
neg exch translate
 9915 49907
a 9915 49907 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 202.01463 a add def
/d 0.0 a add neg def /h 207.7051 a add def a neg d moveto a neg h L
w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 9915 49907 a 20309 44868 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -28.45274 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 108.1205 0.0 -93.89413 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 162.18054 0.0 -45.52455   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 108.1205  0 -93.89413  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -93.89413
 108.1205  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-45.52455  def /maxTickline 162.18054  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 162.18054
0.0 -45.52455   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 108.1205
0.0 -93.89413 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 162.18054  0 -45.52455  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -45.52455
 162.18054  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-93.89413  def /maxTickline 108.1205  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 162.18054
0.0 -45.52455   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 108.1205
0.0 -93.89413 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
19064 42004 a Fk(1)19063 38854 y(2)19063 35704 y(3)19063
32555 y(4)19063 29405 y(5)18331 48257 y Fj(\000)p Fk(1)23223
46213 y(1)2680 b(2)f(3)-13434 b Fj(\000)p Fk(1)-4352
b Fj(\000)p Fk(2)h Fj(\000)p Fk(3)20309 44868 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 20309
44868 a 20309 44868 a
tx@Dict begin  { 108.1205 162.18054 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 20309 44868 a 20309 44868 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 20309
44868 a 19966 45154 a Fp(x)20309 44868 y
tx@Dict begin  PutEnd  end
 20309 44868
a 20309 44868 a
tx@Dict begin  PutEnd  end
 20309 44868 a 20309 44868 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 20309 44868
a 20309 44868 a
tx@Dict begin  { 0.0 0.0 pop 108.1205 162.18054 exch pop } PutCoor
PutBegin  end
 20309 44868 a 20309 44868 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 20309 44868
a 19261 45200 a Fp(f\(x\))20309 44868 y
tx@Dict begin  PutEnd  end
 20309 44868 a
20309 44868 a
tx@Dict begin  PutEnd  end
 20309 44868 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.300000000000001 def /x1 3.8000000000000016
def /dx x1 x sub 199 div def /F@pstplot (x^(3.0)-3.0*x^(2.0)+4.0) 
tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ -28.45274 0.0   false
NArray  /DS 3.0 0. CLW mul add 2 div def /PSTricksDotFont 0. [1.0 0.0
0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale (b) show
grestore } bind def   1. .setopacityalpha  newpath n { transform floor
.5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ 0.0 113.81097   false
NArray  /DS 3.0 0. CLW mul add 2 div def /PSTricksDotFont 0. [1.0 0.0
0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale (b) show
grestore } bind def   1. .setopacityalpha  newpath n { transform floor
.5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ 28.45274 56.90549
  false NArray  /DS 3.0 0. CLW mul add 2 div def /PSTricksDotFont 0.
[1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def   1. .setopacityalpha  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ 56.90549 0.0   false
NArray  /DS 3.0 0. CLW mul add 2 div def /PSTricksDotFont 0. [1.0 0.0
0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale (b) show
grestore } bind def   1. .setopacityalpha  newpath n { transform floor
.5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial 20309 44868 a
tx@Dict begin  { -36.41946 -1.13791 } PutCoor PutBegin  end

20309 44868 a -172 x Fn(f)20309 44868 y
tx@Dict begin  PutEnd  end
 20309 44868 a
32277 49907 a
currentpoint initclip moveto
 32277 49907 a 9915 49907 a
 currentpoint currentpoint translate 1 1.20683 div 1 1.20683 div scale
neg exch neg exch translate
 9915 49907 a
855 53560 a Fp(W)-108 b(elc)-36 b(he)460 b(der)f(folgenden)i(A)-36
b(ussagen)460 b(tre\033en)f(auf)h(die)h(Ableitungsfunktion)f
Fo(f)39771 53078 y Fj(0)40541 53560 y Fp(der)g(F)-108
b(unk-)921 55552 y(tion)434 b Fo(f)575 b Fp(zu?)433 b(Kreuze)h(die)f(b)
36 b(eiden)433 b(zutre\033enden)f(A)-36 b(ussagen)433
b(an.)p 2075 56518 42234 45 v 2075 59736 45 3219 v 2783
58459 a(Die)i(F)-108 b(unktionsw)-36 b(erte)432 b(der)h(F)-108
b(unktion)433 b Fo(f)22848 57977 y Fj(0)23592 58459 y
Fp(sind)g(im)h(In)-36 b(terv)-72 b(all)434 b Fe(\(0;)221
b(2\))435 b Fp(negativ.)p 41899 59736 V 1 0 0 TeXcolorrgb
1374 w Fd(4)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
44265 59736 V 2075 59781 42234 45 v 2075 62999 45 3219
v 2783 61722 a Fp(Die)g(F)-108 b(unktion)432 b Fo(f)11478
61240 y Fj(0)12222 61722 y Fp(ist)i(im)g(In)-36 b(terv)-72
b(all)434 b Fe(\()p Fc(\000)p Fe(1;)221 b(0\))435 b Fp(streng)e
(monoton)h(steigend.)p 41899 62999 V 44265 62999 V 2075
63043 42234 45 v 2075 66165 45 3123 v 2783 64962 a(Die)h(F)-108
b(unktion)432 b Fo(f)11478 64480 y Fj(0)12222 64962 y
Fp(hat)i(an)f(der)g(Stelle)h Fo(x)369 b Fe(=)g(2)434
b Fp(eine)f(W)-108 b(endestelle.)p 41899 66165 V 44265
66165 V 2075 66209 42234 45 v 2075 69332 45 3123 v 2783
68128 a(Die)435 b(F)-108 b(unktion)432 b Fo(f)11478 67646
y Fj(0)12222 68128 y Fp(hat)i(an)f(der)g(Stelle)h Fo(x)369
b Fe(=)g(1)434 b Fp(ein)f(lokales)j(Maxim)-36 b(um.)p
41899 69332 V 44265 69332 V 2075 69376 42234 45 v 2075
72498 45 3123 v 2783 71295 a(Die)435 b(F)-108 b(unktion)432
b Fo(f)11478 70813 y Fj(0)12222 71295 y Fp(hat)i(an)f(der)g(Stelle)h
Fo(x)369 b Fe(=)g(0)434 b Fp(eine)f(Nullstelle.)p 41899
72498 V 1 0 0 TeXcolorrgb 42608 71269 a Fd(4)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 44265 72498
V 2075 72542 42234 45 v 47992 16146 a Fm(___/1)p 1 0 0
TeXcolorrgb 47998 18138 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 76570 54804 45
v 0 TeXcolorgray 24746 81281 a Fp(9)p 0 TeXcolorgray
eop end
%%Page: 10 10
TeXDict begin 10 9 bop 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray -2331 1493 a Fq(AN)1051 b(3.2)f(-)h(11)g(Graphen)f(v)-60
b(on)1050 b(Ableitungsfunktionen)1045 b(-)1051 b(MC)g(-)-2331
4515 y(Matura)717 b(2015/16)g(-)h(Neb)60 b(en)-60 b(termin)716
b(1)p 0 TeXcolorgray -1391 7823 a Fp(11.)p 0 TeXcolorgray
651 w(In)482 b(den)g(un)-36 b(ten)481 b(stehenden)g(Abbildungen)g(sind)
h(jew)-36 b(eils)483 b(die)g(Graphen)e(der)g(F)-108 b(unktionen)921
9815 y Fo(f)142 b Fp(,)434 b Fo(g)481 b Fp(und)432 b
Fo(h)h Fp(dargestellt.)921 14352 y(In)414 b(einer)h(der)f(sec)-36
b(hs)414 b(Abbildungen)f(ist)i Fo(g)462 b Fp(die)415
b(erste)f(Ableitung)g(v)-36 b(on)415 b Fo(f)557 b Fp(und)413
b Fo(h)h Fp(die)h(zw)-36 b(eite)873 16344 y(Ableitung)433
b(v)-36 b(on)434 b Fo(f)142 b Fp(.)434 b(Kreuze)f(diese)h(Abbildung)e
(an.)p 0 TeXcolorgray 0 TeXcolorgray 2800 22256 20905
45 v 2800 37582 45 15326 v 3508 36637 a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 3508 36637 a
3508 36637 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 3508 36637 a 14909 21822 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
14909 21822 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 14909 21822 a 14909 21822 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 14909 21822
a 14909 21822 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 14909 21822 a 14539 22108 a Fo(x)14909
21822 y
tx@Dict begin  PutEnd  end
 14909 21822 a 14909 21822 a
tx@Dict begin  PutEnd  end
 14909 21822 a 14909
21822 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 14909 21822 a 14909 21822 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 14909 21822 a 14909
21822 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 14909 21822 a 10600 22154 a Fo(f)142 b Fe(\()p
Fo(x)p Fe(\))p Fo(;)221 b(g)48 b Fe(\()p Fo(x)p Fe(\))p
Fo(;)221 b(h)p Fe(\()p Fo(x)p Fe(\))14909 21822 y
tx@Dict begin  PutEnd  end
 14909
21822 a 14909 21822 a
tx@Dict begin  PutEnd  end
 14909 21822 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (-.4*x+1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)/5.0-6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (1.0/15.0*x^(3.0)-3.0/5.0*x^(2.0)+3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 14909 21822 a
tx@Dict begin  { -85.35823 56.90549 } PutCoor PutBegin  end
 14909 21822 a
923 x Fo(h)14909 21822 y
tx@Dict begin  PutEnd  end
 14909 21822 a 14909 21822 a
tx@Dict begin  { 170.71646 -5.53894 } PutCoor PutBegin  end

14909 21822 a 572 x Fo(g)14909 21822 y
tx@Dict begin  PutEnd  end
 14909 21822 a
14909 21822 a
tx@Dict begin  { 46.96812 76.41203 } PutCoor PutBegin  end
 14909 21822 a 923 x Fo(f)14909 21822 y
tx@Dict begin  PutEnd  end

14909 21822 a 44967 36637 a
currentpoint initclip moveto
 44967 36637 a 3508 36637
a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 3508 36637 a 21295 37582 45 15326 v 23660 37582 V 2800
37626 20905 45 v 2800 52952 45 15326 v 3508 52007 a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 3508
52007 a 3508 52007 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 3508 52007 a 14909 37192 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
14909 37192 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 14909 37192 a 14909 37192 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 14909 37192
a 14909 37192 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 14909 37192 a 14539 37478 a Fo(x)14909
37192 y
tx@Dict begin  PutEnd  end
 14909 37192 a 14909 37192 a
tx@Dict begin  PutEnd  end
 14909 37192 a 14909
37192 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 14909 37192 a 14909 37192 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 14909 37192 a 14909
37192 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 14909 37192 a 10600 37524 a Fo(f)142 b Fe(\()p
Fo(x)p Fe(\))p Fo(;)221 b(g)48 b Fe(\()p Fo(x)p Fe(\))p
Fo(;)221 b(h)p Fe(\()p Fo(x)p Fe(\))14909 37192 y
tx@Dict begin  PutEnd  end
 14909
37192 a 14909 37192 a
tx@Dict begin  PutEnd  end
 14909 37192 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (.4*x-1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)/5.0-6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (1.0/15.0*x^(3.0)-3.0/5.0*x^(2.0)+3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 14909 37192 a
tx@Dict begin  { 149.45418 42.67911 } PutCoor PutBegin  end
 14909 37192 a
923 x Fo(h)14909 37192 y
tx@Dict begin  PutEnd  end
 14909 37192 a 14909 37192 a
tx@Dict begin  { 170.71646 -5.53894 } PutCoor PutBegin  end

14909 37192 a 572 x Fo(g)14909 37192 y
tx@Dict begin  PutEnd  end
 14909 37192 a
14909 37192 a
tx@Dict begin  { 46.96812 76.41203 } PutCoor PutBegin  end
 14909 37192 a 923 x Fo(f)14909 37192 y
tx@Dict begin  PutEnd  end

14909 37192 a 44967 52007 a
currentpoint initclip moveto
 44967 52007 a 3508 52007
a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 3508 52007 a 21295 52952 45 15326 v 1 0 0 TeXcolorrgb
22003 45621 a Fd(4)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray 23660 52952 V 2800 52996 20905 45 v 2800
68322 45 15326 v 3508 67377 a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 3508 67377 a 3508 67377
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 3508 67377 a 14909 52562 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 14909 52562 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end

14909 52562 a 14909 52562 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 14909 52562 a 14909 52562
a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 14909 52562 a 14539 52848 a Fo(x)14909 52562 y
tx@Dict begin  PutEnd  end
 14909
52562 a 14909 52562 a
tx@Dict begin  PutEnd  end
 14909 52562 a 14909 52562 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 14909
52562 a 14909 52562 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 14909 52562 a 14909 52562 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 14909
52562 a 10600 52894 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))p
Fo(;)221 b(g)48 b Fe(\()p Fo(x)p Fe(\))p Fo(;)221 b(h)p
Fe(\()p Fo(x)p Fe(\))14909 52562 y
tx@Dict begin  PutEnd  end
 14909 52562 a 14909
52562 a
tx@Dict begin  PutEnd  end
 14909 52562 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (-.4*x+1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (-x^(2.0)/5.0+6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (1.0/15.0*x^(3.0)-3.0/5.0*x^(2.0)+3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 14909 52562 a
tx@Dict begin  { -85.35823 56.90549 } PutCoor PutBegin  end
 14909 52562 a
922 x Fo(h)14909 52562 y
tx@Dict begin  PutEnd  end
 14909 52562 a 14909 52562 a
tx@Dict begin  { 156.49008 36.98865 } PutCoor PutBegin  end

14909 52562 a 572 x Fo(g)14909 52562 y
tx@Dict begin  PutEnd  end
 14909 52562 a
14909 52562 a
tx@Dict begin  { 46.96812 76.41203 } PutCoor PutBegin  end
 14909 52562 a 922 x Fo(f)14909 52562 y
tx@Dict begin  PutEnd  end

14909 52562 a 44967 67377 a
currentpoint initclip moveto
 44967 67377 a 3508 67377
a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 3508 67377 a 21295 68322 45 15326 v 23660 68322 V 2800
68366 20905 45 v 24758 22256 19912 45 v 24758 37582 45
15326 v 25466 36637 a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 25466 36637 a 25466 36637 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466
36637 a 36867 21822 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 36867 21822 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end

36867 21822 a 36867 21822 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 36867 21822 a 36867 21822
a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 36867 21822 a 36497 22108 a Fo(x)36867 21822 y
tx@Dict begin  PutEnd  end
 36867
21822 a 36867 21822 a
tx@Dict begin  PutEnd  end
 36867 21822 a 36867 21822 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36867
21822 a 36867 21822 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 36867 21822 a 36867 21822 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36867
21822 a 32557 22154 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))p
Fo(;)221 b(g)48 b Fe(\()p Fo(x)p Fe(\))p Fo(;)221 b(h)p
Fe(\()p Fo(x)p Fe(\))36867 21822 y
tx@Dict begin  PutEnd  end
 36867 21822 a 36867
21822 a
tx@Dict begin  PutEnd  end
 36867 21822 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (-.4*x+1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)/5.0-6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (-1.0/15.0*x^(3.0)+3.0/5.0*x^(2.0)-3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 36867 21822 a
tx@Dict begin  { -93.89413 68.2864 } PutCoor PutBegin  end
 36867 21822 a
923 x Fo(h)36867 21822 y
tx@Dict begin  PutEnd  end
 36867 21822 a 36867 21822 a
tx@Dict begin  { 170.71646 -5.53894 } PutCoor PutBegin  end

36867 21822 a 572 x Fo(g)36867 21822 y
tx@Dict begin  PutEnd  end
 36867 21822 a
36867 21822 a
tx@Dict begin  { 99.5846 76.41203 } PutCoor PutBegin  end
 36867 21822 a 923 x Fo(f)36867 21822 y
tx@Dict begin  PutEnd  end

36867 21822 a 66925 36637 a
currentpoint initclip moveto
 66925 36637 a 25466 36637
a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 25466 36637 a 43253 37582 45 15326 v 44625 37582 V
24758 37626 19912 45 v 24758 52952 45 15326 v 25466 52007
a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 25466 52007 a 25466 52007 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466 52007 a 36867 37192
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 36867 37192 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 36867 37192 a
36867 37192 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 36867 37192 a 36867 37192 a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 36867 37192
a 36497 37478 a Fo(x)36867 37192 y
tx@Dict begin  PutEnd  end
 36867 37192 a 36867
37192 a
tx@Dict begin  PutEnd  end
 36867 37192 a 36867 37192 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36867 37192 a 36867
37192 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 36867 37192 a 36867 37192 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36867 37192 a 32557
37524 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))p Fo(;)221 b(g)48
b Fe(\()p Fo(x)p Fe(\))p Fo(;)221 b(h)p Fe(\()p Fo(x)p
Fe(\))36867 37192 y
tx@Dict begin  PutEnd  end
 36867 37192 a 36867 37192 a
tx@Dict begin  PutEnd  end
 36867
37192 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (.4*x-1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (-x^(2.0)/5.0+6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (-1.0/15.0*x^(3.0)+3.0/5.0*x^(2.0)-3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
36867 37192 a
tx@Dict begin  { 149.45418 42.67911 } PutCoor PutBegin  end
 36867 37192 a 923 x Fo(h)36867 37192 y
tx@Dict begin  PutEnd  end

36867 37192 a 36867 37192 a
tx@Dict begin  { 156.49008 36.98865 } PutCoor PutBegin  end
 36867 37192 a 572 x Fo(g)36867
37192 y
tx@Dict begin  PutEnd  end
 36867 37192 a 36867 37192 a
tx@Dict begin  { 99.5846 76.41203 } PutCoor PutBegin  end
 36867 37192 a 923
x Fo(f)36867 37192 y
tx@Dict begin  PutEnd  end
 36867 37192 a 66925 52007 a
currentpoint initclip moveto
 66925
52007 a 25466 52007 a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 25466 52007 a 43253 52952 45 15326
v 44625 52952 V 24758 52996 19912 45 v 24758 68322 45
15326 v 25466 67377 a
 currentpoint currentpoint translate 0.413 0.413 scale neg exch neg
exch translate
 25466 67377 a 25466 67377 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 374.52588 a add def
/d 0.0 a add neg def /h 293.89343 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466
67377 a 36867 52562 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -113.81097 T 11
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.4  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 271.53275 0.0 -102.99313 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.4  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.5  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 160.0584 0.0 -133.83504   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.5  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 271.53275  0 -102.99313  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -102.99313
 271.53275  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-133.83504  def /maxTickline 160.0584  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 160.0584  0 -133.83504  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -133.83504
 160.0584  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-102.99313  def /maxTickline 271.53275  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 160.0584
0.0 -133.83504   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 271.53275
0.0 -102.99313 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 36867 52562 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end

36867 52562 a 36867 52562 a
tx@Dict begin  { 271.53275 160.0584 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 36867 52562 a 36867 52562
a
tx@Dict begin  { 5.0 6.67703 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 36867 52562 a 36497 52848 a Fo(x)36867 52562 y
tx@Dict begin  PutEnd  end
 36867
52562 a 36867 52562 a
tx@Dict begin  PutEnd  end
 36867 52562 a 36867 52562 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 36867
52562 a 36867 52562 a
tx@Dict begin  { 0.0 0.0 pop 271.53275 160.0584 exch pop } PutCoor
PutBegin  end
 36867 52562 a 36867 52562 a
tx@Dict begin  { 5.0 77.86833 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 36867
52562 a 32557 52894 a Fo(f)142 b Fe(\()p Fo(x)p Fe(\))p
Fo(;)221 b(g)48 b Fe(\()p Fo(x)p Fe(\))p Fo(;)221 b(h)p
Fe(\()p Fo(x)p Fe(\))36867 52562 y
tx@Dict begin  PutEnd  end
 36867 52562 a 36867
52562 a
tx@Dict begin  PutEnd  end
 36867 52562 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 49 div def /F@pstplot (.4*x-1.2)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  49 1 sub { /x x dx add def xy  dup 1.e30
28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto }
{ L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x
x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 0.8 SLW 0  setgray
 1. .setopacityalpha   0  setlinecap [  2.0  2.0 ] 0 0 add  DashLine
 grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (x^(2.0)/5.0-6.0/5.0*x)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinecap [  5.0  5.0 ] 0 0 add
 DashLine  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.619791766083621 def /x1 9.543292745697165
def /dx x1 x sub 199 div def /F@pstplot (-1.0/15.0*x^(3.0)+3.0/5.0*x^(2.0)-3.0)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 1.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 36867 52562 a
tx@Dict begin  { 149.45418 42.67911 } PutCoor PutBegin  end
 36867 52562 a
922 x Fo(h)36867 52562 y
tx@Dict begin  PutEnd  end
 36867 52562 a 36867 52562 a
tx@Dict begin  { 170.71646 -5.53894 } PutCoor PutBegin  end

36867 52562 a 572 x Fo(g)36867 52562 y
tx@Dict begin  PutEnd  end
 36867 52562 a
36867 52562 a
tx@Dict begin  { 99.5846 76.41203 } PutCoor PutBegin  end
 36867 52562 a 922 x Fo(f)36867 52562 y
tx@Dict begin  PutEnd  end

36867 52562 a 66925 67377 a
currentpoint initclip moveto
 66925 67377 a 25466 67377
a
 currentpoint currentpoint translate 1 0.413 div 1 0.413 div scale
neg exch neg exch translate
 25466 67377 a 43253 68322 45 15326 v 44625 68322 V
24758 68366 19912 45 v 47992 7823 a Fm(___/1)p 1 0 0
TeXcolorrgb 47998 9815 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 72394 54804 45
v 0 TeXcolorgray 24421 81281 a Fp(10)p 0 TeXcolorgray
eop end
%%Page: 11 11
TeXDict begin 11 10 bop 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray -2331 1493 a Fq(AN)889 b(3.2)e(-)i(12)f(Eigensc)-60
b(haften)886 b(der)i(zw)-60 b(eiten)888 b(Ableitung)e(-)i(MC)h(-)-2331
4515 y(Matura)717 b(NT)h(2)f(15/16)p 0 TeXcolorgray -1391
7823 a Fp(12.)p 0 TeXcolorgray 651 w(Gegeb)36 b(en)433
b(sind)g(die)h(Graphen)e(v)-36 b(on)434 b(f\374nf)f(reellen)h(F)-108
b(unktionen.)921 10368 y(F)-27 b(\374r)613 b(w)-36 b(elc)g(he)614
b(der)f(angegeb)36 b(enen)613 b(F)-108 b(unktionen)613
b(gilt)h Fo(f)28409 9886 y Fj(00)28975 10368 y Fe(\()p
Fo(x)p Fe(\))675 b Fo(>)g Fe(0)614 b Fp(im)g(In)-36 b(terv)-72
b(all)615 b Fe([)8 b Fc(\000)p Fe(1;)221 b(1])p Fp(?)921
12360 y(Kreuze)433 b(die)h(b)36 b(eiden)433 b(zutre\033enden)e(Graphen)
i(an!)p 0 TeXcolorgray 0 TeXcolorgray 4702 20264 17100
45 v 4702 31512 45 11248 v 5411 30567 a
 currentpoint currentpoint translate 0.57138 0.57138 scale neg exch
neg exch translate
 5411 30567 a
5411 30567 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 210.55054 a add def
/d 0.0 a add neg def /h 147.95416 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 5411 30567 a 17379 22567 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.43004 0.0 -108.1205 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 75.68439 0.0 -72.26978   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.43004  0 -108.1205  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -108.1205
 102.43004  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-72.26978  def /maxTickline 75.68439  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 75.68439  0 -72.26978  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -72.26978
 75.68439  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-108.1205  def /maxTickline 102.43004  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
16134 19703 a Fk(1)16134 16554 y(2)15402 25956 y Fj(\000)p
Fk(1)15402 29106 y Fj(\000)p Fk(2)20294 23913 y(1)2679
b(2)h(3)-13434 b Fj(\000)p Fk(1)-4352 b Fj(\000)p Fk(2)g
Fj(\000)p Fk(3)17379 22567 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 17379 22567 a 17379 22567
a
tx@Dict begin  { 102.43004 75.68439 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 17379 22567 a 17379 22567 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 17379 22567 a 17036 22853
a Fp(x)17379 22567 y
tx@Dict begin  PutEnd  end
 17379 22567 a 17379 22567 a
tx@Dict begin  PutEnd  end
 17379
22567 a 17379 22567 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 17379 22567 a 17379 22567 a
tx@Dict begin  { 0.0 0.0 pop 102.43004 75.68439 exch pop } PutCoor
PutBegin  end
 17379
22567 a 17379 22567 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 17379 22567 a 16331 22899 a Fp(f\(x\))17379
22567 y
tx@Dict begin  PutEnd  end
 17379 22567 a 17379 22567 a
tx@Dict begin  PutEnd  end
 17379 22567 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.8000000000000016 def /x1 3.5999999999999948
def /dx x1 x sub 199 div def /F@pstplot (0.4571364969828991*x^(3.0)-1.8285459879315964*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 2.0 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 17379 22567 a
tx@Dict begin  { -71.13185 -24.46938 } PutCoor PutBegin  end
 17379 22567 a
-258 x Fo(f)17379 22567 y
tx@Dict begin  PutEnd  end
 17379 22567 a 28718 30567 a
currentpoint initclip moveto

28718 30567 a 5411 30567 a
 currentpoint currentpoint translate 1 0.57138 div 1 0.57138 div scale
neg exch neg exch translate
 5411 30567 a 19392 31512 45
11248 v 21757 31512 V 4702 31557 17100 45 v 4702 42804
45 11248 v 5411 41859 a
 currentpoint currentpoint translate 0.57138 0.57138 scale neg exch
neg exch translate
 5411 41859 a 5411 41859 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 210.55054 a add def
/d 0.0 a add neg def /h 147.95416 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 5411
41859 a 17379 33859 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.43004 0.0 -108.1205 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 75.68439 0.0 -72.26978   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.43004  0 -108.1205  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -108.1205
 102.43004  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-72.26978  def /maxTickline 75.68439  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 75.68439  0 -72.26978  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -72.26978
 75.68439  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-108.1205  def /maxTickline 102.43004  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 16134 30995 a
Fk(1)16134 27846 y(2)15402 37248 y Fj(\000)p Fk(1)15402
40398 y Fj(\000)p Fk(2)20294 35205 y(1)2679 b(2)h(3)-13434
b Fj(\000)p Fk(1)-4352 b Fj(\000)p Fk(2)g Fj(\000)p Fk(3)17379
33859 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 17379 33859 a 17379 33859 a
tx@Dict begin  { 102.43004 75.68439 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 17379 33859 a 17379
33859 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 17379 33859 a 17036 34145 a Fp(x)17379 33859
y
tx@Dict begin  PutEnd  end
 17379 33859 a 17379 33859 a
tx@Dict begin  PutEnd  end
 17379 33859 a 17379 33859
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 17379 33859 a 17379 33859 a
tx@Dict begin  { 0.0 0.0 pop 102.43004 75.68439 exch pop } PutCoor
PutBegin  end
 17379 33859 a 17379 33859
a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 17379 33859 a 16331 34192 a Fp(f\(x\))17379 33859 y
tx@Dict begin  PutEnd  end

17379 33859 a 17379 33859 a
tx@Dict begin  PutEnd  end
 17379 33859 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.8000000000000016 def /x1 3.5999999999999948
def /dx x1 x sub 199 div def /F@pstplot (0.77*x^2+0.5)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 2.0 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end
 
@endspecial 17379 33859 a
tx@Dict begin  { -48.36957 24.46938 } PutCoor PutBegin  end
 17379 33859 a
-258 x Fo(f)17379 33859 y
tx@Dict begin  PutEnd  end
 17379 33859 a 28718 41859 a
currentpoint initclip moveto

28718 41859 a 5411 41859 a
 currentpoint currentpoint translate 1 0.57138 div 1 0.57138 div scale
neg exch neg exch translate
 5411 41859 a 19392 42804 45
11248 v 1 0 0 TeXcolorrgb 20101 37513 a Fd(4)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 21757 42804
V 4702 42849 17100 45 v 4702 54096 45 11248 v 5411 53152
a
 currentpoint currentpoint translate 0.57138 0.57138 scale neg exch
neg exch translate
 5411 53152 a 5411 53152 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 210.55054 a add def
/d 0.0 a add neg def /h 147.95416 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 5411 53152 a 17379 45152
a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.43004 0.0 -108.1205 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 75.68439 0.0 -72.26978   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.43004  0 -108.1205  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -108.1205
 102.43004  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-72.26978  def /maxTickline 75.68439  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 75.68439  0 -72.26978  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -72.26978
 75.68439  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-108.1205  def /maxTickline 102.43004  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 16134 42287 a Fk(1)16134 39138
y(2)15402 48540 y Fj(\000)p Fk(1)15402 51690 y Fj(\000)p
Fk(2)20294 46497 y(1)2679 b(2)h(3)-13434 b Fj(\000)p
Fk(1)-4352 b Fj(\000)p Fk(2)g Fj(\000)p Fk(3)17379 45152
y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 17379 45152 a 17379 45152 a
tx@Dict begin  { 102.43004 75.68439 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 17379 45152 a 17379 45152
a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 17379 45152 a 17036 45438 a Fp(x)17379 45152 y
tx@Dict begin  PutEnd  end
 17379
45152 a 17379 45152 a
tx@Dict begin  PutEnd  end
 17379 45152 a 17379 45152 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 17379
45152 a 17379 45152 a
tx@Dict begin  { 0.0 0.0 pop 102.43004 75.68439 exch pop } PutCoor
PutBegin  end
 17379 45152 a 17379 45152 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 17379
45152 a 16331 45484 a Fp(f\(x\))17379 45152 y
tx@Dict begin  PutEnd  end
 17379 45152
a 17379 45152 a
tx@Dict begin  PutEnd  end
 17379 45152 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.8000000000000016 def /x1 3.5999999999999948
def /dx x1 x sub 199 div def /F@pstplot (-0.16*x^2-0.32*x-0.8)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 2.0 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end


@endspecial 17379 45152 a
tx@Dict begin  { -71.13185 -24.46938 } PutCoor PutBegin  end
 17379 45152 a -259 x Fo(f)17379
45152 y
tx@Dict begin  PutEnd  end
 17379 45152 a 28718 53152 a
currentpoint initclip moveto
 28718 53152 a 5411
53152 a
 currentpoint currentpoint translate 1 0.57138 div 1 0.57138 div scale
neg exch neg exch translate
 5411 53152 a 19392 54096 45 11248 v 21757 54096
V 4702 54141 17100 45 v 24758 20264 V 24758 31512 45
11248 v 25466 30567 a
 currentpoint currentpoint translate 0.57138 0.57138 scale neg exch
neg exch translate
 25466 30567 a 25466 30567 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 210.55054 a add def
/d 0.0 a add neg def /h 147.95416 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466
30567 a 37435 22567 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.43004 0.0 -108.1205 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 75.68439 0.0 -72.26978   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.43004  0 -108.1205  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -108.1205
 102.43004  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-72.26978  def /maxTickline 75.68439  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 75.68439  0 -72.26978  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -72.26978
 75.68439  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-108.1205  def /maxTickline 102.43004  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 36190 19703 a
Fk(1)36189 16554 y(2)35458 25956 y Fj(\000)p Fk(1)35458
29106 y Fj(\000)p Fk(2)40349 23913 y(1)2680 b(2)f(3)-13434
b Fj(\000)p Fk(1)-4352 b Fj(\000)p Fk(2)h Fj(\000)p Fk(3)37435
22567 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 37435 22567 a 37435 22567 a
tx@Dict begin  { 102.43004 75.68439 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 37435 22567 a 37435
22567 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 37435 22567 a 37092 22853 a Fp(x)37435 22567
y
tx@Dict begin  PutEnd  end
 37435 22567 a 37435 22567 a
tx@Dict begin  PutEnd  end
 37435 22567 a 37435 22567
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 37435 22567 a 37435 22567 a
tx@Dict begin  { 0.0 0.0 pop 102.43004 75.68439 exch pop } PutCoor
PutBegin  end
 37435 22567 a 37435 22567
a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 37435 22567 a 36387 22899 a Fp(f\(x\))37435 22567 y
tx@Dict begin  PutEnd  end

37435 22567 a 37435 22567 a
tx@Dict begin  PutEnd  end
 37435 22567 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.8000000000000016 def /x1 3.5999999999999948
def /dx x1 x sub 199 div def /F@pstplot (1.15)  tx@AlgToPs begin AlgToPs
end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def  /ps@Exit
false def xy moveto  199 1 sub { /x x dx add def xy  dup 1.e30 28.45274
mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto } { L } ifelse
} ifelse  } ps@Exit { exit } if repeat ps@Exit not { /x x1 def xy 
dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt {
moveto } { L } ifelse } ifelse  } if  gsave 2.0 SLW 0  setgray  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 37435 22567 a
tx@Dict begin  { -48.36957 18.7789 } PutCoor PutBegin  end
 37435 22567 a
-258 x Fo(f)37435 22567 y
tx@Dict begin  PutEnd  end
 37435 22567 a 48773 30567 a
currentpoint initclip moveto

48773 30567 a 25466 30567 a
 currentpoint currentpoint translate 1 0.57138 div 1 0.57138 div scale
neg exch neg exch translate
 25466 30567 a 39448 31512
45 11248 v 41813 31512 V 24758 31557 17100 45 v 24758
42804 45 11248 v 25466 41859 a
 currentpoint currentpoint translate 0.57138 0.57138 scale neg exch
neg exch translate
 25466 41859 a 25466 41859
a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 210.55054 a add def
/d 0.0 a add neg def /h 147.95416 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 25466 41859 a 37435 33859 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 6 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 102.43004 0.0 -108.1205 0.0   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -85.35823 0.0 T 8 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 75.68439 0.0 -72.26978   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 102.43004  0 -108.1205  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -108.1205
 102.43004  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-72.26978  def /maxTickline 75.68439  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 75.68439  0 -72.26978  ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -72.26978
 75.68439  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-108.1205  def /maxTickline 102.43004  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 75.68439
0.0 -72.26978   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 102.43004
0.0 -108.1205 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 36190 30995 a
Fk(1)36189 27846 y(2)35458 37248 y Fj(\000)p Fk(1)35458
40398 y Fj(\000)p Fk(2)40349 35205 y(1)2680 b(2)f(3)-13434
b Fj(\000)p Fk(1)-4352 b Fj(\000)p Fk(2)h Fj(\000)p Fk(3)37435
33859 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 37435 33859 a 37435 33859 a
tx@Dict begin  { 102.43004 75.68439 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 37435 33859 a 37435
33859 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 37435 33859 a 37092 34145 a Fp(x)37435 33859
y
tx@Dict begin  PutEnd  end
 37435 33859 a 37435 33859 a
tx@Dict begin  PutEnd  end
 37435 33859 a 37435 33859
a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 37435 33859 a 37435 33859 a
tx@Dict begin  { 0.0 0.0 pop 102.43004 75.68439 exch pop } PutCoor
PutBegin  end
 37435 33859 a 37435 33859
a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 37435 33859 a 36387 34192 a Fp(f\(x\))37435 33859 y
tx@Dict begin  PutEnd  end

37435 33859 a 37435 33859 a
tx@Dict begin  PutEnd  end
 37435 33859 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -3.8000000000000016 def /x1 3.5999999999999948
def /dx x1 x sub 199 div def /F@pstplot (1/2.718^x)  tx@AlgToPs begin
AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul } def
 /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy  dup
1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt { moveto
} { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit not {
/x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } if  gsave 2.0 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 37435 33859 a
tx@Dict begin  { -22.76227 24.46938 } PutCoor PutBegin  end
 37435 33859 a
-258 x Fo(f)37435 33859 y
tx@Dict begin  PutEnd  end
 37435 33859 a 48773 41859 a
currentpoint initclip moveto

48773 41859 a 25466 41859 a
 currentpoint currentpoint translate 1 0.57138 div 1 0.57138 div scale
neg exch neg exch translate
 25466 41859 a 39448 42804
45 11248 v 1 0 0 TeXcolorrgb 40156 37513 a Fd(4)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 41813 42804
V 24758 42849 17100 45 v 47992 7823 a Fm(___/1)p 1 0 0
TeXcolorrgb 47998 9815 a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 58169 54804 45
v 0 TeXcolorgray 24421 81281 a Fp(11)p 0 TeXcolorgray
eop end
%%Page: 12 12
TeXDict begin 12 11 bop 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray -2331 1599 a Fq(AN)842 b(3.2)f(-)g(13)g(Ableitung)e(-)j
(O)-60 b(A)841 b(-)h(Matura)f(2013/14)g(1.)g(Neb)60 b(en-)-2331
4622 y(termin)p 0 TeXcolorgray -1391 7929 a Fp(13.)p
0 TeXcolorgray 651 w(In)613 b(der)g(nac)-36 b(hstehenden)611
b(Abbildung)h(ist)h(der)g(Graph)f(der)h(1.)i(Ableitungsfunktion)e
Fo(f)45586 7447 y Fj(0)921 9921 y Fp(einer)433 b(P)-36
b(olynomfunktion)435 b Fo(f)575 b Fp(dargestellt.)p 0
TeXcolorgray 0 TeXcolorgray 7666 33456 a
 currentpoint currentpoint translate 0.79463 0.79463 scale neg exch
neg exch translate
 7666 33456 a
7666 33456 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 357.93555 a add def
/d 0.0 a add neg def /h 240.70995 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 7666 33456 a 25808 25645 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -56.90549 T 9 {
gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0
0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 194.04791 0.0 -163.88763 0.0   /Lineto /lineto load def
0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -142.26372 0.0 T 13
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.75  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 170.14728 0.0 -70.56267   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.75  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 194.04791  0 -163.88763  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -163.88763
 194.04791  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-70.56267  def /maxTickline 170.14728  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 170.14728
0.0 -70.56267   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 194.04791
0.0 -163.88763 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 170.14728  0 -70.56267  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -70.56267
 170.14728  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-163.88763  def /maxTickline 194.04791  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 170.14728
0.0 -70.56267   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 194.04791
0.0 -163.88763 0.0   /Lineto /lineto load def 0  setlinejoin false
 NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
24563 22781 a Fk(1)24563 19631 y(2)24563 16481 y(3)24563
13332 y(4)24563 10182 y(5)23831 29034 y Fj(\000)p Fk(1)23831
32183 y Fj(\000)p Fk(2)28722 26990 y(1)2680 b(2)f(3)h(4)g(5)f(6)-22883
b Fj(\000)p Fk(1)-4351 b Fj(\000)p Fk(2)f Fj(\000)p Fk(3)g
Fj(\000)p Fk(4)h Fj(\000)p Fk(5)25808 25645 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 25808 25645
a 25808 25645 a
tx@Dict begin  { 194.04791 170.14728 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 25808 25645 a 25808 25645 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 25808 25645
a 25465 25931 a Fp(x)25808 25645 y
tx@Dict begin  PutEnd  end
 25808 25645 a 25808
25645 a
tx@Dict begin  PutEnd  end
 25808 25645 a 25808 25645 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 25808 25645 a 25808
25645 a
tx@Dict begin  { 0.0 0.0 pop 194.04791 170.14728 exch pop } PutCoor
PutBegin  end
 25808 25645 a 25808 25645 a
tx@Dict begin  { 5.0 22.5208 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 25808 25645 a 24562
25977 a Fp(f)36 b('\(x\))25808 25645 y
tx@Dict begin  PutEnd  end
 25808 25645 a
25808 25645 a
tx@Dict begin  PutEnd  end
 25808 25645 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -5.760000000000003 def /x1 6.820000000000001
def /dx x1 x sub 199 div def /F@pstplot (-0.25*x^(2.0)+4.0)  tx@AlgToPs
begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot 28.45274 mul
} def  /ps@Exit false def xy moveto  199 1 sub { /x x dx add def xy
 dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274 mul lt
{ moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat ps@Exit
not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30
28.45274 mul lt { moveto } { L } ifelse } ifelse  } if  gsave 1.2 SLW
0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke
 grestore end


@endspecial 25808 25645 a
tx@Dict begin  { 72.83894 79.66776 } PutCoor PutBegin  end
 25808 25645 a 915 x Fp(f)g(')25808
25645 y
tx@Dict begin  PutEnd  end
 25808 25645 a 47288 33456 a
currentpoint initclip moveto
 47288 33456 a 7666
33456 a
 currentpoint currentpoint translate 1 0.79463 div 1 0.79463 div scale
neg exch neg exch translate
 7666 33456 a 921 37440 a Fp(Bestimme,)644 b(an)f(w)-36
b(elc)g(hen)643 b(Stellen)g(die)h(F)-108 b(unktion)642
b Fo(f)785 b Fp(im)644 b(In)-36 b(terv)-72 b(all)644
b Fe(\()p Fc(\000)p Fe(5;)221 b(5\))644 b Fp(jedenfalls)921
39432 y(lokale)318 b(Extrema)f(hat!)h(Die)f(f\374r)f(die)h(Bestimm)-36
b(ung)316 b(relev)-72 b(an)-36 b(ten)317 b(Punkte)f(mit)g(ganzzahligen)
921 41424 y(K)-36 b(o)36 b(ordinaten)434 b(k)-36 b(\366nnen)433
b(der)g(Abbildung)f(en)-36 b(tnommen)433 b(w)-36 b(erden.)p
1 0 0 TeXcolorrgb 873 45961 a(An)433 b(den)g(Stellen)g
Fo(x)10463 46160 y Fk(1)11358 45961 y Fe(=)369 b Fc(\000)p
Fe(4)434 b Fp(und)e Fo(x)18196 46160 y Fk(2)19091 45961
y Fe(=)369 b(4)434 b Fp(hat)f Fo(f)575 b Fp(lokale)436
b(Extrema.)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
47992 7929 a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 9921
a Fl(AN)369 b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb
0 TeXcolorgray -2331 49695 54804 45 v 0 TeXcolorgray
24421 81281 a Fp(12)p 0 TeXcolorgray eop end
%%Page: 13 13
TeXDict begin 13 12 bop 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray -2331 1599 a Fq(AN)637 b(3.2)e(-)i(14)e(Gra\034sc)-60
b(h)636 b(di\033erenzieren)f(-)h(O)-60 b(A)636 b(-)h(Matura)e(2016/17)
-2617 4622 y(-)718 b(Haupttermin)p 0 TeXcolorgray -1391
7929 a Fp(14.)p 0 TeXcolorgray 651 w(Gegeb)36 b(en)433
b(ist)h(der)f(Graph)f(einer)h(P)-36 b(olynomfunktion)435
b(dritten)e(Grades)g Fo(f)142 b Fp(.)p 0 TeXcolorgray
0 TeXcolorgray 5417 41953 a
 currentpoint currentpoint translate 0.73058 0.73058 scale neg exch
neg exch translate
 5417 41953 a 5851 41953 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 441.0175 a add def
/d 0.0 a add neg def /h 391.50957 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end

5851 41953 a 33000 25764 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  0.0 -142.26372 T 14
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.3  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 195.755 0.0 -245.2625 0.0   /Lineto /lineto load def 0 
setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ()
length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add
/arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2
y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1
Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.3  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 0.0 28.45274 T } repeat end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  -227.62195 0.0 T 16
{ gsave  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def /ArrowInside { } def  gsave 0.4 SLW 0.3  setgray  /ArrowA {
BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0
moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale 1
setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def /ArrowInside
{ } def  [ 0.0 245.2625 0.0 -146.24707   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
() length 0 gt { 3.0 2.  CLW mul add dup 1.4  mul exch 0.25 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 0.4 SLW 0.3  setgray  1. .setopacityalpha
  1  setlinecap [  1.5  1.5 ] -2 -1 add  DashLine  grestore grestore
grestore 28.45274 0.0 T } repeat end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 195.755  0 -245.2625  0 ArrowA CP 4
2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -245.2625
 195.755  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-146.24707  def /maxTickline 245.2625  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 28.45274
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 245.2625
0.0 -146.24707   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 195.755
0.0 -245.2625 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 245.2625  0 -146.24707  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -146.24707
 245.2625  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-245.2625  def /maxTickline 195.755  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-2.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 28.45274  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 28.45274  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 245.2625
0.0 -146.24707   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 195.755
0.0 -245.2625 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 33000 25764 a
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end

33000 25764 a 33000 25764 a
tx@Dict begin  { 195.755 245.2625 pop 0.0 0.0 exch pop } PutCoor PutBegin
 end
 33000 25764 a 33000 25764
a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 33000 25764 a 32657 26050 a Fp(x)33000 25764 y
tx@Dict begin  PutEnd  end
 33000
25764 a 33000 25764 a
tx@Dict begin  PutEnd  end
 33000 25764 a 33000 25764 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end
 33000
25764 a 33000 25764 a
tx@Dict begin  { 0.0 0.0 pop 195.755 245.2625 exch pop } PutCoor PutBegin
 end
 33000 25764 a 33000 25764 a
tx@Dict begin  { 5.0 18.93042 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 33000
25764 a 31952 26096 a Fp(f\(x\))33000 25764 y
tx@Dict begin  PutEnd  end
 33000 25764
a 33000 25764 a
tx@Dict begin  PutEnd  end
 33000 25764 a 1 0 0 TeXcolorrgb @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 1 0 0  setrgbcolor  /ArrowA { moveto
} def /ArrowB { } def /ArrowInside { } def    /x -7 def /x1 2 def /dx
x1 x sub 199 div def /F@pstplot (0.31003100310031*x^(2.0)+1.24012401240124*x)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 0 0 0 TeXcolorrgb @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.8 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -8.620000000000006 def /x1 6.88
def /dx x1 x sub 199 div def /F@pstplot (0.1034*x^(3.0)+0.62*x^(2.0)+1.7)
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 28.45274 mul F@pstplot
28.45274 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 28.45274 mul gt { moveto } { dup -1.e30 28.45274
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 28.45274 mul gt { moveto } {
dup -1.e30 28.45274 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 0.8 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial 33000 25764 a
tx@Dict begin  { 47.23164 169.57854 } PutCoor PutBegin  end
 33000 25764 a
922 x Fo(f)33000 25764 y
tx@Dict begin  PutEnd  end
 33000 25764 a 33000 25764 a
tx@Dict begin  { 47.8004 73.9773 } PutCoor PutBegin  end

33000 25764 a 974 x Fo(f)33783 26256 y Fj(0)33000 25764
y
tx@Dict begin  PutEnd  end
 33000 25764 a 33000 25764 a
tx@Dict begin  { -205.99802 -5.12128 } PutCoor PutBegin  end
 33000 25764 a 571 x Fo(x)33739
26534 y Fk(1)33000 25764 y
tx@Dict begin  PutEnd  end
 33000 25764 a 33000 25764
a
tx@Dict begin  { 51.21501 -5.69046 } PutCoor PutBegin  end
 33000 25764 a 571 x Fo(x)33739 26534 y Fk(2)33000 25764
y
tx@Dict begin  PutEnd  end
 33000 25764 a 1 0 0 TeXcolorrgb @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  [ -113.81097
0.0   false NArray  /DS 5.0 0. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def   1. .setopacityalpha  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end


@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 1 0 0  setrgbcolor  [ 0.0 0.0 
 false NArray  /DS 5.0 0. CLW mul add 2 div def /PSTricksDotFont 0.
[1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def   1. .setopacityalpha  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 0 0 TeXcolorrgb 1 0 0
TeXcolorrgb 0 TeXcolorgray 54670 41953 a
currentpoint initclip moveto
 54670 41953
a 5417 41953 a
 currentpoint currentpoint translate 1 0.73058 div 1 0.73058 div scale
neg exch neg exch translate
 5417 41953 a 921 45937 a Fp(Skizziere)557
b(in)f(der)f(gegeb)36 b(enen)556 b(Gra\034k)g(den)f(Graphen)f(der)i
(Ableitungsfunktion)g Fo(f)43585 45455 y Fj(0)44451 45937
y Fp(im)921 47929 y(In)-36 b(terv)-72 b(all)434 b Fe([)8
b Fo(x)7195 48128 y Fk(1)7721 47929 y Fe(;)221 b Fo(x)9042
48128 y Fk(2)9569 47929 y Fe(])433 b Fp(und)g(markiere)h(gegeb)36
b(enenfalls)435 b(die)f(Nullstellen!)p 1 0 0 TeXcolorrgb
921 52466 a(L\366sungssc)-36 b(hl\374ssel:)921 55012
y(Ein)455 b(Punkt)f(f\374r)h(eine)g(k)-36 b(orrekte)456
b(Darstellung)g(der)e(Ableitungsfunktion)h Fo(f)38615
54530 y Fj(0)38926 55012 y Fp(.)g(Der)g(Graph)921 57004
y(der)336 b(F)-108 b(unktion)335 b Fo(f)9295 56521 y
Fj(0)9942 57004 y Fp(m)-36 b(uss)336 b(erk)-36 b(enn)g(bar)335
b(die)h(F)-108 b(orm)336 b(einer)g(nac)-36 b(h)336 b(ob)36
b(en)336 b(o\033enen)f(P)-36 b(arab)36 b(el)337 b(hab)36
b(en)921 58995 y(und)435 b(die)g Fo(x)p Fp(-A)-36 b(c)g(hse)435
b(an)h(den)f(b)36 b(eiden)436 b(Stellen)f(sc)-36 b(hneiden,)435
b(b)36 b(ei)436 b(denen)f(die)h(F)-108 b(unktion)435
b Fo(f)577 b Fp(die)921 60987 y(Extremstellen)492 b(hat.)h(Der)f(Graph)
f(einer)h(en)-36 b(tsprec)g(henden)490 b(F)-108 b(unktion)491
b Fo(f)37490 60505 y Fj(0)37801 60987 y Fp(,)h(der)g(\374b)36
b(er)491 b(das)921 62979 y(In)-36 b(terv)-72 b(all)434
b Fe([)8 b Fo(x)7195 63178 y Fk(1)7721 62979 y Fe(;)221
b Fo(x)9042 63178 y Fk(2)9569 62979 y Fe(])433 b Fp(hinaus)h(gezeic)-36
b(hnet)433 b(ist,)h(ist)g(eb)36 b(enfalls)434 b(als)g(ric)-36
b(h)g(tig)434 b(zu)f(w)-36 b(erten.)p 0 0 0 TeXcolorrgb
1 0 0 TeXcolorrgb 0 TeXcolorgray 47992 7929 a Fm(___/1)p
1 0 0 TeXcolorrgb 47998 9921 a Fl(AN)369 b(3.2)p 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray -2331 66787
54804 45 v 0 TeXcolorgray 24421 81281 a Fp(13)p 0 TeXcolorgray
eop end
%%Page: 14 14
TeXDict begin 14 13 bop 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray -2331 1493 a Fq(AN)642 b(3.2)f(-)g(15)g
(Di\033erenzieren)g(einer)f(Exp)60 b(onen)-60 b(tialfunktion)636
b(-)642 b(O)-60 b(A)-2617 4515 y(-)718 b(Matura)f(NT)g(1)g(16/17)p
0 TeXcolorgray -1391 7823 a Fp(15.)p 0 TeXcolorgray 651
w(Gegeb)36 b(en)433 b(ist)h(eine)f(F)-108 b(unktion)433
b Fo(f)575 b Fp(mit)434 b Fo(f)142 b Fe(\()p Fo(x)p Fe(\))369
b(=)f Fo(e)24761 7341 y Fn(\025)p Fj(\001)p Fn(x)26590
7823 y Fp(mit)434 b Fo(\025)368 b Fc(2)h Fb(R)p Fp(.)921
10368 y(Die)410 b(nac)-36 b(hstehende)409 b(Abbildung)f(zeigt)j(die)e
(Graphen)g(der)g(F)-108 b(unktion)409 b Fo(f)552 b Fp(und)408
b(ihrer)i(Ablei-)921 12360 y(tungsfunktion)433 b Fo(f)10021
11878 y Fj(0)10332 12360 y Fp(.)p 0 TeXcolorgray 0 TeXcolorgray
921 39665 a
 currentpoint currentpoint translate 1.23318 1.23318 scale neg exch
neg exch translate
 921 39665 a 921 39665 a
tx@Dict begin  CM STV CP T newpath /a 0.0 def /w 329.4703 a add def
/d 0.0 a add neg def /h 170.02682 a add def a neg d moveto a neg h
L w h L w d L closepath clip newpath 0 0 moveto setmatrix end
 921 39665 a 8698
32878 a @beginspecial @setspecial
  tx@Dict begin STP newpath 1.6 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 259.21455  0 -70.25575  0 ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 2 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa -70.25575
 259.21455  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-61.31737  def /maxTickline 108.70946  def /dT 1864679 abs 65536 div
viceversa { neg } if def /DT 0.5 abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-4.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { xStart } def /MaxValue { xEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin 0 
setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch def
logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add div
dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 56.9055  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 56.9055
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.6
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 108.70946
0.0 -61.31737   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.6
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 259.21455
0.0 -70.25575 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 1.6 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 108.70946  0 -61.31737  ArrowA CP
4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 2 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa -61.31737
 108.70946  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
-70.25575  def /maxTickline 259.21455  def /dT 2797019 abs 65536 div
viceversa { neg } if def /DT 1. abs viceversa { neg } if def /subTNo
2 def subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse
-4.0 0.0 /tickend exch def /tickstart exch def /Twidth 0.4  def /subTwidth
0.2  def /STsize 0.75 def /TColor { 0  setgray  } def /subTColor {
0.5  setgray  } def /MinValue { yStart } def /MaxValue { yEnd 3.0 2.
 CLW mul add 1.4  mul viceversa { add epsilon sub }{ sub epsilon add
} ifelse } def /logLines { false } def /LSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin 0
 setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 42.67912  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 42.67912  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.6
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 108.70946
0.0 -61.31737   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0 2.  CLW
mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch def 4
copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def
ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul
add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5
 1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.6
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.25 1.4 3.0 2. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 259.21455
0.0 -70.25575 0.0   /Lineto /lineto load def 0  setlinejoin false 
NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 3.0
2.  CLW mul add dup 1.4  mul exch 0.25 mul neg add /arrowlength exch
def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan
def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.6 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial
7231 28439 a Fk(1)7231 23714 y(2)6499 37841 y Fj(\000)p
Fk(1)8698 32878 y
tx@Dict begin  gsave STV CP T /ps@refangle 140.  def grestore  end
 8698 32878 a 8698 32878 a
tx@Dict begin  { 259.21455 108.70946 pop 0.0 0.0 exch pop } PutCoor
PutBegin  end
 8698 32878
a 8698 32878 a
tx@Dict begin  { 5.0 6.2015 5.16667 0.0 140.  Uput UUput } PutCoor
PutBegin  end
 8698 32878 a 8355 33164 a Fp(x)8698 32878
y
tx@Dict begin  PutEnd  end
 8698 32878 a 8698 32878 a
tx@Dict begin  PutEnd  end
 8698 32878 a 8698 32878 a
tx@Dict begin  gsave STV CP T /ps@refangle -40.  def grestore  end

8698 32878 a 8698 32878 a
tx@Dict begin  { 0.0 0.0 pop 259.21455 108.70946 exch pop } PutCoor
PutBegin  end
 8698 32878 a 8698 32878 a
tx@Dict begin  { 5.0 44.71521 9.0 3.0 -40.  Uput UUput } PutCoor PutBegin
 end
 8698
32878 a 6223 33210 a Fp(f\(x\),f)36 b('\(x\))8698 32878
y
tx@Dict begin  PutEnd  end
 8698 32878 a 8698 32878 a
tx@Dict begin  PutEnd  end
 8698 32878 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -1.2346000372737964 def /x1 4.3
def /dx x1 x sub 199 div def /F@pstplot (2.718281828459045^(-0.5*x))
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 56.9055 mul F@pstplot
42.67912 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 42.67912 mul gt { moveto } { dup -1.e30 42.67912
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 42.67912 mul gt { moveto } {
dup -1.e30 42.67912 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 2.0 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  2.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def    /x -1.2346000372737964 def /x1 4.3
def /dx x1 x sub 199 div def /F@pstplot (-1.0/2.0*2.718281828459045^(-1.0/2.0*x))
 tx@AlgToPs begin AlgToPs end cvx def /xy { x 56.9055 mul F@pstplot
42.67912 mul } def  /ps@Exit false def xy moveto  199 1 sub { /x x
dx add def xy  dup 1.e30 42.67912 mul gt { moveto } { dup -1.e30 42.67912
mul lt { moveto } { L } ifelse } ifelse  } ps@Exit { exit } if repeat
ps@Exit not { /x x1 def xy  dup 1.e30 42.67912 mul gt { moveto } {
dup -1.e30 42.67912 mul lt { moveto } { L } ifelse } ifelse  } if 
gsave 2.0 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
8698 32878 a
tx@Dict begin  { 62.22215 39.32137 } PutCoor PutBegin  end
 8698 32878 a 922 x Fo(f)8698 32878 y
tx@Dict begin  PutEnd  end
 8698
32878 a 8698 32878 a
tx@Dict begin  { 72.07138 -17.35402 } PutCoor PutBegin  end
 8698 32878 a 974 x Fo(f)9481 33370
y Fj(0)8698 32878 y
tx@Dict begin  PutEnd  end
 8698 32878 a 37392 39665 a
currentpoint initclip moveto
 37392
39665 a 921 39665 a
 currentpoint currentpoint translate 1 1.23318 div 1 1.23318 div scale
neg exch neg exch translate
 921 39665 a 3985 x Fp(Gib)433 b(den)g(W)-108
b(ert)433 b(des)g(P)-36 b(arameters)434 b Fo(\025)f Fp(an!)921
48187 y Fo(\025)369 b Fe(=)p 1 0 0 TeXcolorrgb 433 w
Fp(-0,5)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 874 50732
a(T)-108 b(oleranzin)-36 b(terv)-72 b(all:)435 b Fe([)8
b Fc(\000)p Fe(0)p Fo(;)p Fe(55;)221 b Fc(\000)p Fe(0)p
Fo(;)p Fe(45])p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 0 0
TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray 47992 7823
a Fm(___/1)p 1 0 0 TeXcolorrgb 47998 9815 a Fl(AN)369
b(3.2)p 0 0 0 TeXcolorrgb 1 0 0 TeXcolorrgb 0 TeXcolorgray
-2331 54540 54804 45 v 0 TeXcolorgray 24421 81281 a Fp(14)p
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
